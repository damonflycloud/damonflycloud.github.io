<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
    

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.4"/>
<link rel="stylesheet" type="text/css" href="/css/flyCloud.css?v=0.4.4"/>




    <meta name="description" content="Stay Hungry,Stay Foolish" />



  <meta name="keywords" content="Hexo,next" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.4" />


<meta name="description" content="Stay Hungry,Stay Foolish">
<meta property="og:type" content="website">
<meta property="og:title" content="FlyCloud-Blog">
<meta property="og:url" content="damonflycloud.info/index.html">
<meta property="og:site_name" content="FlyCloud-Blog">
<meta property="og:description" content="Stay Hungry,Stay Foolish">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="FlyCloud-Blog">
<meta name="twitter:description" content="Stay Hungry,Stay Foolish">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'hide'
  };
</script>

    <title> FlyCloud-Blog </title>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'eda476eb401cfa8c6acbb4de2a48238b', 'auto');
  ga('send', 'pageview');
</script>







<div class="container one-column 
   page-home 
">
    <div class="headband"></div>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">

        <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">FlyCloud-Blog</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu menu-left">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            <i class="menu-item-icon icon-categories"></i> <br />
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-tags"></i> <br />
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            <i class="menu-item-icon icon-about"></i> <br />
            关于
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
<form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'RpxH2-xz3kTMGTPnfLBm','2.0.0');
</script>

<div class="site-search-toggle"></div>
    </div>
  
</nav>


        </div>
    </header>



    <main id="main" class="main">
        <div class="main-inner">
            <div id="content" class="content">
                
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/06/javascript/javascript-patterns/chapter1/" itemprop="url">
                第一章 绪言
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-06T22:08:29+08:00" content="2015-12-06">
            2015-12-06
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/12/06/javascript/javascript-patterns/chapter1/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/12/06/javascript/javascript-patterns/chapter1/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <p>JavaScript是一门Web开发语言。起初人们只是用它来操作网页中为数不多的元素（比如图片和表单域），但是谁也没想到这门语言可以成长得如此迅速，如今，JavaScript除了适用于客户端浏览器编程外，还可以在越来越多的平台上运行。你可以用它来开发服务端程序（使用.Net或Node.js）、桌面应用程序（运行于桌面操作系统）、应用程序扩展（Firefox插件或者Photoshop扩展）、移动终端应用和纯命令行的批处理脚本。</p>
<p>JavaScript是一门有些独特的语言。它没有类，在很多场景中它都将函数作为“第一型”（first-class objects，中文也有译作“第一类”，以前叫“一等公民”）。起初，许多开发者认为这门语言存在很多缺陷，但最近几年情况发生了微妙的变化。有意思的是，有一些老牌语言比如Java和PHP也已经开始添加诸如闭包和匿名函数等新特性，而闭包和匿名函数则是JavaScript程序员最津津乐道的话题。</p>
<p>尽管JavaScript十分灵活，可以用你所熟悉的其他任何编程语言的编程风格来写JavaScript程序，但最好的方式还是拥抱它的独到之处、学习它所特有的编程模式。</p>
          <div class="post-more-link text-center">
            <a class="btn" href="/2015/12/06/javascript/javascript-patterns/chapter1/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/06/javascript/javascript-patterns/chapter2/" itemprop="url">
                第二章 概要
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-06T22:08:29+08:00" content="2015-12-06">
            2015-12-06
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/12/06/javascript/javascript-patterns/chapter2/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/12/06/javascript/javascript-patterns/chapter2/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>本章将概要介绍一些编写高质量JavaScript的最佳实践、模式和习惯，比如避免全局变量、使用单<code>var</code>声明、预缓存循环中的<code>length</code>、遵守编码约定等等。本章还包括一些编程习惯，这些习惯跟具体的代码关系不大，而是更多关注代码创建的总体过程，包括撰写API文档、同事评审以及使用JSLint。这些习惯和最佳实践可以帮助你写出更好更易读和可维护性更好的代码，当几个月或数年后你再重读你的代码时，就会深有体会了。</p>
<h2 id="编写可维护的代码">编写可维护的代码</h2><p>修复软件bug成本很高，而且随着时间的推移，修复这些bug的成本会越来越高，尤其以出现在已经打包发布的软件中的bug为最甚。发现bug时立刻解决掉是最好的，但前提是你对你的代码依然很熟悉，否则当你转身投入到另外一个项目的开发中后，已经根本不记得当初的代码的模样了。当过了一段时间后你再去阅读当初的代码时你需要更多的时间：</p>
<ul>
<li>重新学习并理解面临的问题</li>
<li>理解用于问题的代码</li>
</ul>
<p>在大项目或者大公司的软件开发中还有另一个问题，就是解决这个bug的人和制造这个bug的人往往不是同一个人（而发现bug的往往又是另外一个人）。因此不管是隔了很长时间重读自己的代码还是阅读团队内其他人的代码，减少理解代码所需的时间成本都是非常重要的。这对于公司的利益底线和工程师的幸福指数同样重要，因为每个人都宁愿去开发新的项目而不愿花很多时间和精力去维护旧代码。</p>
<p>软件开发中的另一个普遍现象是，在读代码上花的时间要远远超过写代码的时间。当你专注于某个问题的时候，你往往会坐下来用一下午的时间写出大量的代码。在当时的场景下，这些代码是可以正常运行的，但当应用趋于成熟，会有很多因素促使你重读代码、改进代码或对代码做微调。比如：</p>
<ul>
<li>发现了bug</li>
<li>需要给应用添加新需求</li>
<li>需要将应用迁移到新的平台中运行（比如当市场中出现了新的浏览器时）</li>
<li>代码重构</li>
<li>由于架构更改或者更换语言导致代码重写</li>
</ul>
<p>这些不确定因素带来的后果是，少数人花几小时写的代码需要很多人花几个星期去阅读它。因此，创建可维护的代码对于一个成功的应用来说至关重要。</p>
<p>可维护的代码意味着代码是：</p>
<ul>
<li>可读的</li>
<li>风格一致的</li>
<li>可预测的</li>
<li>看起来像是同一个人写的</li>
<li>有文档的</li>
</ul>
<p>本章接下来的部分会对这几点深入讲解。</p>
<h2 id="减少全局变量">减少全局变量</h2><p>JavaScript使用函数来管理作用域，在一个函数内定义的变量称作“本地变量”，本地变量在函数外部是不能被访问的。与之相对，“全局变量”是不在任何函数体内部声明的变量，或者是直接使用而未声明的变量。</p>
<p>每一个JavaScript运行环境都有一个“全局对象”，不在任何函数体内使用this就可以获得对这个全局对象的引用。你所创建的每一个全局变量都是这个全局对象的属性。为了方便起见，浏览器会额外提供一个全局对象的属性<code>window</code>，（一般）指向全局对象本身。下面的示例代码展示了如何在浏览器中创建或访问全局变量：</p>
<pre><code>myglobal = <span class="string">"hello"</span>; <span class="comment">// 反模式</span>
<span class="built_in">console</span>.log(myglobal); <span class="comment">// "hello"</span>
<span class="built_in">console</span>.log(<span class="built_in">window</span>.myglobal); <span class="comment">// "hello"</span>
<span class="built_in">console</span>.log(<span class="built_in">window</span>[<span class="string">"myglobal"</span>]); <span class="comment">// "hello"</span>
<span class="built_in">console</span>.log(<span class="keyword">this</span>.myglobal); <span class="comment">// "hello"</span>
</code></pre><h3 id="全局变量的问题">全局变量的问题</h3><p>全局变量的问题是，它们在整个JavaScript应用或者是整个web页面中是始终被所有代码共享的。它们存在于同一个命名空间中，因此命名冲突的情况会时有发生，毕竟在应用程序的不同模块中，经常会出于某种目的定义相同的全局变量。</p>
<p>同样，在网页中嵌入不是页面开发者编写的代码是很常见的，比如：</p>
<ul>
<li>网页中使用了第三方的JavaScript库</li>
<li>网页中使用了广告代码</li>
<li>网页中使用了用以分析流量和点击率的第三方统计代码</li>
<li>网页中使用了很多组件、挂件和按钮等等</li>
</ul>
<p>假设某一段第三方提供的脚本定义了一个全局变量result。随后你在自己写的某个函数中也定义了一个全局变量result。这时，第二个变量就会覆盖第一个，会导致第三方脚本工作不正常。</p>
<p>因此，为了让你的脚本和这个页面中的其他脚本和谐相处，要尽量少使用全局变量，这一点非常重要。本书随后的章节中会讲到一些减少全局变量的技巧和策略，比如使用命名空间或者即时函数等，但减少全局变量最有效的方法还是坚持使用<code>var</code>来声明变量。</p>
<p>在JavaScript中有意无意地创建全局变量是件很容易的事，因为它有两个特性：首先，你可以不声明而直接使用变量，其次，JavaScirpt中具有“隐式全局对象”的概念，也就是说任何不通过<code>var</code>声明的变量都会成为全局对象的一个属性（可以把它们当作全局变量）。(译注：在ES6中可以通过<code>let</code>来声明块级作用域变量。)看一下下面这段代码：</p>
<pre><code>function sum(x, y) {
    // 反模式：隐式全局变量
    <span class="literal">result</span> = x + y;
    <span class="keyword">return</span> <span class="literal">result</span>;
}
</code></pre><p>这段代码中，我们直接使用了<code>result</code>而没有事先声明它。这段代码的确是可以正常工作，但被调用后会产生一个全局变量<code>result</code>，这可能会导致其他问题。</p>
<p>解决办法是，总是使用var来声明变量，下面代码就是改进了的<code>sum()</code>函数：</p>
<pre><code>function sum(x, y) {
    <span class="keyword">var</span> <span class="literal">result</span> = x + y;
    <span class="keyword">return</span> <span class="literal">result</span>;
}
</code></pre><p>另一种创建全局变量的反模式，就是在<code>var</code>声明中使用链式赋值的方法。在下面这个代码片段中，<code>a</code>是局部变量，但<code>b</code>是全局变量，而作者的意图显然不是这样：</p>
<pre><code><span class="comment">// 反模式</span>
<span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>{
    <span class="keyword">var</span> a = b = <span class="number">0</span>;
    <span class="comment">// ...</span>
}
</code></pre><p>为什么会这样呢？因为这里的计算顺序是从右至左的：首先计算表达式<code>b=0</code>，这里的<code>b</code>是未声明的；这个表达式的结果是<code>0</code>，然后通过var创建了本地变量<code>a</code>，并赋值为<code>0</code>。换言之，可以将代码写成这样：</p>
<pre><code><span class="variable"><span class="keyword">var</span> a</span> = (b = <span class="number">0</span>);
</code></pre><p>如果变量b已经被声明，这种链式赋值的写法是可以使用的，不会意外地创建全局变量，比如：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>{
    <span class="keyword">var</span> a, b;
    <span class="comment">// ...</span>
    a = b = <span class="number">0</span>; <span class="comment">// 两个都是本地变量</span>
}
</code></pre><blockquote>
<p>避免使用全局变量的另一个原因是出于可移植性考虑，如果你希望将你的代码运行于不同的平台环境（宿主），那么使用全局变量就非常危险。因为很有可能你无意间创建的某个全局变量在当前的平台环境中是不存在的，你以为可以安全地使用，而在另一个环境中却是本来就存在的。</p>
</blockquote>
<h3 id="忘记var时的副作用">忘记var时的副作用</h3><p>隐式创建的全局变量和显式定义的全局变量之间有着细微的差别，就是通过<code>delete</code>来删除它们的时候表现不一致。</p>
<ul>
<li>通过<code>var</code>创建的全局变量（在任何函数体之外创建的变量）不能被删除。</li>
<li>没有用<code>var</code>创建的隐式全局变量（不考虑函数内的情况）可以被删除。</li>
</ul>
<p>也就是说，隐式全局变量并不算是真正的变量，但它们却是全局对象的属性。属性是可以通过<code>delete</code>运算符删除的，而变量不可以被删除：</p>
<pre><code><span class="comment">// 定义三个全局变量</span>
<span class="keyword">var</span> global_var = <span class="number">1</span>;
global_novar = <span class="number">2</span>; <span class="comment">// 反模式</span>
(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    global_fromfunc = <span class="number">3</span>; <span class="comment">// 反模式</span>
}());

<span class="comment">// 尝试删除</span>
<span class="keyword">delete</span> global_var; <span class="comment">// false</span>
<span class="keyword">delete</span> global_novar; <span class="comment">// true</span>
<span class="keyword">delete</span> global_fromfunc; <span class="comment">// true</span>

<span class="comment">// 测试删除结果</span>
<span class="keyword">typeof</span> global_var; <span class="comment">// "number"</span>
<span class="keyword">typeof</span> global_novar; <span class="comment">// "undefined"</span>
<span class="keyword">typeof</span> global_fromfunc; <span class="comment">// "undefined"</span>
</code></pre><p>在ES5严格模式中，给未声明的变量赋值会报错（比如这段代码中提到的两个反模式）。</p>
<h3 id="访问全局对象">访问全局对象</h3><p>在浏览器中，我们可以随时随地通过<code>window</code>属性来访问全局对象（除非你定义了一个名叫<code>window</code>的局部变量）。但换一个运行环境这个<code>window</code>可能就换成了别的名字（甚至根本就被禁止访问全局对象了）。如果不想通过这种写死<code>window</code>的方式来访问全局变量，那么你可以在任意函数作用域内执行：</p>
<pre><code><span class="keyword">var</span> global = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="keyword">return</span> <span class="keyword">this</span>;
}());
</code></pre><p>这种方式总是可以访问到全局对象，因为在被当作函数（而不是构造函数）执行的函数体内，<code>this</code>总是指向全局对象。但这种情况在ECMAScript5的严格模式中行不通，因此在严格模式中你不得不寻求其他的替代方案。比如，如果你在开发一个库，你会将你的代码包装在一个即时函数中（在第四章会讲到），然后从全局作用域给这个匿名函数传入一个指向<code>this</code>的参数。</p>
<h3 id="单var模式">单var模式</h3><p>在函数的顶部使用唯一一个<code>var</code>语句是非常推荐的一种模式，它有如下一些好处：</p>
<ul>
<li>可以在同一个位置找到函数所需的所有变量</li>
<li>避免在变量声明之前使用这个变量时产生的逻辑错误（参考下一小节“声明提前：分散的var带来的问题”）</li>
<li>提醒你不要忘记声明变量，顺便减少潜在的全局变量</li>
<li>代码量更少（输入代码更少且更易做代码优化）</li>
</ul>
<p>单<code>var</code>模式看起来像这样：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">func</span><span class="params">()</span> <span class="comment">{
    var a = 1,
        b = 2,
        sum = a + b,
        myobject = {}</span>,
        <span class="title">i</span>,
        <span class="title">j</span>;</span>
    <span class="comment">// 函数体…</span>
}
</code></pre><p>你可以使用一个<code>var</code>语句来声明多个变量，变量之间用逗号分隔，也可以在这个语句中加入变量初始化的部分。这是一种非常好的实践方式，可以避免逻辑错误（所有未初始化的变量都被声明了，且值为undefined），并增加了代码的可读性。过段时间后再看这段代码，你可以从初始化的值中大概知道这个变量的用法，比如你一眼就可看出某个变量是对象还是整数。</p>
<p>你可以在声明变量时做一些额外的工作，比如在这个例子中就写了<code>sum=a+b</code>这种代码。另一个例子就是当代码中用到对DOM元素时，你可以把DOM引用赋值的操作也放在这个变量声明语句中，比如下面这段代码：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">updateElement</span>(<span class="params"></span>) </span>{
    <span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">"result"</span>),
        style = el.style;
    <span class="comment">// 使用el和style…</span>
}
</code></pre><h3 id="声明提前：分散的var带来的问题">声明提前：分散的var带来的问题</h3><p>JavaScript允许在函数的任意地方写任意多个<code>var</code>语句，但它们的行为会像在函数体顶部声明变量一样，这种现象被称为“声明提前”，当你在声明语句之前使用这个变量时，可能会造成逻辑错误。对于JavaScript来说，一旦在某个作用域（同一个函数内）里声明了一个变量，那么这个变量在整个作用域内都是存在的，包括在<code>var</code>声明语句之前的位置。看一下这个例子：</p>
<pre><code><span class="comment">// 反模式</span>
myname = <span class="string">"global"</span>; <span class="comment">// 全局变量</span>
function <span class="func"><span class="keyword">func</span><span class="params">()</span></span> {
    alert(myname); <span class="comment">// "undefined"</span>
    <span class="keyword">var</span> myname = <span class="string">"local"</span>;
    alert(myname); <span class="comment">// "local"</span>
}
<span class="func"><span class="keyword">func</span><span class="params">()</span></span>;
</code></pre><p>这个例子中，你可能会期望第一个<code>alert()</code>弹出“global”，第二个<code>alert()</code>弹出“local”。这种结果看起来是合乎常理的，因为在第一个<code>alert()</code>执行时，<code>myname</code>还没有被声明，这时就应该“寻找”全局变量<code>myname</code>。但实际情况并不是这样，第一个<code>alert()</code>弹出“undefined”，因为<code>myname</code>已经在函数内被声明了（尽管声明语句在后面）。所有的变量声明都会被提前到函数的顶部，因此，为了避免类似带有“歧义”的程序逻辑，最好在使用之前一起声明它们。</p>
<p>上一个代码片段等价于下面这个代码片段：</p>
<pre><code>myname = <span class="string">"global"</span>; <span class="comment">// 全局变量</span>
function <span class="func"><span class="keyword">func</span><span class="params">()</span></span> {
    <span class="keyword">var</span> myname; <span class="comment">// 等价于 -&gt; var myname = undefined;</span>
    alert(myname); <span class="comment">// "undefined"</span>
    myname = <span class="string">"local"</span>;
    alert(myname); <span class="comment">// "local"</span>
}
<span class="func"><span class="keyword">func</span><span class="params">()</span></span>;
</code></pre><blockquote>
<p>这里有必要对“变量提前”做进一步补充，实际上从JavaScript引擎的工作机制上看，这个过程稍微有点复杂。代码处理经过了两个阶段：第一阶段是创建变量、函数和形参，也就是预编译的过程，它会扫描整段代码的上下文；第二阶段是在代码的运行时（runtime），这一阶段将创建函数表达式和一些非法的标识符（未声明的变量）。（译注：这两个阶段并没有包含代码的执行，是在执行前的处理过程。）从实用性角度来讲，我们更愿意将这两个阶段归成一个概念“变量提前”，尽管这个概念并没有在ECMAScript标准中定义，但我们常常用它来解释预编译的行为过程。</p>
</blockquote>
<h2 id="for循环">for循环</h2><p>在<code>for</code>循环中，可以对数组或类似数组的对象（比如<code>arguments</code>和<code>HTMLCollection</code>对象）进行遍历，通常<code>for</code>循环模式形如：</p>
<pre><code><span class="comment">// 非最优的循环方式</span>
for <span class="comment">(var i = 0; i &lt; myarray.length; i++)</span> {
    <span class="comment">// 访问myarray[i]…</span>
}
</code></pre><p>这种模式的问题是，每次遍历都会访问数组的length属性，这会降低代码运行效率，特别是当<code>myarray</code>不是一个数组而是一个<code>HTMLCollection</code>对象的时候。</p>
<p><code>HTMLCollection</code>是由DOM方法返回的对象集合，比如：</p>
<ul>
<li>document.getElementsByName()</li>
<li>document.getElementsByClassName()</li>
<li>document.getElementsByTagName()</li>
</ul>
<p>还有一些<code>HTMLCollection</code>是在DOM标准诞生之前就已经在用了并且现在仍然可用，包括：</p>
<ul>
<li><p>document.images</p>
<p>  页面中所有的IMG元素</p>
</li>
<li><p>document.links</p>
<p>  页面中所有的A元素</p>
</li>
<li><p>document.forms</p>
<p>  页面中所有的表单</p>
</li>
<li><p>document.forms[0].elements</p>
<p>  页面中第一个表单的所有字段</p>
</li>
</ul>
<p>这些对象的问题在于，它们都会实时查询文档（HTML页面）中的对象。也就是说每次通过它们访问集合的<code>length</code>属性时，总是都会去查询DOM，而DOM操则是很耗资源的。</p>
<p>更好的办法是在<code>for</code>循环中缓存要遍历的数组的长度，比如下面这段代码：</p>
<pre><code>for <span class="comment">(var i = 0, max = myarray.length; i &lt; max; i++)</span> {
    <span class="comment">// 访问myarray[i]…</span>
}
</code></pre><p>通过这种方法只需要获取<code>length</code>一次，然后在整个循环过程中使用它。</p>
<p>不管在什么浏览器中，在遍历<code>HTMLCollection</code>时缓存<code>length</code>都可以让程序执行的更快，可以提速2倍（Safari3）到190倍（IE7）不等。更多细节可以参照Nicholas Zakas的《高性能JavaScript》，这本书也是由O’Reilly出版。</p>
<p>需要注意的是，当你在循环过程中需要修改这个元素集合（比如增加DOM元素）时，你可能需要更新<code>length</code>。</p>
<p>按照“单<code>var</code>模式”，你可以将<code>var</code>提到循环的外部，比如：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">looper</span><span class="params">()</span> {</span>
    var i = <span class="number">0</span>,
        <span class="built_in">max</span>,
        myarray = [];
    <span class="comment">// …</span>
    <span class="keyword">for</span> (i = <span class="number">0</span>, <span class="built_in">max</span> = myarray.length; i &lt; <span class="built_in">max</span>; i++) {
        <span class="comment">// 访问myarray[i]…</span>
    }
}
</code></pre><p>当你越来越依赖“单<code>var</code>模式”时，带来的好处就是提高了代码的一致性。而缺点则是在重构代码的时候不能直接复制粘贴一个循环体，比如，你正在将某个循环从一个函数复制至另外一个函数中，那么必须确保<code>i</code>和<code>max</code>也复制到新函数里，并且需要从旧函数中将这些没用的变量删除掉。</p>
<p>最后一个需要对循环做出调整的地方是将i++替换成为下面两者之一：</p>
<pre><code><span class="tag">i</span> = <span class="tag">i</span> + <span class="number">1</span>
<span class="tag">i</span> += <span class="number">1</span>
</code></pre><p>JSLint提示你这样做，是因为<code>++</code>和<code>--</code>实际上降低了代码的可读性，如果你觉得无所谓，可以将JSLint的<code>plusplus</code>选项设为<code>false</code>（默认为<code>true</code>）。稍后，在本书所介绍的最后一个模式中用到了:<code>i += 1</code>。</p>
<p>关于这种<code>for</code>模式还有两种变化的形式，做了少量改进，原因有二：</p>
<ul>
<li>减少一个变量（没有<code>max</code>）</li>
<li>减量循环至0，这种方式速度更快，因为和零比较要比和非零数字或数组长度比较要高效的多</li>
</ul>
<p>第一种变化形式是：</p>
<pre><code>var i, myarray = [];
for <span class="comment">(i = myarray.length; i--;)</span> {
    <span class="comment">// 访问myarray[i]…</span>
}
</code></pre><p>第二种变化形式用到了while循环：</p>
<pre><code><span class="variable"><span class="keyword">var</span> myarray</span> = [],
    i = myarray.length;
<span class="keyword">while</span> (i--) {
    <span class="comment">// 访问myarray[i]…</span>
}
</code></pre><p>这些小改进只能体现在对性能要求比较苛刻的地方，此外，JSLint不推荐使用<code>i--</code>。</p>
<h2 id="for-in循环">for-in循环</h2><p><code>for-in</code>循环用于对非数组对象进行遍历。通过<code>for-in</code>进行循环也被称作“枚举”（enumeration）。</p>
<p>从技术上讲，<code>for-in</code>循环同样可以用于数组（JavaScript中数组也是对象），但不推荐这样做。当数组对象被扩充了自定义函数时，可能会产生逻辑错误。另外，<code>for-in</code>循环中属性的遍历顺序是不固定的，所以最好数组使用普通的<code>for</code>循环，对象使用<code>for-in</code>循环。</p>
<p>可以使用对象的<code>hasOwnProperty()</code>方法过滤来自原型链中继承来的属性，这一点非常重要。看一下这段代码：</p>
<pre><code><span class="comment">// 对象</span>
<span class="keyword">var</span> man = {
    hands: <span class="number">2</span>,
    legs: <span class="number">2</span>,
    heads: <span class="number">1</span>
};
<span class="comment">// 在代码的另一个地方给所有的对象添加了一个方法</span>
<span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.prototype.clone === <span class="string">"undefined"</span>) {
    <span class="built_in">Object</span>.prototype.clone = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{};
}
</code></pre><p>在这个例子中，我们使用对象字面量定义了一个名叫<code>man</code>的对象。在代码中的某个地方（可以是<code>man</code>定义之前也可以是之后），给<code>Object</code>的原型增加了一个方法<code>clone()</code>。原型链是实时的，这意味着所有的对象都可以访问到这个新方法。要想在枚举<code>man</code>的时候避免枚举出<code>clone()</code>方法，就需要调用<code>hasOwnProperty()</code>来过滤来自原型的属性。如果不做过滤，<code>clone()</code>也会被遍历到，这是我们不希望看到的：</p>
<pre><code><span class="comment">// 1.for-in循环</span>
<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> <span class="keyword">man</span>) {
    <span class="keyword">if</span> (<span class="keyword">man</span>.hasOwnProperty(i)) { <span class="comment">// filter</span>
        console.<span class="literal">log</span>(i, <span class="string">":"</span>, <span class="keyword">man</span>[i]);
    }
}
<span class="comment">/*
控制台中的结果
hands : 2
legs : 2
heads : 1
*/</span>

<span class="comment">// 2.反模式:</span>
<span class="comment">// 不使用hasOwnProperty()过滤的for-in循环</span>
<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> <span class="keyword">man</span>) {
    console.<span class="literal">log</span>(i, <span class="string">":"</span>, <span class="keyword">man</span>[i]);
}
<span class="comment">/*
控制台中的结果
hands : 2
legs : 2
heads : 1
clone: function()
*/</span>
</code></pre><p>另外一种调用<code>hasOwnProperty()</code>的方法是通过<code>Object.prototype</code>来调用，像这样：</p>
<pre><code><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> <span class="keyword">man</span>) {
    <span class="keyword">if</span> (Object.prototype.hasOwnProperty.call(<span class="keyword">man</span>, i)) { <span class="comment">// 过滤</span>
        console.<span class="literal">log</span>(i, <span class="string">":"</span>, <span class="keyword">man</span>[i]);
    }
}
</code></pre><p>这种做法的好处是，在<code>man</code>对象中重新定义了<code>hasOwnProperty</code>方法的情况下，可以避免调用时的命名冲突。为了避免查找属性时从<code>Object</code>对象一路找到原型的冗长过程，你可以定义一个变量来“缓存”住它：</p>
<pre><code><span class="keyword">var</span> i,
    hasOwn = Object.prototype.hasOwnProperty;
<span class="keyword">for</span> (i <span class="keyword">in</span> <span class="keyword">man</span>) {
    <span class="keyword">if</span> (hasOwn.call(<span class="keyword">man</span>, i)) { <span class="comment">// 过滤</span>
        console.<span class="literal">log</span>(i, <span class="string">":"</span>, <span class="keyword">man</span>[i]);
    }
}
</code></pre><blockquote>
<p>严格说来，省略<code>hasOwnProperty()</code>并不是一个错误。根据具体的任务以及你对代码的自信程度，你可以省略掉它以提高一些程序执行效率。但当你对当前要遍历的对象不确定的时候，添加hasOwnProperty()则更加保险些。</p>
</blockquote>
<p>这里介绍一种格式上的变种（这种写法无法通过JSLint检查），这种写法在<code>for</code>循环所在的行加入了<code>if</code>判断条件，他的好处是能让循环语句读起来更完整和通顺（“如果元素包含属性X，则对X做点什么”）：</p>
<pre><code><span class="comment">// 警告：无法通过JSLint检查</span>
<span class="keyword">var</span> i,
    hasOwn = Object.prototype.hasOwnProperty;
<span class="keyword">for</span> (i <span class="keyword">in</span> <span class="keyword">man</span>) <span class="keyword">if</span> (hasOwn.call(<span class="keyword">man</span>, i)) { <span class="comment">// 过滤</span>
    console.<span class="literal">log</span>(i, <span class="string">":"</span>, <span class="keyword">man</span>[i]);
}
</code></pre><h2 id="（不）扩充内置原型">（不）扩充内置原型</h2><p>我们可以扩充构造函数的<code>prototype</code>属性来为构造函数增加功能，这个特性非常强大，但有时会强大到超过我们的掌控。</p>
<p>给内置构造函数如<code>Object()</code>、<code>Array()</code>、<code>Function()</code>扩充原型看起来非常诱人，但这种做法会严重降低代码的可维护性，因为它会让你的代码变得难以预测。对于那些基于你的代码来做开发的开发者来说，他们更希望使用原生的JavaScript方法来保持代码的一致性，而不愿意使用你所添加的方法。</p>
<p>另外，如果将属性添加至原型中，很可能导致原型上的属性在那些不使用<code>hasOwnProperty()</code>做过滤的循环中被遍历出来，从而造成混乱。</p>
<p>因此，不扩充内置对象的原型是最好的，你也可以自己定义一个规则，仅当下列条件满足时才考虑扩充内置对象的原型：</p>
<ol>
<li>未来的ECMAScript版本或者JavaScirpt会将你将要实现的方法添加为内置方法。比如，你可以实现ECMAScript5定义的一些方法，直到浏览器升级至支持ES5。这样，你只是提前定义了这些方法。</li>
<li>当某个属性或者方法是你在其它地方实现过的，或者是某个JavaScript引擎或浏览器的一部分，而你检查时又发现它不存在时。</li>
<li>在有充分的文档说明，并且和团队其他成员做了沟通的时候。</li>
</ol>
<p>如果你遇到这三种情况之一，你可以给内置原型添加自定义方法，写法如下：</p>
<pre><code><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.protoype.myMethod !== <span class="string">"function"</span>) {
    <span class="built_in">Object</span>.protoype.myMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
        <span class="comment">// 实现…</span>
    };
}
</code></pre><h2 id="switch模式">switch模式</h2><p>你可以通过下面这种模式来增强<code>switch</code>语句的可读性和健壮性：</p>
<pre><code><span class="keyword">var</span> inspect_me = <span class="number">0</span>,
    <span class="literal">result</span> = '';
switch (inspect_me) {
<span class="keyword">case</span> <span class="number">0</span>:
    <span class="literal">result</span> = <span class="string">"zero"</span>;
    <span class="keyword">break</span>;
<span class="keyword">case</span> <span class="number">1</span>:
    <span class="literal">result</span> = <span class="string">"one"</span>;
    <span class="keyword">break</span>;
default:
    <span class="literal">result</span> = <span class="string">"unknown"</span>;
}
</code></pre><p>这个简单的例子所遵循的风格约定如下：</p>
<ul>
<li>每个<code>case</code>和<code>switch</code>对齐（这里不考虑花括号相关的缩进规则）。</li>
<li>每个<code>case</code>中的代码整齐缩进。</li>
<li>每个<code>case</code>都以<code>break</code>作为结束。</li>
<li>避免连续执行多个case语句块（省略break时），如果你坚持认为连续执行多个<code>case</code>语句块是最好的方法，请务必补充文档说明，对于其他人来说，会觉得这种情况是错误的写法。</li>
<li>以<code>default</code>结束整个<code>switch</code>，以确保即便是在找不到匹配项时也有合理的结果。</li>
</ul>
<h2 id="避免隐式类型转换">避免隐式类型转换</h2><p>在JavaScript对变量进行比较时会有一些隐式的数据类型转换。比如诸如<code>false == 0</code>或<code>&quot;&quot; == 0</code>之类的比较都返回<code>true</code>。</p>
<p>为了避免隐式类型转换对程序造成干扰，推荐使用<code>===</code>和<code>!==</code>运算符，它们除了比较值还会比较类型：</p>
<pre><code><span class="variable"><span class="keyword">var</span> zero</span> = <span class="number">0</span>;
<span class="keyword">if</span> (zero === <span class="literal">false</span>) {
    <span class="comment">// 不会执行，因为zero是0，不是false</span>
}
<span class="comment">// 反模式</span>
<span class="keyword">if</span> (zero == <span class="literal">false</span>) {
    <span class="comment">// 代码块会执行…</span>
}
</code></pre><p>有一种观点认为当<code>==</code>够用的时候就不必使用<code>===</code>。比如，当你知道<code>typeof</code>的返回值是一个字符串，就不必使用全等运算符。但JSLint却要求使用全等运算符，这无疑会提高代码风格的一致性，并减少了阅读代码时的思考量（“这里使用<code>==</code>是故意的还是无意的？”）。</p>
<h3 id="避免使用eval()">避免使用eval()</h3><p>当你想使用<code>eval()</code>的时候，不要忘了那句话“<code>eval()</code> is evil”（<code>eval()</code>是魔鬼）。这个函数的参数是一个字符串，它会将传入的字符串作为JavaScript代码执行。如果用来解决问题的代码是事先知道的（在运行之前），则没有理由使用<code>eval()</code>。如果需要在运行时动态生成并执行代码，那一般都会有更好的方式达到同样的目的，而非一定要使用<code>eval()</code>。例如，访问动态属性时可以使用方括号：</p>
<pre><code>// 反模式
var <span class="keyword">property</span><span class="title"> </span>= <span class="string">"name"</span>;
alert(eval(<span class="string">"obj."</span> + <span class="keyword">property</span><span class="title"></span>));
// 更好的方式
var <span class="keyword">property</span><span class="title"> </span>= <span class="string">"name"</span>;
alert(obj[<span class="keyword">property</span><span class="title"></span>]);
</code></pre><p><code>eval()</code>还有安全隐患，因为你有可能会运行一些被干扰过的代码（比如一段来自于网络的代码）。这是一种在处理Ajax请求所返回的JSON数据时比较常见的反模式。这种情况下最好使用浏览器的内置方法来解析JSON数据，以确保代码的安全性和数据的合法性。如果浏览器不支持<code>JSON.parse()</code>，你可以使用JSON.org所提供的库。</p>
<p>值得一提的是，多数情况下，给<code>setInterval()</code>、<code>setTimeout()</code>和<code>Function()</code>构造函数传入字符串的情形和<code>eval()</code>类似，这种用法也是应当避免的，因为这些情形中JavaScript最终还是会执行传入的字符串参数：</p>
<pre><code><span class="comment">// 反模式</span>
setTimeout(<span class="string">"myFunc()"</span>, <span class="number">1000</span>);
setTimeout(<span class="string">"myFunc(1, 2, 3)"</span>, <span class="number">1000</span>);
<span class="comment">// 更好的方式</span>
setTimeout(myFunc, <span class="number">1000</span>);
setTimeout(function () {
    myFunc(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);
}, <span class="number">1000</span>);
</code></pre><p><code>new Function()</code>的用法和<code>eval()</code>非常类似，应当特别注意。这种构造函数的方式很强大，但经常会被误用。如果你不得不使用<code>eval()</code>，你可以尝试用<code>new Function()</code>来代替。这有一个潜在的好处，在<code>new Function()</code>中运行的代码会在一个局部函数作用域内执行，因此源码中所有用<code>var</code>定义的变量不会自动变成全局变量。还有一种方法可以避免<code>eval()</code>中定义的变量被转换为全局变量，即是将<code>eval()</code>包装在一个即时函数内（详细内容请参见第四章）。</p>
<p>看一下这个例子，这里只有<code>un</code>成为全局变量污染了全局命名空间：</p>
<pre><code><span class="built_in">console</span>.log(<span class="keyword">typeof</span> un);<span class="comment">// "undefined"</span>
<span class="built_in">console</span>.log(<span class="keyword">typeof</span> deux); <span class="comment">// "undefined"</span>
<span class="built_in">console</span>.log(<span class="keyword">typeof</span> trois); <span class="comment">// "undefined"</span>

<span class="keyword">var</span> jsstring = <span class="string">"var un = 1; console.log(un);"</span>;
<span class="built_in">eval</span>(jsstring); <span class="comment">// 打印出 "1"</span>

jsstring = <span class="string">"var deux = 2; console.log(deux);"</span>;
<span class="keyword">new</span> <span class="built_in">Function</span>(jsstring)(); <span class="comment">// 打印出 "2"</span>

jsstring = <span class="string">"var trois = 3; console.log(trois);"</span>;
(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    <span class="built_in">eval</span>(jsstring);
}()); <span class="comment">// 打印出 "3"</span>

<span class="built_in">console</span>.log(<span class="keyword">typeof</span> un); <span class="comment">// "number"</span>
<span class="built_in">console</span>.log(<span class="keyword">typeof</span> deux); <span class="comment">// "undefined"</span>
<span class="built_in">console</span>.log(<span class="keyword">typeof</span> trois); <span class="comment">// "undefined"</span>
</code></pre><p><code>eval()</code>和<code>Function()</code>构造函数还有一个区别，就是<code>eval()</code>可以修改作用域链，而<code>Function</code>更像是一个沙箱。不管在什么地方执行<code>Function()</code>，它都只能看到全局作用域。因此它不会太严重的污染局部变量。在下面的示例代码中，<code>eval()</code>可以访问并修改其作用域之外的变量，而<code>Function()</code>则不能（注意，使用<code>Function()</code>和<code>new Function()</code>是完全一样的）。</p>
<pre><code>(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="keyword">var</span> local = <span class="number">1</span>;
    <span class="keyword">eval</span>(<span class="string">"local = 3; console.log(local)"</span>); <span class="comment">// 打印出 3</span>
    console.log(local); <span class="comment">// 打印出 3</span>
}());

(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="keyword">var</span> local = <span class="number">1</span>;
    <span class="function"><span class="keyword">Function</span><span class="params">(<span class="string">"console.log(typeof local);"</span>)</span><span class="params">()</span></span>; <span class="comment">// 打印出 undefined</span>
}());
</code></pre><h2 id="使用parseInt()进行数字转换">使用parseInt()进行数字转换</h2><p>你可以使用<code>parseInt()</code>将字符串转换为数字。函数的第二个参数是进制参数，这个参数应该被指定，但却通常被省略。当字符串以0为前缀时转换就会出问题，例如，在表单中输入日期的一个字段。ECMAScript3中以0为前缀的字符串会被当作八进制数处理，这一点在ES5中已经有了改变。为了避免转换类型不一致而导致的意外结果，应当总是指定第二个参数：</p>
<pre><code>var <span class="property">month</span> = <span class="string">"06"</span>,
    <span class="property">year</span> = <span class="string">"09"</span>;
<span class="property">month</span> = parseInt(<span class="property">month</span>, <span class="number">10</span>);
<span class="property">year</span> = parseInt(<span class="property">year</span>, <span class="number">10</span>);
</code></pre><p>在这个例子中，如果省略掉parseInt的第二个参数，比如<code>parseInt(year)</code>，返回的值是0，因为“09”被认为是八进制数（等价于<code>parseInt(year,8)</code>），但09是非法的八进制数。</p>
<p>字符串转换为数字还有两种方法：</p>
<pre><code>+<span class="string">"08"</span> <span class="comment">// 结果为8</span>
<span class="function"><span class="title">Number</span><span class="params">(<span class="string">"08"</span>)</span></span> <span class="comment">// 结果为8</span>
</code></pre><p>这两种方法要比<code>parseInt()</code>更快一些，因为顾名思义<code>parseInt()</code>是一种“解析”而不是简单的“转换”。但当你期望将“08 hello”这类字符串转换为数字，则必须使用<code>parseInt()</code>，其他方法都会返回NaN。</p>
<h2 id="代码规范">代码规范</h2><p>确立并遵守代码规范非常重要，这会让你的代码风格一致、可预测，并且可读性更强。团队新成员通过学习代码规范可以很快进入开发状态，并写出让团队其他成员易于理解的代码。</p>
<p>在开源社区和邮件组中关于编代风格的争论一直不断。（比如关于代码缩进，用tab还是空格？）因此，如果你打算在团队内推行某种编码规范时，要做好应对各种反对意见的心理准备，而且要吸取各种意见。确定并遵守代码规范非常重要，任何一种规范都可以，这甚至比代码规范中的具体约定是怎么样的还要重要。</p>
<h3 id="缩进">缩进</h3><p>代码如果没有缩进就几乎不能读了，而不一致的缩进会使情况更加糟糕，因为它看上去像是遵守了规范，但真正读起来却没那么顺利。因此规范地使用缩进非常重要。</p>
<p>有些开发者喜欢使用tab缩进，因为每个人都可以根据自己的喜好来调整tab缩进的空格数，有些人则喜欢使用空格缩进，通常是四个空格。这都无所谓，只要团队每个人都遵守同一个规范即可，本书中所有的示例代码都采用四个空格的缩进写法，这也是JSLint所推荐的。（译注：电子版中看到的是用tab缩进，本译文也保留使用tab缩进。）</p>
<p>那么到底什么时候应该缩进呢？规则很简单，花括号里的内容应当缩进，包括函数体、循环（<code>do</code>、<code>while</code>、<code>for</code>和<code>for-in</code>）体、<code>if</code>语句、<code>switch</code>语句和对象字面量里的属性。下面的代码展示了如何正确地使用缩进：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">outer</span><span class="params">(a, b)</span> </span>{
    <span class="keyword">var</span> c = <span class="number">1</span>,
        d = <span class="number">2</span>,
        inner;
    <span class="keyword">if</span> (a &gt; b) {
        inner = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
            <span class="keyword">return</span> {
                r: c - d
            };
        };
    } <span class="keyword">else</span> {
        inner = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
            <span class="keyword">return</span> {
                r: c + d
            };
        };
    }
    <span class="keyword">return</span> inner;
}
</code></pre><h3 id="花括号">花括号</h3><p>在特定的语句中应当总是使用花括号，即便是在可省略花括号的情况下也应当如此。从技术角度讲，如果<code>if</code>或<code>for</code>中只有一个语句，花括号是可以省略的，但最好还是不要省略，这会让你的代码更加工整一致而且易于修改。</p>
<p>假设有这样一段代码，<code>for</code>循环中只有一条语句，你可以省略掉这里的花括号，而且不会有语法错误：</p>
<pre><code><span class="comment">// 不好的方式</span>
for <span class="comment">(var i = 0; i &lt; 10; i += 1)</span>
    alert<span class="comment">(i)</span>;
</code></pre><p>但如果过了一段时间，你给这个循环添加了另一行代码会怎样？</p>
<pre><code><span class="comment">// 不好的方式</span>
for <span class="comment">(var i = 0; i &lt; 10; i += 1)</span>
    alert<span class="comment">(i)</span>;
    alert<span class="comment">(i + " is " + (i % 2 ? "odd" : "even")</span>);
</code></pre><p>第二个<code>alert</code>实际上在循环体之外，但这里的缩进会让你迷惑。从长远考虑最好还是写上花括号，即便是在只有一个语句的语句块中也应如此：</p>
<pre><code><span class="comment">// 更好的方式</span>
for <span class="comment">(var i = 0; i &lt; 10; i += 1)</span> {
    alert<span class="comment">(i)</span>;
}
</code></pre><p>同理，if条件句也应当如此：</p>
<pre><code><span class="comment">// 不好的方式</span>
<span class="keyword">if</span> (<span class="literal">true</span>)
    alert(<span class="number">1</span>);
<span class="keyword">else</span>
    alert(<span class="number">2</span>);

<span class="comment">// 更好的试</span>
<span class="keyword">if</span> (<span class="literal">true</span>) {
    alert(<span class="number">1</span>);
} <span class="keyword">else</span> {
    alert(<span class="number">2</span>);
}
</code></pre><h3 id="左花括号的位置">左花括号的位置</h3><p>开发人员对于左大括号的位置有着不同的偏好，在同一行呢还是在下一行？</p>
<pre><code><span class="keyword">if</span> (<span class="literal">true</span>) {
    alert(<span class="string">"It's TRUE!"</span>);
}
</code></pre><p>或者：</p>
<pre><code><span class="keyword">if</span> (<span class="literal">true</span>)
{
    alert(<span class="string">"It's TRUE!"</span>);
}
</code></pre><p>在这个例子中，这个问题只是个人偏好问题。但有时候花括号位置的不同会影响程序的执行，因为JavaScript会“自动插入分号”。JavaScript对行尾是否有分号并没有要求，它会自动将分号补全。因此，当函数的<code>return</code>语句返回了一个对象字面量，而对象的左花括号和<code>return</code>又不在同一行时，程序的执行就和预期的不同了：</p>
<pre><code><span class="comment">// 警告：返回值和预期的不同</span>
<span class="tag">function</span> <span class="tag">func</span>() {
    <span class="tag">return</span>
    {
        <span class="attribute">name</span>: <span class="string">"Batman"</span>
    };
}
</code></pre><p>可以看出程序作者的意图是返回一个包含了<code>name</code>属性的对象，但实际情况不是这样。因为return后会填补一个分号，函数的返回值就是undefined。这段代码等价于：</p>
<pre><code><span class="comment">// 警告：返回值和预期的不同</span>
<span class="function"><span class="keyword">function</span> <span class="title">func</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> <span class="literal">undefined</span>;
    <span class="comment">// 下面的代码不会运行…</span>
    {
        name: <span class="string">"Batman"</span>
    };
}
</code></pre><p>总结一下好的写法，在特写的语句中总是使用花括号，并且总是将左花括号与上一条语句放在同一行：</p>
<pre><code><span class="tag">function</span> <span class="tag">func</span>() {
    <span class="tag">return</span> {
        <span class="attribute">name</span>: <span class="string">"Batman"</span>
    };
}
</code></pre><blockquote>
<p>关于分号也值得注意：和花括号一样，应当总是使用分号，尽管在JavaScript解析代码时会补全行末省略的分号，但严格遵守这条规则，可以让代码更加严谨，同时可以避免前面例子中所出现的歧义。</p>
</blockquote>
<p>###　空格</p>
<p>空格的使用同样有助于改善代码的可读性和一致性。在写英文句子的时候，在逗号和句号后面会使用间隔，在JavaScript中，你可以按照同样的逻辑在表达式（相当于逗号）和语句结束（相对于完成了某个“想法”的表达）后面添加间隔。</p>
<p>适合使用空格的地方包括：</p>
<ul>
<li>for循环中的分号之后，比如<code>for (var i = 0; i &lt; 10; i += 1) {...}</code></li>
<li>for循环中初始化多个变量，比如<code>for (var i = 0, max = 10; i &lt; max; i += 1) {...}</code></li>
<li>用于分隔数组元素的逗号之后，比如<code>var a = [1, 2, 3];</code></li>
<li>对象属性后的逗号以及名值对之间的冒号之后，比如<code>var o = {a: 1, b: 2};</code></li>
<li>函数参数中，比如<code>myFunc(a, b, c)</code></li>
<li>函数声明的花括号之前，比如<code>function myFunc() {}</code></li>
<li>匿名函数表达式<code>function</code>之后，比如<code>var myFunc = function () {};</code></li>
</ul>
<p>另外，我们推荐在运算符和操作数之间也添加空格。也就是说在<code>+</code>、<code>-</code>、<code>*</code>、<code>=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code>、<code>===</code>、<code>!==</code>、<code>&amp;&amp;</code>、<code>||</code>、<code>+=</code>符号前后都添加空格。</p>
<pre><code><span class="comment">// 适当且一致的空格给代码留了“呼吸空间”，使代码更易读</span>
<span class="keyword">var</span> <span class="keyword">d</span> = 0,
    a = b + 1;
<span class="keyword">if</span> (a &amp;&amp; b &amp;&amp; c) {
    <span class="keyword">d</span> = a % c;
    a += <span class="keyword">d</span>;
}

<span class="comment">// 反模式，缺少或者不正确的空格使得代码不易读</span>
<span class="keyword">var</span> <span class="keyword">d</span>= 0,
    a =b+1;
<span class="keyword">if</span> (a&amp;&amp; b&amp;&amp;c) {
    <span class="keyword">d</span>=a %c;
    a+= <span class="keyword">d</span>;
}
</code></pre><p>最后，还应当注意，最好在花括号旁边添加空格：</p>
<ul>
<li>在函数、<code>if-else</code>语句、循环、对象字面量的左花括号之前补充空格</li>
<li>在右花括号和<code>else</code>或者<code>while</code>之间补充空格</li>
</ul>
<blockquote>
<p>垂直空白的使用经常被我们忽略，你可以使用空行来将代码单元分隔开，就像文学作品中使用段落进行分隔一样。</p>
</blockquote>
<h2 id="命名规范">命名规范</h2><p>另外一种可以提升你代码的可预测性和可维护性的方法是采用命名规范。也就是说变量和函数的命名都遵守同样的习惯。</p>
<p>下面是一些建议的命名规范，你可以原样采用，也可以根据自己的喜好作调整。同样，遵循规范要比规范本身是什么样更加重要。</p>
<h3 id="构造函数命名中的大小写">构造函数命名中的大小写</h3><p>JavaScript中没有类，但有构造函数，可以通过<code>new</code>来调用构造函数：</p>
<pre><code><span class="keyword">var</span> adam = <span class="keyword">new</span> Person();
</code></pre><p>由于构造函数毕竟还是函数，如果只通过函数名就可分辨出它是构造函数还是普通函数是非常有用的。</p>
<p>首字母大写可以提示你这是一个构造函数，而首字母小写的函数一般只认为它是普通的函数，不应该通过new来调用它：</p>
<pre><code>function <span class="type">MyConstructor</span>() <span class="decorator">{...}</span>
function myFunction() <span class="decorator">{...}</span>
</code></pre><p>下一章将介绍一些强制将普通函数用作构造函数的编程模式，但遵守我们所提到的命名规范会更好的帮助程序员阅读源码。</p>
<h3 id="单词分隔">单词分隔</h3><p>当你的变量名或函数名中含有多个单词时，单词之间的分隔也应当遵循统一的规范。最常见的是“驼峰式”（camel case）命名，单词都是小写，每个单词的首字母是大写。</p>
<p>对于构造函数，可以使用“大驼峰式”（upper camel case）命名，比如<code>MyConstructor()</code>，对于函数和方法，可以采用“小驼峰式”（lower camel case）命名，比如<code>myFunction()</code>、<code>calculateArea()</code>和<code>getFirstName()</code>。</p>
<p>那么对于那些不是函数的变量应当如何命名呢？变量名通常采用小驼峰式命名，还有一个不错的做法是，变量所有字母都是小写，单词之间用下划线分隔，比如，<code>first_name</code>、<code>favorite_bands</code>和<code>old_company_name</code>，这种方法可以帮助你区分函数和其他标识符如原始类型数据或对象。</p>
<p>ECMAScript的属性和方法均使用驼峰式命名，尽管包含多个单词的属性名称并不多见（正则表达式对象的<code>lastIndex</code>和<code>ignoreCase</code>属性）。</p>
<h3 id="其他命名风格">其他命名风格</h3><p>有时开发人员使用命名规范来弥补或代替语言特性的不足。</p>
<p>比如，JavaScript中无法定义常量（尽管有一些内置常量比如<code>Number.MAX_VALUE</code>），所以开发者都采用了一种命名规范，对于那些程序运行周期内不会更改的变量使用全大写字母来命名。比如：</p>
<pre><code><span class="comment">// 常量，请勿修改</span>
var PI = <span class="number">3.14</span>,
    MAX_WIDTH = <span class="number">800</span>;
</code></pre><p>除了使用大写字母的命名方式之外，还有另一种命名规范：全局变量全大写。这种命名方式和“减少全局变量”的约定相辅相成，并让全局变量很容易辨认。</p>
<p>除了常量和全局变量的命名规范，这里讨论另外一种命名规范，即私有变量的命名。尽管在JavaScript是可以实现真正的私有变量的，但开发人员更喜欢在私有成员或方法名之前加上下划线前缀，比如下面的例子：</p>
<pre><code><span class="keyword">var</span> person = {
    getName: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="keyword">this</span>._getFirst() + <span class="string">' '</span> + <span class="keyword">this</span>._getLast();
    },
    _getFirst: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        <span class="comment">// ...</span>
    },
    _getLast: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        <span class="comment">// ...</span>
    }
};
</code></pre><p>在这个例子中，<code>getName()</code>是一个公有方法，是确定的API的一部分，而<code>_getFirst()</code>和<code>_getLast()</code>则是私有方法。尽管这两个方法本质上和公有方法没有区别，但在方法名前加下划线前缀就是为了告知用户不要直接使用这两个私有方法，因为不能保证它们在下一个版本中还能正常工作。JSLint会对私有方法作检查，除非设置了JSLint的<code>nomen</code>选项为<code>false</code>。</p>
<p>下面介绍一些<code>_private</code>风格写法的变种：</p>
<ul>
<li>在名字尾部添加下划线以表明私有，比如<code>name_</code>和<code>getElements_()</code></li>
<li>使用一个下划线前缀表明受保护的属性<code>_protected</code>，用两个下划线前缀表明私有属性<code>__private</code></li>
<li>在Firefox中实现了一些非标准的内置属性，这些属性在开头和结束都有两个下划线，比如<code>__proto__</code>和<code>__parent__</code></li>
</ul>
<h2 id="写注释">写注释</h2><p>在写代码时，即便你认为你的代码不会被别人读到，也应该写好注释。因为当你对一个问题非常熟悉时，你会非常明白这些代码的作用，但当过了几个星期后再来读这段代码时，则需要绞尽脑汁的回想这些代码在干什么。</p>
<p>你不必对那些浅显易懂的代码写过多的注释，比如每个变量、每一行都写注释。但你应该对所有的函数、它们的参数和返回值进行注释，除此之外，对于那些值得注意的或是比较怪异的算法和技术也应当写好注释。对于其他阅读你代码的人来说，注释就是一种提示，只要阅读注释、函数名和参数，就算不读其它部分的代码也能大概理解程序的逻辑。比如，这里有五六行代码完成了某个功能，如果有一行描述这段代码功能的注释，读程序的人就不必再去关注代码的实现细节了。代码注释的写法并没有硬性规定，但有些代码片段（比如正则表达式）需要比代码本身更多的注释。</p>
<blockquote>
<p>过时的注释会造成误导，这比不写注释还要糟糕。保持注释的状态为最新的习惯非常重要，尽管对很多人来说这很难做到。</p>
</blockquote>
<p>在下一小节我们会讲到，利用注释可以自动生成文档。</p>
<h2 id="写API文档">写API文档</h2><p>很多人都觉得写文档是一件很枯燥而且吃力不讨好的事情，但实际情况并不是这样。我们可以通过代码注释自动生成文档，这样就不用再去专门写文档了。很多人觉得这是一个不错的点子，因为根据某些关键字和特定的格式自动生成可阅读的参考手册本身就是“某种编程”。</p>
<p>最早利用注释生成API文档的工具诞生自Java业界，这个工具名叫“javadoc”，和Java SDK（软件开发工具包）一起提供，但这个创意迅速被其他语言借鉴。JavaScript领域有两个非常优秀的开源工具，它们是JSDoc Toolkit（<a href="http://code.google.com/p/jsdoc-toolkit/" target="_blank" rel="external">http://code.google.com/p/jsdoc-toolkit/</a>）和YUIDoc（<a href="http://yuilibrary.com/projects/yuidoc" target="_blank" rel="external">http://yuilibrary.com/projects/yuidoc</a>）。</p>
<p>生成API文档的过程：</p>
<ul>
<li>以特定的格式来写代码</li>
<li>运行工具来对代码和注释进行解析</li>
<li>发布工具运行的结果，通常是HTML页面</li>
</ul>
<p>这种语法包括十几种标签（tag），写法类似于：</p>
<pre><code>/<span class="keyword">*</span><span class="keyword">*</span>
 <span class="keyword">*</span> <span class="comment">@tag value</span>
 <span class="keyword">*</span>/
</code></pre><p>比如这里有一个函数<code>reverse()</code>，可以对字符串进行反序操作。它的参数和返回值都是字符串。给它补充注释如下：</p>
<pre><code><span class="comment">/**
* Reverse a string
*
* <span class="doctag">@param</span> {String} input String to reverse
* <span class="doctag">@return</span> {String} The reversed string
*/</span>
<span class="keyword">var</span> reverse = <span class="function"><span class="keyword">function</span> <span class="params">(input)</span> </span>{
    <span class="comment">// ...</span>
    <span class="keyword">return</span> output;
};
</code></pre><p>如你所见，<code>@param</code>是用来说明输入参数的标签，<code>@return</code>是用来说明返回值的标签，文档生成工具最终会将这种带注释的源代码解析成HTML文档。</p>
<h3 id="示例：YUIDoc">示例：YUIDoc</h3><p>YUIDoc的初衷是为YUI（Yahoo! User Interface）库生成文档，但其实它也可以应用于任何项目。为了更充分的使用YUIDoc，你需要学习它的注释规范，比如模块和类的写法。（尽管在JavaScript中其实是没有类的概念的）。</p>
<p>让我们看一个用YUIDoc生成文档的完整例子。</p>
<p>图2-1展示了最终生成的文档的样子，你可以根据项目需要定制HTML模板，让生成的文档更加友好和个性化。</p>
<p>这里提供了在线的demo，请参照<a href="http://jspatterns.com/book/2/" target="_blank" rel="external">http://jspatterns.com/book/2/</a>。</p>
<p>这个例子中所有的应用作为一个模块（myapp）放在一个文件里（app.js），后续的章节会更详细的介绍模块，现在只需知道可以用一个YUIDoc的标签来表示模块即可。</p>
<p>图2-1 YUIDoc生成的文档</p>
<p><img src="./Figure/chapter2/2-1.jpg" alt="YUIDoc生成的文档"></p>
<p><code>app.js</code>的开始部分：</p>
<pre><code>/<span class="keyword">*</span><span class="keyword">*</span>
 <span class="keyword">*</span> My JavaScript application
 <span class="keyword">*</span>
 <span class="keyword">*</span> <span class="comment">@module myapp</span>
 <span class="keyword">*</span>/
</code></pre><p>然后定义了一个空对象作为模块的命名空间：</p>
<pre><code><span class="variable"><span class="keyword">var</span> MYAPP</span> = {};
</code></pre><p>紧接着定义了一个包含两个方法的对象<code>math_stuff</code>，这两个方法分别是<code>sum()</code>和<code>multi()</code>：</p>
<pre><code>/<span class="keyword">*</span><span class="keyword">*</span>
<span class="keyword">*</span> A math utility
<span class="keyword">*</span> <span class="comment">@namespace MYAPP</span>
<span class="keyword">*</span> <span class="comment">@class math_stuff</span>
<span class="keyword">*</span>/
MYAPP.math_stuff = {
    /<span class="keyword">*</span><span class="keyword">*</span>
    <span class="keyword">*</span> Sums two numbers
    <span class="keyword">*</span>
    <span class="keyword">*</span> <span class="comment">@method sum</span>
    <span class="keyword">*</span> <span class="comment">@param {Number} a First number</span>
    <span class="keyword">*</span> <span class="comment">@param {Number} b The second number</span>
    <span class="keyword">*</span> <span class="comment">@return {Number} The sum of the two inputs</span>
    <span class="keyword">*</span>/
    sum: function (a, b) {
        return a + b;
    },

    /<span class="keyword">*</span><span class="keyword">*</span>
    <span class="keyword">*</span> Multiplies two numbers
    <span class="keyword">*</span>
    <span class="keyword">*</span> <span class="comment">@method multi</span>
    <span class="keyword">*</span> <span class="comment">@param {Number} a First number</span>
    <span class="keyword">*</span> <span class="comment">@param {Number} b The second number</span>
    <span class="keyword">*</span> <span class="comment">@return {Number} The two inputs multiplied</span>
    <span class="keyword">*</span>/
    multi: function (a, b) {
        return a <span class="keyword">*</span> b;
    }
};
</code></pre><p>这样就完成了第一个“类”的定义，注意以下标签：</p>
<ul>
<li><p><code>@namespace</code></p>
<p>  包含对象的全局引用</p>
</li>
<li><p><code>@class</code></p>
<p>  代表一个对象或构造函数（JavaScript中没有类）</p>
</li>
<li><p><code>@method</code></p>
<p>  定义对象的方法，并指定方法的名称</p>
</li>
<li><p><code>@param</code></p>
<p>  列出函数需要的参数，参数的类型放在一对花括号内，后面跟参数名和描述</p>
</li>
<li><p><code>@return</code></p>
<p>  和@param类似，用以描述方法的返回值，可以不带名字</p>
</li>
</ul>
<p>我们来实现第二个“类”，使用一个构造函数，并给这个构造函数的原型添加一个方法，看看YUIDoc在面对不同的对象创建方式时是如何工作的：</p>
<pre><code>/<span class="keyword">*</span><span class="keyword">*</span>
<span class="keyword">*</span> Constructs Person objects
<span class="keyword">*</span> <span class="comment">@class Person</span>
<span class="keyword">*</span> <span class="comment">@constructor</span>
<span class="keyword">*</span> <span class="comment">@namespace MYAPP</span>
<span class="keyword">*</span> <span class="comment">@param {String} first First name</span>
<span class="keyword">*</span> <span class="comment">@param {String} last Last name</span>
<span class="keyword">*</span>/
MYAPP.Person = function (first, last) {
    /<span class="keyword">*</span><span class="keyword">*</span>
    <span class="keyword">*</span> Name of the person
    <span class="keyword">*</span> <span class="comment">@property first_name</span>
    <span class="keyword">*</span> <span class="comment">@type String</span>
    <span class="keyword">*</span>/
    this.first_name = first;
    /<span class="keyword">*</span><span class="keyword">*</span>
    <span class="keyword">*</span> Last (family) name of the person
    <span class="keyword">*</span> <span class="comment">@property last_name</span>
    <span class="keyword">*</span> <span class="comment">@type String</span>
    <span class="keyword">*</span>/
    this.last_name = last;
};
/<span class="keyword">*</span><span class="keyword">*</span>
<span class="keyword">*</span> Returns the name of the person object
<span class="keyword">*</span>
<span class="keyword">*</span> <span class="comment">@method getName</span>
<span class="keyword">*</span> <span class="comment">@return {String} The name of the person</span>
<span class="keyword">*</span>/
MYAPP.Person.prototype.getName = function () {
    return this.first_name + ' ' + this.last_name;
};
</code></pre><p>在图2-1中可以看到生成的文档中<code>Person</code>构造函数的生成结果，值得注意的部分是：</p>
<ul>
<li><code>@constructor</code> 说明这个“类”其实是一个构造函数</li>
<li><code>@prototype</code> 和 <code>@type</code> 用来描述对象的属性</li>
</ul>
<p>YUIDoc工具是与语言无关的，只解析注释块，而不是JavaScript代码。它的缺点是必须要在注释中指定属性、参数和方法的名字，比如，<code>@property first_name</code>。好处是一旦你熟练掌握YUIDoc，就可以用它对任何语言源码生成文档。</p>
<h2 id="编写易读的代码">编写易读的代码</h2><p>这种编写注释块来生成API文档的做法可不仅仅是为了偷懒，它还有另外一个作用，就是通过回头重看代码来提高代码质量。</p>
<p>随便一个作者或者编辑都会告诉你“编辑非常重要”，甚至是写一本好书或好文章最最重要的步骤。将想法落实在纸上形成草稿只是第一步，草稿确实可以给读者提供不少信息，但往往还不是重点最明晰、结构最合理、最符合阅读习惯的呈现形式。</p>
<p>编程也是同样的道理，当你坐下来解决一个问题的时候，这时的解决方案只是一种“草案”，尽管能正常工作，但是不是最优的方法呢？是不是可读性好、易于理解、可维护和更新？假设当你过一段时间后再来回头看你的代码，一定会发现很多需要改进的地方，比如需要重新组织代码或删掉多余的内容等等。这实际上就是在“整理”你的代码了，可以很大程度上提高你的代码质量。但事实却不那么如愿，我们常常承受着高强度的工作，根本没有时间来整理代码，因此通过代码注释来写文档其实是个不错的机会。</p>
<p>你往往会在写注释文档的时候发现很多问题，也会重新思考代码中的不合理之处，比如，某个方法中的第三个参数比第二个参数更常用，第二个参数多数情况下取值为<code>true</code>，因此就需要对这个方法进行适当的改造和包装。</p>
<p>写出易读的代码（或API），是指写代码时要有让别人能轻易读懂的意识。带着这个意识，你就需要不断思考采用更好的方法来解决手头的问题。</p>
<p>说回“草稿”的问题，也算是“抱佛脚”的权宜之计，一眼看上去是有点“草”，不过至少是有用的，特别是当你处理的是一个关键项目时（比如人命关天时）。一个合适的思路是，你应当始终扔掉你所给出的第一个解决方案，虽然它是可以正常工作的，但毕竟是一个草稿，是一种仅用于验证解决问题可行性的方案。事实上，第二个方案往往会更好，因为这时你对问题的理解会更加透彻。在产生第二个方案的过程中，不要允许自己去复制粘贴之前的代码，这有助于阻止自己投机取巧利用之前的捷径，最后产生不完美的方案。</p>
<h2 id="同事评审（Peer_Reviews）">同事评审（Peer Reviews）</h2><p>另外一种可以提高代码质量的方法是组织相互评审。同事评审可以用一些工具辅助，可以很正式很规范，也是一种开发流程中值得提倡的步骤。你可能觉得没有时间去作代码互相评审，没关系，你可以让坐在你旁边的同事读一下你的代码，或者和她（译注：注意是“她”而不是“他”）一起过一遍你的代码。</p>
<p>同样，当你在写API文档或者其他文档的时候，同事评审能让你的产出物更加清晰，因为你写的文档是本来就是让别人读的，你得让别人通过文档知道你所做的东西。</p>
<p>同事评审是一种很好的实践，不仅仅是因为它能让代码变得更好，更重要的是，在评审的过程中，评审人和代码作者通过分享和讨论，两人都能取长补短、相互促进。</p>
<p>如果你的团队只有你一个开发人员，找不出第二个人能给你作代码评审，这也没关系。你可以通过将你的代码片段开源，或把有意思的代码片段贴在博客中，让全世界的人为你评审。</p>
<p>另外一个很好的实践是使用版本管理工具（CVS、SVN或Git），一旦有人修改并提交了代码，就会发邮件通知组内成员。虽然大部分邮件都进入了垃圾箱，但总是会碰巧有人在工作间隙看到你所提交的代码，并对代码做出一些评价。</p>
<h2 id="发布时的代码压缩（Minify）">发布时的代码压缩（Minify）</h2><p>这里所说的代码压缩（Minify）是指去除JavaScript代码中的空格、注释以及其他不必要的部分，用以减少JavaScript文件的体积，降低网络带宽消耗。我们通常使用压缩工具来进行压缩，比如YUICompressor（Yahoo!）或Closure Compiler（Google），这可以减少页面加载时间。压缩用于发布的的脚本是很重要的，压缩后的文件体积能减少至原来的一半以下。</p>
<p>下面这段代码是压缩后的样子（这段代码是YUI2库中的事件模块）：</p>
<pre><code>YAHOO.util.CustomEvent=<span class="function"><span class="keyword">function</span>(<span class="params">D,C,B,A</span>)</span>{<span class="keyword">this</span>.type=D;<span class="keyword">this</span>.scope=C||<span class="built_in">window</span>;<span class="keyword">this</span>.silent
=B;<span class="keyword">this</span>.signature=A||YAHOO.util.CustomEvent.LIST;<span class="keyword">this</span>.subscribers=[];<span class="keyword">if</span>(!<span class="keyword">this</span>.silent)
{}<span class="keyword">var</span> E=<span class="string">"_YUICEOnSubscribe"</span>;<span class="keyword">if</span>(D!==E){<span class="keyword">this</span>.subscribeEvent=<span class="keyword">new</span>
YAHOO.util.CustomEvent(E,<span class="keyword">this</span>,<span class="literal">true</span>);}...
</code></pre><p>除了去除空格、空行和注释之外，压缩工具还能缩短命名的长度（在保证代码安全的前提下），比如这段代码中的参数<code>A</code>、<code>B</code>、<code>C</code>、<code>D</code>。压缩工具只会重命名局部变量，因为更改全局变量会破坏代码的逻辑，这也是要尽量使用局部变量的原因。如果你使用的全局变量是对DOM节点的引用，而且程序中多次用到，那么最好将它赋值给一个局部变量，这样能提高查找速度，代码也会运行的更快，此外还能提高压缩比、加快下载速度。</p>
<p>补充说明一下，Goolge Closure Compiler还会为了更高的压缩比对全局变量进行压缩（在“高级”模式中），这是很危险的，且对编程规范的要求非常苛刻。</p>
<p>对用于生产环境的脚本做压缩是非常重要的步骤，因为它能提升页面性能，但你应当将这个过程交给工具来完成。千万不要试图手写“压缩好的”代码，你应当在编写代码时坚持使用语义化的变量命名，并保留足够的空格、缩进和注释。你写的代码是需要被人阅读的，所以应当将注意力放在代码可读性和可维护性上，将代码压缩的工作交给工具去完成。</p>
<h2 id="运行JSLint">运行JSLint</h2><p>在上一章我们已经介绍了JSLint，本章中也提到了数次。到现在你应该已经相信用JSLint检查你的代码是一种好的编程模式了。</p>
<p>JSLint的检查点都有哪些呢？它会对本章讨论过的一些模式（单<code>var</code>模式、<code>parseInt()</code>的第二个参数、总是使用花括号）做检查。JSLint还包括其他方面的检查：</p>
<ul>
<li>不可达代码（译注：指永远不可能运行的代码）</li>
<li>变量在声明之前被使用</li>
<li>不安全的UTF字符</li>
<li>使用<code>void</code>、<code>with</code>或者<code>eval</code></li>
<li>无法正确解析的正则表达式</li>
</ul>
<p>JSLint是基于JavaScript实现的（它自己的代码是可以通过JSLint检查的），它提供了在线工具，也可以下载使用，可以运行于很多种平台的JavaScript解析器。你可以将源码下载后在本地运行，支持的环境包括WSH（Windows Scripting Host，Windows）、JSC（JavaScriptCore，MacOSX）或Rhino（Mozilla开发的JavaScript引擎）。</p>
<p>将JSLint下载后和你的代码编辑器配置在一起是个很不错的主意，这样每次你保存代码的时候都会自动执行代码检查。（为它配置一个快捷键也很有用）。</p>
<h2 id="小结">小结</h2><p>本章我们讨论了编写可维护性代码的意义，它不仅关系着软件项目的成功与否，还关系到参与项目的工程师的“精神健康”和“幸福指数”。随后我们讨论了一些最佳实践和模式，它们包括：</p>
<ul>
<li>减少全局对象，最好每个应用只有一个全局对象</li>
<li>函数都使用单<code>var</code>模式来定义，这样可以将所有的变量放在同一个地方声明，同时可以避免“声明提前”给程序逻辑带来的影响</li>
<li><code>for</code>循环、<code>for-in</code>循环、<code>switch</code>语句、“避免使用<code>eval()</code>”、不要扩充内置原型</li>
<li>遵守统一的编码规范（在任何必要的时候保持空格、缩进、花括号和分号）和命名规范（构造函数、普通函数和变量）。</li>
</ul>
<p>本章还讨论了其他一些和代码本身无关的实践，这些实践和编码过程紧密相关，包括写注释、写API文档、组织同事评审、不要试图去手动“压缩”（minify）代码而牺牲代码可读性、坚持使用JSLint来对代码进行检查。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/06/javascript/javascript-patterns/chapter3/" itemprop="url">
                第三章 字面量和构造函数
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-06T22:08:29+08:00" content="2015-12-06">
            2015-12-06
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/12/06/javascript/javascript-patterns/chapter3/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/12/06/javascript/javascript-patterns/chapter3/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>JavaScript中的字面量模式更加简洁、有表现力，而且在定义对象时不容易出错。本章将会讨论字面量，包括对象、数组和正则表达式字面量，以及为什么字面量要比等价的内置构造函数（如<code>Object()</code>、<code>Array()</code>等）要更好。本章还会介绍JSON格式，JSON是使用数组和对象字面量的形式定义的一种数据交换格式。本章还会讨论自定义构造函数，包括如何强制使用<code>new</code>以确保构造函数正确执行。</p>
<p>为了方便使用字面量而不是构造函数，本章还会补充一些知识，比如内置包装构造函数<code>Number()</code>、<code>String()</code>和<code>Boolean()</code>，以及如何将它们和原始值（数字、字符串和布尔值）比较。最后，快速介绍一下<code>Error()</code>构造函数的用法。</p>
<h2 id="对象字面量">对象字面量</h2><p>我们可以将JavaScript中的对象简单地理解为名值对组成的散列表（hash table，也叫哈希表）。在其他编程语言中被称作“关联数组”。其中的值可以是原始值也可以是对象。不管是什么类型，它们都是“属性”（property），属性值同样可以是函数，这时属性就被称为“方法”（method）。</p>
<p>JavaScript中自定义的对象（用户定义的本地对象）任何时候都是可变的。内置本地对象的属性也是可变的。你可以先创建一个空对象，然后在需要时给它添加功能。“对象字面量写法（object literal notation）”是按需创建对象的一种理想方式。</p>
<p>看一下这个例子：</p>
<pre><code><span class="comment">// 定义空对象</span>
<span class="keyword">var</span> dog = {};

<span class="comment">// 添加一个属性</span>
dog.name = <span class="string">"Benji"</span>;

<span class="comment">// 添加一个方法</span>
dog.getName = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="keyword">return</span> dog.name;
};
</code></pre><p>在这个例子中，我们首先定义了一个空对象，然后添加了一个属性和一个方法，在程序的生命周期内的任何时刻都可以：</p>
<ul>
<li><p>更改属性和方法的值，比如：</p>
<p>  dog.getName = function () {</p>
<pre><code><span class="comment">// 重新定义方法，返回一个硬编码的值</span>
<span class="keyword">return</span> <span class="string">"Fido"</span>;
</code></pre><p>  };</p>
</li>
<li><p>删除属性/方法</p>
<p>  delete dog.name;</p>
</li>
<li><p>添加更多的属性和方法</p>
<p>  dog.say = function () {</p>
<pre><code><span class="keyword">return</span> <span class="string">"Woof!"</span>;
</code></pre><p>  };<br>  dog.fleas = true;</p>
</li>
</ul>
<p>每次都创建空对象并不是必须的，对象字面量模式可以直接在创建对象时添加功能，就像下面这个例子：</p>
<pre><code><span class="keyword">var</span> dog = {
    name: <span class="string">"Benji"</span>,
    getName: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="keyword">this</span>.name;
    }
};
</code></pre><blockquote>
<p>在本书中多次提到“空对象”（“blank object”和“empty object”），这只是一种简称，在JavaScript中根本不存在真正的空对象，理解这一点至关重要。即使最简单的<code>{}</code>对象也会包含从<code>Object.prototype</code>继承来的属性和方法。我们提到的“空（empty）对象”只是说这个对象没有自有属性(own properties)，不考虑它是否有继承来的属性。</p>
</blockquote>
<h3 id="对象字面量语法">对象字面量语法</h3><p>如果你从来没有接触过对象字面量的写法，可能会感觉怪怪的。但越到后来你就越喜欢它。本质上讲，对象字面量语法包括：</p>
<ul>
<li>将对象主体包含在一对花括号内（<code>{</code> 和 <code>}</code>）。</li>
<li>对象内的属性或方法之间使用逗号分隔。最后一个名值对后也可以有逗号，但在IE下会报错，所以尽量不要在最后一个属性或方法后加逗号。</li>
<li>属性名和值之间使用冒号分隔。</li>
<li>如果将对象赋值给一个变量，不要忘了在右括号<code>}</code>之后补上分号。</li>
</ul>
<h3 id="通过构造函数创建对象">通过构造函数创建对象</h3><p>JavaScript中没有类的概念，这给JavaScript带来了极大的灵活性，因为你不必提前知晓关于对象的任何信息，也不需要类的“蓝图”（译注：指类的结构）。但JavaScript同样具有构造函数，它的语法和Java或其他语言中基于类的对象创建非常类似。</p>
<p>你可以使用自定义的构造函数来创建对象实例，也可以使用内置构造函数来创建，比如<code>Object()</code>、<code>Date()</code>、<code>String()</code>等等。</p>
<p>下面这个例子展示了用两种等价的方法分别创建两个独立的实例对象：</p>
<pre><code><span class="comment">// 一种方法，使用字面量</span>
<span class="keyword">var</span> car = {goes: <span class="string">"far"</span>};

<span class="comment">// 另一种方法，使用内置构造函数</span>
<span class="comment">// 注意：这是一种反模式</span>
<span class="keyword">var</span> car = <span class="keyword">new</span> <span class="built_in">Object</span>();
car.goes = <span class="string">"far"</span>;
</code></pre><p>从这个例子中可以看到，字面量写法的一个明显优势是，它的代码更少。“创建对象的最佳模式是使用字面量”还有一个原因，它可以强调对象就是一个简单的可变的散列表，而不必一定派生自某个类。</p>
<p>另外一个使用字面量而不是<code>Object()</code>构造函数创建实例对象的原因是，对象字面量不需要“作用域解析”（scope resolution）。因为存在你已经创建了一个同名的构造函数<code>Object()</code>的可能，当你调用<code>Object()</code>的时候，解析器需要顺着作用域链从当前作用域开始查找，直到找到全局<code>Object()</code>构造函数为止。</p>
<h3 id="Object()构造函数的参数">Object()构造函数的参数</h3><blockquote>
<p>译注：这小节的标题是Object Constructor Catch，恕译者水平有限，实在不知如何翻译，故自作主张修改了本节标题。</p>
</blockquote>
<p>创建实例对象时能用对象字面量就不要使用<code>new Object()</code>构造函数，但有时你可能是在别人写的代码基础上工作，这时就需要了解构造函数的一个“特性”（也是不使用它的另一个原因），就是<code>Object()</code>构造函数可以接收参数，通过这个参数可以把对象实例的创建过程委托给另一个内置构造函数，并返回另外一个对象实例，而这往往不是你想要的。</p>
<p>下面的示例代码中展示了给<code>new Object()</code>传入不同的参数（数字、字符串和布尔值），最终得到的对象是由不同的构造函数生成的：</p>
<pre><code><span class="comment">// 注意：这是反模式</span>

<span class="comment">// 空对象</span>
<span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();
<span class="built_in">console</span>.log(o.constructor === <span class="built_in">Object</span>); <span class="comment">// true</span>

<span class="comment">// 数值对象</span>
<span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="number">1</span>);
<span class="built_in">console</span>.log(o.constructor === <span class="built_in">Number</span>); <span class="comment">// true</span>
<span class="built_in">console</span>.log(o.toFixed(<span class="number">2</span>)); <span class="comment">// "1.00"</span>

<span class="comment">// 字符串对象</span>
<span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">"I am a string"</span>);
<span class="built_in">console</span>.log(o.constructor === <span class="built_in">String</span>); <span class="comment">// true</span>
<span class="comment">// 普通对象没有substring()方法，但字符串对象有</span>
<span class="built_in">console</span>.log(<span class="keyword">typeof</span> o.substring); <span class="comment">// "function"</span>

<span class="comment">// 布尔值对象</span>
<span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="literal">true</span>);
<span class="built_in">console</span>.log(o.constructor === <span class="built_in">Boolean</span>); <span class="comment">// true</span>
</code></pre><p><code>Object()</code>构造函数的这种特性会导致一些意想不到的结果，特别是当参数不确定的时候。最后再次提醒不要使用<code>new Object()</code>，尽可能的使用对象字面量来创建实例对象。</p>
<h2 id="自定义构造函数">自定义构造函数</h2><p>除了对象字面量和内置构造函数之外，你也可以通过自定义的构造函数来创建对象实例，正如下面的代码所示：</p>
<pre><code><span class="keyword">var</span> adam = <span class="keyword">new</span> Person(<span class="string">"Adam"</span>);
adam.say(); <span class="comment">// "I am Adam"</span>
</code></pre><p>这种写法非常像Java中用<code>Person</code>类创建了一个实例，两者的语法非常接近，但实际上JavaScript中没有类的概念，<code>Person()</code>是一个函数。</p>
<p><code>Person()</code>构造函数是如何定义的呢？看下面的代码：</p>
<pre><code><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> <span class="params">(name)</span> </span>{
    <span class="keyword">this</span>.name = name;
    <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="string">"I am "</span> + <span class="keyword">this</span>.name;
    };
};
</code></pre><p>当你通过<code>new</code>来调用这个构造函数时，函数体内将发生这些事情：</p>
<ul>
<li>创建一个空对象，将它的引用赋给<code>this</code>，并继承函数的原型。</li>
<li>通过<code>this</code>将属性和方法添加至这个对象。</li>
<li>最后返回this指向的新对象（如果没有手动返回其他的对象）。</li>
</ul>
<p>用代码表示这个过程如下：</p>
<pre><code><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> <span class="params">(name)</span> </span>{
    <span class="comment">// 使用对象字面量创建新对象</span>
    <span class="comment">// var this = {};</span>

    <span class="comment">// 添加属性和方法</span>
    <span class="keyword">this</span>.name = name;
    <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="string">"I am "</span> + <span class="keyword">this</span>.name;
    };

    <span class="comment">//return this;</span>
};
</code></pre><p>上例中，为简便起见，<code>say()</code>方法被添加至<code>this</code>中，结果就是不论何时调用<code>new Person()</code>，在内存中都会创建一个新函数（<code>say()</code>），显然这是效率很低的，因为所有实例的<code>say()</code>方法是一模一样的。最好的办法是将方法添加至<code>Person()</code>的原型中。</p>
<pre><code>Person.prototype.say = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="keyword">return</span> <span class="string">"I am "</span> + <span class="keyword">this</span>.name;
};
</code></pre><p>我们将会在下一章里详细讨论原型和继承，现在只要记住将需要重用的成员放在原型里即可。</p>
<p>关于构造函数的内部工作机制也会在后续章节中有更细致的讨论。这里我们只做概要的介绍。刚才提到，构造函数执行的时候，首先创建一个新对象，并将它的引用赋给<code>this</code>：</p>
<pre><code><span class="comment">// var this = {};</span>
</code></pre><p>其实事实并不完全是这样，因为“空”对象并不是真的空，这个对象继承了<code>Person</code>的原型，看起来更像：</p>
<pre><code><span class="comment">// var this = Object.create(Person.prototype);</span>
</code></pre><p>在后续章节会进一步讨论<code>Object.create()</code>。</p>
<h3 id="构造函数的返回值">构造函数的返回值</h3><p>当使用<code>new</code>调用的时候，构造函数总是会返回一个对象，默认情况下返回<code>this</code>所指向的对象。如果构造函数内没有给<code>this</code>赋任何属性，则返回一个“空”对象（除了继承构造函数的原型之外，没有自有属性）。</p>
<p>尽管在构造函数中没有<code>return</code>语句的情况下，也会隐式返回<code>this</code>。但事实上我们是可以返回任意指定的对象的，在下面的例子中就返回了新创建的<code>that</code>对象。</p>
<pre><code><span class="keyword">var</span> Objectmaker = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{

    <span class="comment">// name属性会被忽略，因为返回的是另一个对象</span>
    <span class="keyword">this</span>.name = <span class="string">"This is it"</span>;

    <span class="comment">// 创建并返回一个新对象</span>
    <span class="keyword">var</span> that = {};
    that.name = <span class="string">"And that's that"</span>;
    <span class="keyword">return</span> that;
};

<span class="comment">// 测试</span>
<span class="keyword">var</span> o = <span class="keyword">new</span> Objectmaker();
<span class="built_in">console</span>.log(o.name); <span class="comment">// "And that's that"</span>
</code></pre><p>可以看到，构造函数中其实是可以返回任意对象的，只要你返回的东西是对象即可。如果返回值不是对象（字符串、数字或布尔值），程序不会报错，但这个返回值被忽略，最终还是返回<code>this</code>所指的对象。</p>
<h2 id="强制使用new的模式">强制使用new的模式</h2><p>我们知道，构造函数和普通的函数本质一样，只是通过<code>new</code>调用而已。那么如果调用构造函数时忘记<code>new</code>会发生什么呢？漏掉<code>new</code>不会产生语法错误也不会有运行时错误，但可能会造成逻辑错误，导致执行结果不符合预期。这是因为如果不写<code>new</code>的话，函数内的<code>this</code>会指向全局对象（在浏览器端<code>this</code>指向<code>window</code>）。</p>
<p>当构造函数内包含<code>this.member</code>之类的代码，并直接调用这个函数（省略<code>new</code>），实际上会创建一个全局对象的属性<code>member</code>，可以通过<code>window.member</code>或<code>member</code>访问到。这不是我们想要的结果，因为我们要努力确保全局命名空间干净。</p>
<pre><code><span class="comment">// 构造函数</span>
<span class="function"><span class="keyword">function</span> <span class="title">Waffle</span>(<span class="params"></span>) </span>{
    <span class="keyword">this</span>.tastes = <span class="string">"yummy"</span>;
}

<span class="comment">// 新对象</span>
<span class="keyword">var</span> good_morning = <span class="keyword">new</span> Waffle();
<span class="built_in">console</span>.log(<span class="keyword">typeof</span> good_morning); <span class="comment">// "object"</span>
<span class="built_in">console</span>.log(good_morning.tastes); <span class="comment">// "yummy"</span>

<span class="comment">// 反模式，漏掉new</span>
<span class="keyword">var</span> good_morning = Waffle();
<span class="built_in">console</span>.log(<span class="keyword">typeof</span> good_morning); <span class="comment">// "undefined"</span>
<span class="built_in">console</span>.log(<span class="built_in">window</span>.tastes); <span class="comment">// "yummy"</span>
</code></pre><p>ECMAScript5中修正了这种出乎意料的行为逻辑。在严格模式中，<code>this</code>不再指向全局对象。如果在不支持ES5的JavaScript环境中，也有一些方法可以确保有没有<code>new</code>时构造函数的行为都保持一致。</p>
<h3 id="命名规范">命名规范</h3><p>一种简单解决上述问题的方法就是命名规范，前面的章节已经讨论过，构造函数首字母大写（<code>MyConstructor()</code>），普通函数和方法首字母小写（<code>myFunction</code>）。</p>
<h3 id="使用that">使用that</h3><p>遵守命名规范有一定的作用，但规范毕竟不是强制，不能完全避免出现错误。这里给出了一种模式可以确保构造函数一定会按照构造函数的方式执行，那就是不要将所有成员添加到<code>this</code>上，而是将它们添加到<code>that</code>上，并返回<code>that</code>。</p>
<pre><code><span class="keyword">function</span> Waffle() {
    <span class="keyword">var</span> <span class="literal">that</span> = {};
    <span class="literal">that</span>.tastes = <span class="string">"yummy"</span>;
    <span class="keyword">return</span> <span class="literal">that</span>;
}
</code></pre><p>如果要创建更简单一点的对象，甚至不需要局部变量<code>that</code>，直接返回一个对象字面量即可，就像这样：</p>
<pre><code><span class="tag">function</span> <span class="tag">Waffle</span>() {
    <span class="tag">return</span> {
        <span class="attribute">tastes</span>: <span class="string">"yummy"</span>
    };
}
</code></pre><p>不管用什么方式调用它（使用<code>new</code>或直接调用），它都会返回一个实例对象：</p>
<pre><code>var first = <span class="keyword">new</span> Waffle(),
    <span class="built_in">second</span> = Waffle();
console.<span class="built_in">log</span>(first.tastes); <span class="comment">// "yummy"</span>
console.<span class="built_in">log</span>(<span class="built_in">second</span>.tastes); <span class="comment">// "yummy"</span>
</code></pre><p>这种模式的问题是会丢失原型，因此在<code>Waffle()</code>的原型上的成员不会被继承到这些对象中。</p>
<blockquote>
<p>需要注意的是，这里用的<code>that</code>只是一种命名规范，<code>that</code>并不是语言特性的一部分，它可以被替换为任何你喜欢的名字，比如<code>self</code>或<code>me</code>。</p>
</blockquote>
<h3 id="调用自身的构造函数">调用自身的构造函数</h3><p>为了解决上述模式的问题，能够让对象继承原型上的属性，我们使用下面的方法：在构造函数中首先检查<code>this</code>是否是构造函数的实例，如果不是，则通过<code>new</code>再次调用自己：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Waffle</span>(<span class="params"></span>) </span>{

    <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Waffle)) {
        <span class="keyword">return</span> <span class="keyword">new</span> Waffle();
    }
    <span class="keyword">this</span>.tastes = <span class="string">"yummy"</span>;

}
Waffle.prototype.wantAnother = <span class="literal">true</span>;

<span class="comment">// 测试</span>
<span class="keyword">var</span> first = <span class="keyword">new</span> Waffle(),
    second = Waffle();

<span class="built_in">console</span>.log(first.tastes); <span class="comment">// "yummy"</span>
<span class="built_in">console</span>.log(second.tastes); <span class="comment">// "yummy"</span>

<span class="built_in">console</span>.log(first.wantAnother); <span class="comment">// true</span>
<span class="built_in">console</span>.log(second.wantAnother); <span class="comment">// true</span>
</code></pre><p>还有一种比较通用的用来检查实例的方法是使用<code>arguments.callee</code>，而不是直接将构造函数名写死在代码中：</p>
<pre><code><span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> <span class="built_in">arguments</span>.callee)) {
    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">arguments</span>.callee();
}
</code></pre><p>这种模式利用了一个事实，即在任何函数内部都会创建一个<code>arguments</code>对象，它包含函数调用时传入的参数。同时<code>arguments</code>包含一个<code>callee</code>属性，指向正在被调用的函数。需要注意，ES5严格模式中已经禁止了<code>arguments.callee</code>的使用，因此最好对它的使用加以限制，并尽可能删除现有代码中已经用到的地方。</p>
<h2 id="数组字面量">数组字面量</h2><p>和JavaScript中大多数“东西”一样，数组也是对象。可以通过内置构造函数<code>Array()</code>来创建数组，也可以通过字面量形式创建，就像对象字面量那样。而且更推荐使用字面量创建数组。</p>
<p>这里的示例代码给出了创建两个具有相同元素的数组的两种方法，使用<code>Array()</code>和使用字面量模式：</p>
<pre><code><span class="comment">// 有三个元素的数组</span>
<span class="comment">// 注意：这是反模式</span>
<span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"itsy"</span>, <span class="string">"bitsy"</span>, <span class="string">"spider"</span>);

<span class="comment">// 完全相同的数组</span>
<span class="keyword">var</span> a = [<span class="string">"itsy"</span>, <span class="string">"bitsy"</span>, <span class="string">"spider"</span>];

<span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">// "object"，因为数组也是对象</span>
<span class="built_in">console</span>.log(a.constructor === <span class="built_in">Array</span>); <span class="comment">// true</span>
</code></pre><h3 id="数组字面量语法">数组字面量语法</h3><p>数组字面量写法非常简单：整个数组使用方括号括起来，数组元素之间使用逗号分隔。数组元素可以是任意类型，包括数组和对象。</p>
<p>数组字面量语法简单直观而且优雅，毕竟数组只是从0开始索引的一些值的集合，完全没必要引入构造器和<code>new</code>运算符（还要写更多的代码）。</p>
<h3 id="Array()构造函数的“陷阱”">Array()构造函数的“陷阱”</h3><p>我们对<code>new Array()</code>敬而远之还有一个原因，就是为了避免构造函数带来的陷阱。</p>
<p>如果给<code>Array()</code>构造函数传入一个数字，这个数字并不会成为数组的第一个元素，而是设置了数组的长度。也就是说，<code>new Array(3)</code>创建了一个长度为3的数组，而不是某个元素是3。如果你访问数组的任意元素都会得到<code>undefined</code>，因为元素并不存在。下面的示例代码展示了字面量和构造函数的区别：</p>
<pre><code><span class="comment">// 含有1个元素的数组</span>
var a = [<span class="number">3</span>];
console.<span class="built_in">log</span>(a.length); <span class="comment">// 1</span>
console.<span class="built_in">log</span>(a[<span class="number">0</span>]); <span class="comment">// 3</span>

<span class="comment">// 含有3个元素的数组</span>
var a = <span class="keyword">new</span> Array(<span class="number">3</span>);
console.<span class="built_in">log</span>(a.length); <span class="comment">// 3</span>
console.<span class="built_in">log</span>(typeof a[<span class="number">0</span>]); <span class="comment">// "undefined"</span>
</code></pre><p>构造函数的行为可能有一点出乎意料，但当给<code>new Array()</code>传入一个浮点数时情况就更糟糕了，这时会出错（译注：给new Array()传入浮点数会报“范围错误”RangError），因为数组长度不可能是浮点数。</p>
<pre><code><span class="comment">// 使用数组字面量</span>
<span class="keyword">var</span> a = [<span class="number">3.14</span>];
<span class="built_in">console</span>.log(a[<span class="number">0</span>]); <span class="comment">// 3.14</span>

<span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3.14</span>); <span class="comment">// RangeError: invalid array length</span>
<span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">// "undefined"</span>
</code></pre><p>为了避免在运行时动态创建数组时出现这种错误，强烈推荐使用数组字面量来代替<code>new Array()</code>。</p>
<blockquote>
<p>有些人用<code>Array()</code>构造器来做一些有意思的事情，比如用来生成重复字符串。下面这行代码返回的字符串包含255个空格（请读者思考为什么不是256个空格）。<code>var white = new Array(256).join(&#39; &#39;);</code></p>
</blockquote>
<h3 id="检查是否数组">检查是否数组</h3><p>如果<code>typeof</code>的操作数是数组的话，将返回“object”。</p>
<pre><code>console.<span class="built_in">log</span>(typeof [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// "object"</span>
</code></pre><p>这个结果勉强说得过去，毕竟数组也是一种对象，但对我们来说这个结果却没什么用，实际上你往往是需要知道一个值是不是真正的数组。有时候你会见到一些检查数组的方法：检查<code>length</code>属性、检查数组方法比如<code>slice()</code>等等，但这些方法非常脆弱，非数组的对象也可以拥有这些同名的属性。还有些人使用<code>instanceof Array</code>来判断数组，但这种方法在某些版本的IE里的多个iframe的场景中会出问题（译注：原因就是在不同iframe中创建的数组不会相互共享其<code>prototype</code>属性）。</p>
<p>ECMAScript5定义了一个新的方法<code>Array.isArray()</code>，如果参数是数组的话就返回true。比如：</p>
<pre><code><span class="built_in">Array</span>.isArray([]); <span class="comment">// true</span>

<span class="comment">// 尝试用一个类似数组的对象去测试</span>
<span class="built_in">Array</span>.isArray({
    length: <span class="number">1</span>,
    <span class="string">"0"</span>: <span class="number">1</span>,
    slice: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{}
}); <span class="comment">// false</span>
</code></pre><p>如果你的开发环境不支持ECMAScript5，可以通过<code>Object.prototype.toString()</code>方法来代替。如调用<code>toString</code>的<code>call()</code>方法并传入数组上下文，将返回字符串“[object Array]”。如果传入对象上下文，则返回字符串“[object Object]”。因此可以这样做：</p>
<pre><code><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Array</span>.isArray === <span class="string">"undefined"</span>) {
    <span class="built_in">Array</span>.isArray = <span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>{
        <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(arg) === <span class="string">"[object Array]"</span>;
    };
}
</code></pre><h2 id="JSON">JSON</h2><p>我们刚刚讨论了对象和数组字面量，你应该很熟悉了，现在我们来看一看JSON。JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，可以很容易地用在多种语言中，尤其是在JavaScript中。</p>
<p>JSON格式及其简单，它只是数组和对象字面量的混合写法，看一个JSON字符串的例子：</p>
<pre><code>{"<span class="attribute">name</span>": <span class="value"><span class="string">"value"</span></span>, "<span class="attribute">some</span>": <span class="value">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span>}
</code></pre><p>JSON和对象字面量在语法上的唯一区别是，合法的JSON属性名均需要用引号包含。而在对象字面量中，只有属性名是非法的标识符时才使用引号包含，比如，属性名中包含空格<code>{&quot;first name&quot;: &quot;Dave&quot;}</code>。</p>
<p>在JSON字符串中，不能使用函数和正则表达式字面量。</p>
<h3 id="使用JSON">使用JSON</h3><p>在前面的章节中讲到，出于安全考虑，不推荐使用<code>eval()</code>来粗暴地解析JSON字符串。最好是使用<code>JSON.parse()</code>方法，ES5中已经包含了这个方法，并且现代浏览器的JavaScript引擎中也已经内置支持JSON了。对于老旧的JavaScript引擎来说，你可以使用JSON.org所提供的JS文件（<a href="http://www.json.org/json2.js" target="_blank" rel="external">http://www.json.org/json2.js</a>）来获得JSON对象和方法。</p>
<pre><code><span class="comment">// 输入JSON字符串</span>
<span class="built_in">var</span> jstr = <span class="string">'{"mykey": "my value"}'</span>;

<span class="comment">// 反模式</span>
<span class="built_in">var</span> <span class="built_in">data</span> = eval(<span class="string">'('</span> + jstr + <span class="string">')'</span>);

<span class="comment">// 更好的方式</span>
<span class="built_in">var</span> <span class="built_in">data</span> = JSON<span class="built_in">.</span>parse(jstr);

console<span class="built_in">.</span><span class="keyword">log</span>(<span class="built_in">data</span><span class="built_in">.</span>mykey); <span class="comment">// "my value"</span>
</code></pre><p>如果你已经在使用某个JavaScript库了，很可能这个库中已经提供了解析JSON的方法，就不必再额外引入JSON.org的库了，比如，如果你已经使用了YUI3，你可以这样：</p>
<pre><code><span class="comment">// 输入JSON字符串</span>
<span class="keyword">var</span> jstr = <span class="string">'{"mykey": "my value"}'</span>;

<span class="comment">// 使用YUI来解析并将结果返回为一个对象</span>
YUI().<span class="keyword">use</span>(<span class="string">'json-parse'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(Y)</span> </span>{
    <span class="keyword">var</span> data = Y.JSON.parse(jstr);
    console.log(data.mykey); <span class="comment">// "my value"</span>
});
</code></pre><p>如果你使用的是jQuery，可以直接使用它提供的<code>parseJSON()</code>方法：</p>
<pre><code><span class="comment">// 输入JSON字符串</span>
<span class="variable"><span class="keyword">var</span> jstr</span> = '{<span class="string">"mykey"</span>: <span class="string">"my value"</span>}';

<span class="variable"><span class="keyword">var</span> data</span> = jQuery.parseJSON(jstr);
console.log(data.mykey); <span class="comment">// "my value"</span>
</code></pre><p>和<code>JSON.parse()</code>方法相对应的是<code>JSON.stringify()</code>。它将对象或数组（或任何原始值）转换为JSON字符串。</p>
<pre><code><span class="keyword">var</span> dog = {
    <span class="attribute">name</span>: <span class="string">"Fido"</span>,
    <span class="attribute">dob</span>:<span class="keyword">new</span> Date(),
    <span class="attribute">legs</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]
};

<span class="keyword">var</span> jsonstr = JSON.stringify(dog);

<span class="pi">// jsonstr的值为
//</span> {<span class="string">"name"</span>:<span class="string">"Fido"</span>,<span class="string">"dob"</span>:<span class="string">"2010-04-11T22:36:22.436Z"</span>,<span class="string">"legs"</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]}
</code></pre><h2 id="正则表达式字面量">正则表达式字面量</h2><p>JavaScript中的正则表达式也是对象，可以通过两种方式创建它们：</p>
<ul>
<li>使用<code>new RegExp()</code>构造函数</li>
<li>使用正则表达式字面量</li>
</ul>
<p>下面的示例代码展示了创建用来匹配一个反斜杠（\）的正则表达式的两种方法：</p>
<pre><code><span class="comment">// 正则表达式字面量</span>
<span class="keyword">var</span> re = <span class="regexp">/\\/gm</span>;

<span class="comment">// 构造函数</span>
<span class="keyword">var</span> re = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\\\"</span>, <span class="string">"gm"</span>);
</code></pre><p>显然正则表达式字面量写法的代码更短，而且不会让你觉得在用像类一样的构造函数的思想在写正则表达式，因此更推荐使用字面量写法。</p>
<p>另外，如果使用<code>RegExp()</code>构造函数写法，还需要考虑对引号和反斜杠进行转义，正如上段代码所示的那样，用了四个反斜杠来匹配一个反斜杠。这会增加正则表达式的长度，而且让它变得难于理解和维护。正则表达式入门不是件容易的事，所以不要放弃任何一个简化它们的机会，尽量使用字面量而不是通过构造函数来创建正则表达式。</p>
<h3 id="正则表达式字面量语法">正则表达式字面量语法</h3><p>正则表达式字面量使用两个斜杠包裹，主体部分不包括两端的斜线。在第二个斜线之后可以指定模式匹配的修饰符，修饰符不需要用引号引起来，JavaScript中有三个修饰符：</p>
<ul>
<li><code>g</code>，全局匹配</li>
<li><code>m</code>，多行匹配</li>
<li><code>i</code>，忽略大小写的匹配</li>
</ul>
<p>修饰符可以自由组合，而且与顺序无关：</p>
<pre><code><span class="keyword">var</span> re = <span class="regexp">/pattern/gmi</span>;
</code></pre><p>使用正则表达式字面量可以让代码更加简洁高效，比如当调用<code>String.prototype.replace()</code>方法时，可以传入正则表达式参数：</p>
<pre><code><span class="keyword">var</span> no_letters = <span class="string">"abc123XYZ"</span>.replace(<span class="regexp">/[a-z]/gi</span>, <span class="string">""</span>);
<span class="built_in">console</span>.log(no_letters); <span class="comment">// 123</span>
</code></pre><p>有一种不得不使用<code>new RegExp()</code>的场景，就是正则表达式是不确定，只有等到运行时才能确定下来的情况。</p>
<p>正则表达式字面量和构造函数还有另一个区别，就是字面量只在解析时创建一次正则表达式对象（译注：多次解析同一个正则表达式，会产生相同的实例对象）。如果在循环体内反复使用相同的字面量创建对象，则会返回第一次创建的对象以及它的属性（比如<code>lastIndex</code>）。下面这个例子展示了两次返回相同的正则表达式的情形。</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">getRE</span>(<span class="params"></span>) </span>{
    <span class="keyword">var</span> re = <span class="regexp">/[a-z]/</span>;
    re.foo = <span class="string">"bar"</span>;
    <span class="keyword">return</span> re;
}

<span class="keyword">var</span> reg = getRE(),
    re2 = getRE();

<span class="built_in">console</span>.log(reg === re2); <span class="comment">// true</span>
reg.foo = <span class="string">"baz"</span>;
<span class="built_in">console</span>.log(re2.foo); <span class="comment">// "baz"</span>
</code></pre><blockquote>
<p>在ECMAScript5中这种情况有所改变，相同正则表达式字面量的每次计算都会创建新的实例对象，目前很多现代浏览器也对此做了纠正。</p>
</blockquote>
<p>最后需要提一点，不带<code>new</code>调用<code>RegExp()</code>（作为普通的函数）和带<code>new</code>调用<code>RegExp()</code>是完全一样的。</p>
<h2 id="原始值的包装对象">原始值的包装对象</h2><p>JavaScript中有五种原始类型：数字、字符串、布尔值、<code>null</code>和<code>undefined</code>。除了<code>null</code>和<code>undefined</code>之外，其他三种都有对应的“包装对象”（primitive wrapper object）。可以通过内置构造函数<code>Number()</code>、<code>String()</code>和<code>Boolean()</code>来生成包装对象。</p>
<p>为了说明数字原始值和数字对象之间的区别，看一下下面这个例子：</p>
<pre><code><span class="comment">// 一个数字原始值</span>
<span class="keyword">var</span> n = <span class="number">100</span>;
<span class="built_in">console</span>.log(<span class="keyword">typeof</span> n); <span class="comment">// "number"</span>

<span class="comment">// 一个Number对象</span>
<span class="keyword">var</span> nobj = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">100</span>);
<span class="built_in">console</span>.log(<span class="keyword">typeof</span> nobj); <span class="comment">// "object"</span>
</code></pre><p>包装对象带有一些有用的属性和方法。比如，数字对象就带有<code>toFixed()</code>和<code>toExponential()</code>之类的方法，字符串对象带有<code>substring()</code>、<code>chatAt()</code>和<code>toLowerCase()</code>等方法以及<code>length</code>属性。这些方法非常方便，和原始值相比，这是包装对象的优势，但其实原始值也可以调用这些方法，因为原始值会首先转换为一个临时对象，如果转换成功，则调用包装对象的方法。</p>
<pre><code><span class="comment">// 像使用对象一样使用一个字符串原始值</span>
var s = <span class="string">"hello"</span>;
console.<span class="built_in">log</span>(s.toUpperCase()); <span class="comment">// "HELLO"</span>

<span class="comment">// 值本身也可以像对象一样</span>
<span class="string">"monkey"</span>.slice(<span class="number">3</span>, <span class="number">6</span>); <span class="comment">// "key"</span>

<span class="comment">// 数字也是一样</span>
(<span class="number">22</span> / <span class="number">7</span>).toPrecision(<span class="number">3</span>); <span class="comment">// "3.14"</span>
</code></pre><p>因为原始值可以根据需要转换成对象，这样的话，也不必为了用包装对象的方法而将原始值手动“包装”成对象。比如，不必使用new String(“hi”)，直接使用”hi”即可。</p>
<pre><code><span class="comment">// 避免这些：</span>
<span class="variable"><span class="keyword">var</span> s</span> = new String(<span class="string">"my string"</span>);
<span class="variable"><span class="keyword">var</span> n</span> = new Number(<span class="number">101</span>);
<span class="variable"><span class="keyword">var</span> b</span> = new <span class="typename">Boolean</span>(<span class="literal">true</span>);

<span class="comment">// 更好更简洁的办法：</span>
<span class="variable"><span class="keyword">var</span> s</span> = <span class="string">"my string"</span>;
<span class="variable"><span class="keyword">var</span> n</span> = <span class="number">101</span>;
<span class="variable"><span class="keyword">var</span> b</span> = <span class="literal">true</span>;
</code></pre><p>不得不使用包装对象的一个场景是，有时我们需要对值进行扩充并保持值的状态。原始值毕竟不是对象，不能直接对其进行扩充。</p>
<pre><code><span class="comment">// 字符串原始值</span>
<span class="keyword">var</span> greet = <span class="string">"Hello there"</span>;

<span class="comment">// 为使用split方法，原始值被转换为对象</span>
greet.split(<span class="string">' '</span>)[<span class="number">0</span>]; <span class="comment">// "Hello"</span>

<span class="comment">// 给原始值添加属性并不会报错</span>
greet.smile = <span class="literal">true</span>;

<span class="comment">// 但实际上却没有作用</span>
<span class="keyword">typeof</span> greet.smile; <span class="comment">// "undefined"</span>
</code></pre><p>在这段示例代码中，<code>greet</code>只是临时被转换成了对象，以保证访问其属性、方法时不会出错。而如果是另一种情况，<code>greet</code>通过<code>new String()</code>被定义为一个对象，那么扩充<code>smile</code>属性的过程就会像我们预期的那样。对字符串、数字或布尔值进行扩充的情况很少见，因此建议只在确实有必要的情况下使用包装对象。</p>
<p>当省略<code>new</code>时，包装对象的构造函数将传给它的参数转换为原始值：</p>
<pre><code><span class="keyword">typeof</span> <span class="built_in">Number</span>(<span class="number">1</span>); <span class="comment">// "number"</span>
<span class="keyword">typeof</span> <span class="built_in">Number</span>(<span class="string">"1"</span>); <span class="comment">// "number"</span>
<span class="keyword">typeof</span> <span class="built_in">Number</span>(<span class="keyword">new</span> <span class="built_in">Number</span>()); <span class="comment">// "number"</span>
<span class="keyword">typeof</span> <span class="built_in">String</span>(<span class="number">1</span>); <span class="comment">// "string"</span>
<span class="keyword">typeof</span> <span class="built_in">Boolean</span>(<span class="number">1</span>); <span class="comment">// "boolean"</span>
</code></pre><h2 id="错误处理对象">错误处理对象</h2><p>JavaScript中有很多内置的错误处理构造函数，比如<code>Error()</code>、<code>SyntaxError()</code>，<code>TypeError()</code>等等，它们通常和<code>throw</code>语句一起被使用。这些构造函数创建的错误对象包含这些属性：</p>
<ul>
<li><p><code>name</code></p>
<p>  name属性是指产生这个对象的构造函数的名字，通常是“Error”，有时会有特定的名字比如“RangeError”</p>
</li>
<li><p><code>message</code></p>
<p>  创建这个对象时传入构造函数的字符串</p>
</li>
</ul>
<p>错误对象还有一些其他的属性，比如产生错误的行号和文件名，但这些属性是浏览器自行实现的，不同浏览器的实现也不一致，因此出于兼容性考虑，并不推荐使用这些属性。</p>
<p><code>throw</code>可以抛出任何对象，并不限于“错误对象”，因此你可以根据需要抛出自定义的对象。这些对象包含属性“name”和“message”或其他你希望传递给异常处理逻辑的信息，异常处理逻辑由<code>catch</code>语句指定。你可以灵活运用抛出的错误对象，将程序从错误状态恢复至正常状态。</p>
<pre><code><span class="keyword">try</span> {
    <span class="comment">// 一些不好的事情发生了，抛出错误</span>
    <span class="keyword">throw</span> {
        name: <span class="string">"MyErrorType"</span>, <span class="comment">// 自定义错误类型</span>
        message: <span class="string">"oops"</span>,
        extra: <span class="string">"This was rather embarrassing"</span>,
        remedy: genericErrorHandler <span class="comment">// 应该由谁处理</span>
    };
} <span class="keyword">catch</span> (e) {
    <span class="comment">// 通知用户</span>
    alert(e.message); <span class="comment">// "oops"</span>

    <span class="comment">// 优雅地处理错误</span>
    e.remedy(); <span class="comment">// 调用genericErrorHandler()</span>
}
</code></pre><p>使用<code>new</code>调用和省略<code>new</code>调用错误构造函数是一模一样的，他们都返回相同的错误对象。</p>
<h2 id="小结">小结</h2><p>在本章里，我们讨论了多种字面量模式，它们是使用构造函数写法的替代方案，本章讲述了这些内容：</p>
<ul>
<li>对象字面量写法——一种简洁优雅的定义对象的方法，通过花括号包裹，名值对之间用逗号分隔</li>
<li>构造函数——内置构造函数（内置构造函数通常都有对应的字面量语法）和自定义构造函数</li>
<li>一种强制函数以构造函数的模式运行行（不管用不用<code>new</code>调用构造函数，都始终返回<code>new</code>出来的实例）的技巧</li>
<li>数组字面量写法——通过方括号包裹，数组元素之间使用逗号分隔</li>
<li>JSON——一种轻量级的数据交换格式</li>
<li>正则表达式字面量</li>
<li>避免使用其他的内置构造函数：<code>String()</code>、<code>Number()</code>、<code>Boolean()</code>以及不同种类的<code>Error()</code>构造函数</li>
</ul>
<p>通常情况下，除了<code>Date()</code>之外，其他的内置构造函数并不常用，下面的表格对这些构造函数以及它们的字面量语法做了整理。</p>
<table><br>    <tr><br>        <td>内置构造函数（不推荐）</td><br>        <td>字面量语法和原始值（推荐）</td><br>    </tr><br>    <tr><br>        <td>var o = new Object();</td><br>        <td>var o = {};<br>        </td><br>    </tr><br>    <tr><br>        <td>var a = new Array();<br>        </td><br>        <td>var a = [];<br>        </td><br>    </tr><br>    <tr><br>        <td>var re = new RegExp(“[a-z]”,”g”);<br>        </td><br>        <td>var re = /[a-z]/g;<br>        </td><br>    </tr><br>    <tr><br>        <td>var s = new String();<br>        </td><br>        <td>var s = “”;<br>        </td><br>    </tr><br>    <tr><br>        <td>var n = new Number();<br>        </td><br>        <td>var n = 0;<br>        </td><br>    </tr><br>    <tr><br>        <td>var b = new Boolean();<br>        </td><br>        <td>var b = false;<br>        </td><br>    </tr><br>    <tr><br>        <td>throw new Error(“uh-oh”);<br>        </td><br>        <td>throw { name: “Error”,message: “uh-oh”};或者throw Error(“uh-oh”);<br>        </td><br>    </tr><br></table>


</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/06/javascript/javascript-patterns/chapter4/" itemprop="url">
                第四章 函数
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-06T22:08:29+08:00" content="2015-12-06">
            2015-12-06
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/12/06/javascript/javascript-patterns/chapter4/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/12/06/javascript/javascript-patterns/chapter4/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>熟练运用函数是JavaScript程序员的必备技能，因为在JavaScript中函数实在是太常用了。它能够完成各种类型的任务，而在其他语言中则需要很多特殊的语法支持才能拥有这种能力。</p>
<p>本章将会介绍在JavaScript中定义函数的几种方式，包括函数表达式和函数声明以及局部作用域和变量声明提前的工作原理。然后会介绍一些有用的模式，帮助你设计API（为你的函数提供更好的接口）、搭建代码架构（使用尽可能少的全局对象）、并优化性能（避免不必要的操作）。</p>
<p>现在让我们来一起揭秘JavaScript函数，首先从一些背景知识开始说起。</p>
<h2 id="背景知识">背景知识</h2><p>JavaScript的函数具有两个主要特性，正是这两个特性让它们与众不同。第一个特性是，函数是一等对象（first-class object），第二个是函数提供作用域支持。</p>
<p>函数是对象，那么：</p>
<ul>
<li>可以在程序执行时动态创建函数</li>
<li>可以将函数赋值给变量，可以将函数的引用拷贝至另一个变量，可以扩充函数，除了某些特殊场景外均可被删除</li>
<li>可以将函数作为参数传入另一个函数，也可以被当作返回值返回</li>
<li>函数可以包含自己的属性和方法</li>
</ul>
<p>有可能会有这样的情况：一个函数A，它也是一个对象，拥有属性和方法，其中某个属性是另一个函数B，B可以接受函数作为参数，假设这个函数参数为C，当执行B的时候，返回另一个函数D。乍一看这里有一大堆相互关联的函数，但当你开始习惯函数的许多用法时，你会惊叹原来函数是如此灵活、强大且富有表现力。通常说来，一说到JavaScript的函数，我们首先认为它是一个对象，具有一个可以“执行”的特性，也就是说我们可以“调用”这个函数。</p>
<p>我们通过<code>new Function()</code>构造函数来创建一个函数，这时可以明显看出函数是对象：</p>
<pre><code><span class="comment">// 反模式，仅用于演示</span>
<span class="keyword">var</span> <span class="keyword">add</span> = <span class="keyword">new</span> <span class="function"><span class="keyword">Function</span><span class="params">(<span class="string">'a, b'</span>, <span class="string">'return a + b'</span>)</span>;</span>
<span class="keyword">add</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 返回 3</span>
</code></pre><p>在这段代码中，毫无疑问<code>add()</code>是一个对象，因为它是由构造函数创建的。这里并不推荐使用<code>Function()</code>构造函数来创建函数（和<code>eval()</code>一样糟糕），因为程序逻辑代码是以字符串的形式传入构造器的。这样的代码可读性差，写起来也很费劲，你还要对代码中的引号做转义处理，并需要特别关注为了保持可读性而保留的空格和缩进。</p>
<p>函数的第二个重要特性是它能提供作用域支持。在JavaScript中没有块级作用域（译注：在JavaScript1.7中提供了块级作用域部分特性的支持，可以通过<code>let</code>来声明块级作用域内的“局部变量”），也就是说不能通过花括号来创建作用域，JavaScript中只有函数作用域（译注：这里只针对函数而言，此外JavaScript还有全局作用域）。在函数内所有通过<code>var</code>声明的变量都是局部变量，在函数外部是不可见的。刚才所说的花括号无法提供作用域支持的意思是说，如果在<code>if</code>条件句、<code>for</code>或<code>while</code>循环体内用<code>var</code>定义了变量，这个变量并不是属于<code>if</code>语句或<code>for</code>（<code>while</code>）循环的局部变量，而是属于它所在的函数。如果不在任何函数内部，它会成为全局变量。在第二章里提到我们要减少对全局命名空间的污染，那么使用函数则是控制变量作用域的最佳选择。</p>
<h3 id="术语">术语</h3><p>首先我们先简单讨论下与创建函数相关的术语，因为精确无歧义的术语约定非常重要。</p>
<p>看下这个代码片段：</p>
<pre><code><span class="comment">// 具名函数表达式</span>
<span class="keyword">var</span> <span class="keyword">add</span> = <span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(a, b)</span> <span class="comment">{
    return a + b;
}</span>;</span>
</code></pre><p>这段代码描述了一个函数，这种描述称为“具名函数表达式”。</p>
<p>如果省略掉函数表达式中的名字（比如下面的示例代码），这时它是“匿名函数表达式”，通常我们称之为“匿名函数”，比如：</p>
<pre><code><span class="comment">// 匿名函数表达式，又称匿名函数</span>
<span class="keyword">var</span> <span class="keyword">add</span> = <span class="function"><span class="keyword">function</span> <span class="params">(a, b)</span> <span class="comment">{
    return a + b;
}</span>;</span>
</code></pre><p>因此“函数表达式”是一个更广义的概念，“具名函数表达式”是函数表达式的一种特殊形式，仅仅当需要给函数定义一个可选的名字时使用。</p>
<p>当省略第二个<code>add</code>，它就成了没有名字的函数表达式，这不会对函数定义和调用语法造成任何影响。带名字和不带名字唯一的区别是函数对象的<code>name</code>属性是否为空字符串。<code>name</code>属性属于语言的扩展（未在ECMA标准中定义），但很多环境都实现了。如果不省略第二个<code>add</code>，那么<code>add.name</code>是”add”，<code>name</code>属性在用像Firebug之类的调试工具进行调试的过程中非常有用，它也可以让函数递归调用自身，如果是其他情况，则可以省略它。</p>
<p>最后来看一下“函数声明”，函数声明的语法和其他语言中的语法非常类似：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>{
    <span class="comment">// 函数体</span>
}
</code></pre><p>从语法上来看，具名函数表达式和函数声明非常像，特别是当不需要将函数表达式赋值给一个变量的时候（在本章后面所讲到的回调模式中有类似的例子）。多数情况下，函数声明和具名函数表达式在外观上没有多少不同，只是它们在函数执行时对上下文的影响有所区别，下一小节会讲到。</p>
<p>两种语法的一个区别是末尾的分号。函数声明末尾不需要分号，而函数表达式末尾是需要分号的。推荐你始终不要丢掉函数表达式末尾的分号，即便JavaScript可以进行分号补全，也不要冒险这样做。</p>
<blockquote>
<p>另外我们经常看到“函数字面量”。它用来表示函数表达式或具名函数表达式。由于这个术语是有歧义的，所以最好不要用它。</p>
</blockquote>
<h3 id="声明_vs_表达式：命名与提前">声明 vs 表达式：命名与提前</h3><p>那么，到底应该用哪个呢？函数声明还是函数表达式？在不能使用函数声明语法的场景下，就只能使用函数表达式了，将函数作为参数传递、在对象字面量中定义方法都是这样的例子：</p>
<pre><code><span class="comment">// 作为参数传递给callMe的函数表达式</span>
callMe(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="comment">// 我是匿名函数表达式，也叫匿名函数</span>
});

<span class="comment">// 这是一个具名函数表达式</span>
callMe(<span class="function"><span class="keyword">function</span> <span class="title">me</span><span class="params">()</span> </span>{
    <span class="comment">// 我是具名函数表达式，我的名字是“me”</span>
});

<span class="comment">// 另一个函数表达式</span>
<span class="keyword">var</span> myobject = {
    say: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        <span class="comment">// 我是函数表达式</span>
    }
};
</code></pre><p>函数声明只能出现在“程序代码”中，也就是说在别的函数体内或在全局。这个定义不能赋值给变量或属性，同样不能作为函数调用的参数。（译注：注意这里说的是函数声明的语句，而不是通过声明语句定义出来的函数本身。任何函数都是可以被赋值给变量和属性的，也可以被作为参数传递。）下面这个例子是函数声明的合法用法，这里所有的函数<code>foo()</code>，<code>bar()</code>和<code>local()</code>都使用函数声明来定义：</p>
<pre><code><span class="comment">// 全局作用域</span>
<span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>{}

<span class="function"><span class="keyword">function</span> <span class="title">local</span><span class="params">()</span> </span>{
    <span class="comment">// 本地作用域</span>
    <span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span> </span>{}
    <span class="keyword">return</span> bar;
}
</code></pre><h3 id="函数的name属性">函数的name属性</h3><p>选择用哪种模式定义函数时的另一个考虑是只读属性<code>name</code>的可用性。尽管标准规范中并未定义，但很多运行环境都实现了<code>name</code>属性，在函数声明和具名函数表达式中是有<code>name</code>属性的。在匿名函数表达式中，则不一定有定义，这个是和实现相关的，在IE中是无定义的，在Firefox和Safari中是有定义的，但是值为空字符串。</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>{} <span class="comment">// 函数声明</span>
<span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{}; <span class="comment">// 匿名函数表达式</span>
<span class="keyword">var</span> baz = <span class="function"><span class="keyword">function</span> <span class="title">baz</span><span class="params">()</span> </span>{}; <span class="comment">// 具名函数表达式</span>

foo.name; <span class="comment">// "foo"</span>
bar.name; <span class="comment">// ""</span>
baz.name; <span class="comment">// "baz"</span>
</code></pre><p>在Firebug或其他工具中调试程序时<code>name</code>属性非常有用，它可以用来显示当前正在执行的函数。同样可以通过<code>name</code>属性来递归地调用函数自身。如果你对这些场景不感兴趣，那么请尽可能地使用匿名函数表达式，这样会更简单、且冗余代码更少。</p>
<p>相对函数声明而言，函数表达式的语法更能说明函数是一种和其它对象类似的对象，而不是语言中某种特别的组成部分。</p>
<blockquote>
<p>我们可以将一个带名字的函数表达式赋值给变量，变量名和函数名不同，这在技术上是可行的。比如：<code>var foo = function bar(){};</code>。然而，这种用法的行为在浏览器中的兼容性不好（特别是IE中），因此并不推荐大家使用这种模式。</p>
</blockquote>
<h3 id="声明提前">声明提前</h3><p>通过前面的讲解，你可能以为函数声明和具名函数表达式是完全等价的。事实上并不是这样，主要区别在于“声明提前”的行为。</p>
<blockquote>
<p>术语“提前”并未在ECMAScript中定义，但是它是一种很好地描述这种行为的方法。</p>
</blockquote>
<p>我们知道，不管在函数内何处声明变量，变量都会自动提前至函数体的顶部。对于函数来说亦是如此，因为他们也是一种对象，赋值给了变量。需要注意的是，函数声明定义的函数不仅能让声明提前，还能让定义提前，看一下这段示例代码：</p>
<pre><code><span class="comment">// 反模式，仅用于演示</span>

<span class="comment">// 全局函数</span>
<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>{
    alert(<span class="string">'global foo'</span>);
}
<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>{
    alert(<span class="string">'global bar'</span>);
}

<span class="function"><span class="keyword">function</span> <span class="title">hoistMe</span>(<span class="params"></span>) </span>{

    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo); <span class="comment">// "function"</span>
    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> bar); <span class="comment">// "undefined"</span>

    foo(); <span class="comment">// "local foo"</span>
    bar(); <span class="comment">// TypeError: bar is not a function</span>

    <span class="comment">// 函数声明：</span>
    <span class="comment">// 变量foo和它的定义实现都被提前了</span>

    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>{
        alert(<span class="string">'local foo'</span>);
    }

    <span class="comment">// 函数表达式：</span>
    <span class="comment">// 只有变量bar被提前，它的定义实现没有被提前</span>
    <span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
        alert(<span class="string">'local bar'</span>);
    };
}
hoistMe();
</code></pre><p>在这段代码中，和普通的变量一样，<code>hoistMe()</code>函数中的<code>foo</code>和<code>bar</code>被“搬运”到了顶部，覆盖了全局的<code>foo()</code>和<code>bar()</code>。不同之处在于，本地的<code>foo()</code>的位置并不在前面，但它的定义却被提前到了顶部并能正常工作，而<code>bar()</code>的定义并未提前，只有声明提前了。因此当程序执行到<code>bar()</code>定义的位置之前，它的值都不是函数，而是<code>undefined</code>（在此期间全局的<code>bar()</code>都是被本地覆盖的）。</p>
<p>到目前为止我们介绍了必要的背景知识和函数定义相关的术语，下面开始介绍一些JavaScript所提供的函数相关的模式，我们从回调模式开始。再次强调JavaScript函数的两个特性，掌握这两点至关重要：</p>
<ul>
<li>函数是对象</li>
<li>函数提供本地变量作用域</li>
</ul>
<h2 id="回调模式">回调模式</h2><p>函数是对象，也就意味着函数可以当作参数传入另外一个函数中。给函数<code>writeCode()</code>传入一个函数参数<code>introduceBugs()</code>，在某个时刻<code>writeCode()</code>执行了（或调用了）<code>introduceBugs()</code>，在这种情况下，我们称<code>introduceBugs()</code>是一个“回调函数”，简称“回调”：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">writeCode</span><span class="params">(callback)</span> </span>{
    <span class="comment">// 做点什么……</span>
    <span class="keyword">callback</span>();
    <span class="comment">// ……</span>
}

<span class="function"><span class="keyword">function</span> <span class="title">introduceBugs</span><span class="params">()</span> </span>{
    <span class="comment">// ……</span>
}

writeCode(introduceBugs);
</code></pre><p>注意<code>introduceBugs()</code>作为参数传入<code>writeCode()</code>时，函数后面是不带括号的。括号的意思是执行函数，而这里我们希望传入一个引用，让<code>writeCode()</code>在合适的时机执行它（调用它）。</p>
<h3 id="回调的例子">回调的例子</h3><p>我们从一个例子开始，首先介绍无回调的情况，然后再进行修改。假设你有一个通用的函数，用来完成某种复杂的逻辑并返回一大段数据。假设这个通用函数叫<code>findNodes()</code>，用来对DOM树进行遍历，并返回页面节点：</p>
<pre><code><span class="keyword">var</span> findNodes = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="keyword">var</span> i = <span class="number">100000</span>, <span class="comment">// 大量耗时的循环</span>
        nodes = [], <span class="comment">// 存储结果</span>
        found; <span class="comment">// 标示下找到的节点</span>
    <span class="keyword">while</span> (i) {
        i -= <span class="number">1</span>;
        <span class="comment">// 这里是复杂的逻辑……</span>
        nodes.push(found);
    }
    <span class="keyword">return</span> nodes;
};
</code></pre><p>保持这个函数的功能的通用性，让它只返回DOM节点组成的数组，而不对节点进行操作是一个很好的思想。可以将操作节点的逻辑放入另外一个函数中，比如<code>hide()</code>函数，这个函数用来隐藏页面中的节点元素：</p>
<pre><code><span class="keyword">var</span> hide = <span class="function"><span class="keyword">function</span> <span class="params">(nodes)</span> <span class="comment">{
    var i = 0, max = nodes.length;
    for (; i &lt; max; i += 1) {
        nodes[i].style.display = "none";
    }</span>
};</span>

<span class="comment">// 执行函数</span>
hide(findNodes());
</code></pre><p>这个实现的效率并不高，因为它将<code>findNodes()</code>所返回的节点数组重新遍历了一遍。更高效的办法是在<code>findNodes()</code>中选择元素的时候就直接应用<code>hide()</code>操作，这样就能避免第二次的遍历，从而提高效率。但如果将<code>hide()</code>的逻辑写死在<code>findNodes()</code>的函数体内，<code>findNodes()</code>就变得不再通用了，因为修改逻辑和遍历逻辑耦合在一起了。这时候如果使用回调模式，就可以将隐藏节点的逻辑写入回调函数，将其传入<code>findNodes()</code>中适时执行：</p>
<pre><code><span class="comment">// 重构后的findNodes()接受一个回调函数</span>
<span class="keyword">var</span> findNodes = <span class="function"><span class="keyword">function</span> <span class="params">(callback)</span> </span>{
    <span class="keyword">var</span> i = <span class="number">100000</span>,
        nodes = [],
        found;

    <span class="comment">// 检查回调函数是否可以执行</span>
    <span class="keyword">if</span> (typeof <span class="keyword">callback</span> !== <span class="string">"function"</span>) {
        <span class="keyword">callback</span> = <span class="literal">false</span>;
    }
    <span class="keyword">while</span> (i) {
        i -= <span class="number">1</span>;

        <span class="comment">// 这里是复杂的逻辑……</span>

        <span class="comment">// 回调：</span>
        <span class="keyword">if</span> (<span class="keyword">callback</span>) {
            <span class="keyword">callback</span>(found);
        }

        nodes.push(found);
    }
    <span class="keyword">return</span> nodes;
};
</code></pre><p>这里的实现比较直接，<code>findNodes()</code>多作了一个额外工作，就是检查回调函数是否存在，如果存在的话就执行它。回调函数是可选的，因此修改后的<code>findNodes()</code>仍然可以和之前一样使用，是可以兼容旧代码和旧API的。</p>
<p>这时<code>hide()</code>的实现就非常简单了，因为它不用对元素列表做任何遍历了：</p>
<pre><code><span class="comment">// 回调函数</span>
<span class="keyword">var</span> hide = <span class="function"><span class="keyword">function</span> <span class="params">(node)</span> </span>{
    node.style.display = <span class="string">"none"</span>;
};

<span class="comment">// 找到节点并隐藏它们</span>
findNodes(hide);
</code></pre><p>回调函数可以是事先定义好的，像上面的代码一样，也可以是一个在调用函数时创建的匿名函数，比如这段代码，我们利用同样的通用函数<code>findNodes()</code>来完成显示元素的操作：</p>
<pre><code><span class="comment">// 传入匿名回调函数</span>
findNodes(<span class="function"><span class="keyword">function</span> <span class="params">(node)</span> </span>{
    node.style.display = <span class="string">"block"</span>;
});
</code></pre><h3 id="回调和作用域">回调和作用域</h3><p>在上一个例子中，执行回调函数的写法是：</p>
<pre><code>callback(<span class="section"><span class="keyword">parameters</span>);</span>
</code></pre><p>尽管这种写法很简单，而且可以适用于大多数的情况，但还有一些场景，回调函数不是匿名函数或者全局函数，而是对象的方法，如果这种情况下回调函数中使用了<code>this</code>指向它所属的对象，则回调逻辑就可能不是我们期望的那样。</p>
<p>假设回调函数是<code>paint()</code>，它是<code>myapp</code>的一个方法：</p>
<pre><code>var myapp = {};
myapp.<span class="built_in">color</span> = <span class="string">"green"</span>;
myapp.paint = <span class="function"><span class="keyword">function</span> <span class="params">(node)</span> {</span>
    node.style.<span class="built_in">color</span> = this.<span class="built_in">color</span>;
};
</code></pre><p>函数findNodes()大致如下：</p>
<pre><code><span class="keyword">var</span> findNodes = <span class="function"><span class="keyword">function</span> <span class="params">(callback)</span> </span>{
    <span class="comment">// ...</span>
    <span class="keyword">if</span> (typeof <span class="keyword">callback</span> === <span class="string">"function"</span>) {
        <span class="keyword">callback</span>(found);
    }
    <span class="comment">// ...</span>
};
</code></pre><p>当你调用<code>findNodes(myapp.paint)</code>时，运行结果和我们期望的不一致，因为<code>this.color</code>未定义。这时候<code>this</code>指向的是全局对象，因为<code>findNodes()</code>是全局函数。如果<code>findNodes()</code>是dom对象的方法（类似<code>dom.findNodes()</code>），那么回调函数内的<code>this</code>指向该dom，而不是<code>myapp</code>。</p>
<p>解决办法是，除了传入回调函数，还需将回调函数所属的对象当作参数传进去：</p>
<pre><code>findNodes<span class="list">(<span class="keyword">myapp</span>.paint, myapp)</span><span class="comment">;</span>
</code></pre><p>同样需要修改<code>findNodes()</code>的逻辑，增加对传入的对象的绑定：</p>
<pre><code><span class="keyword">var</span> findNodes = <span class="function"><span class="keyword">function</span> <span class="params">(callback, callback_obj)</span> </span>{
    <span class="comment">//...</span>
    <span class="keyword">if</span> (typeof <span class="keyword">callback</span> === <span class="string">"function"</span>) {
        <span class="keyword">callback</span>.call(callback_obj, found);
    }
    <span class="comment">// ...</span>
};
</code></pre><p>在后续的章节会对<code>call()</code>和<code>apply()</code>有更详细的讲述。</p>
<p>其实还有一种替代写法，就是将函数名称以字符串传入<code>findNodes()</code>，这样就不必再写一次对象了，也就是说：</p>
<pre><code>findNodes<span class="list">(<span class="keyword">myapp</span>.paint, myapp)</span><span class="comment">;</span>
</code></pre><p>可以写成：</p>
<pre><code>findNodes<span class="list">(<span class="string">"paint"</span>, myapp)</span><span class="comment">;</span>
</code></pre><p>在<code>findNodes()</code>中的逻辑则需要修改为：</p>
<pre><code><span class="keyword">var</span> findNodes = <span class="function"><span class="keyword">function</span> <span class="params">(callback, callback_obj)</span> </span>{

    <span class="keyword">if</span> (typeof <span class="keyword">callback</span> === <span class="string">"string"</span>) {
        <span class="keyword">callback</span> = callback_obj[<span class="keyword">callback</span>];
    }

    <span class="comment">//...</span>
    <span class="keyword">if</span> (typeof <span class="keyword">callback</span> === <span class="string">"function"</span>) {
        <span class="keyword">callback</span>.call(callback_obj, found);
    }
    <span class="comment">// ...</span>
};
</code></pre><h3 id="异步事件监听">异步事件监听</h3><p>JavaScript中的回调模式已经是我们的家常便饭了，比如，如果你给网页中的元素绑定事件，则需要提供回调函数的引用，以便事件发生时能调用到它。这里有一个简单的例子，我们将<code>console.log()</code>作为回调函数绑定到了<code>document</code>的点击事件上：</p>
<pre><code><span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>, <span class="built_in">console</span>.log, <span class="literal">false</span>);
</code></pre><p>客户端浏览器中的大多数编程都是事件驱动的，当网页下载完成，则触发<code>load</code>事件，当用户和页面产生交互时也会触发多种事件，比如<code>click</code>、<code>keypress</code>、<code>mouseover</code>、<code>mousemove</code>等等。JavaScript天生适合事件驱动编程，因为回调模式能够让程序“异步”执行，换句话说，就是让程序不按顺序执行。</p>
<p>“不要打电话给我，我会打给你”，这是好莱坞很有名的一句台词，可能很多人会对同一个角色说这句话，而电影中的主角不可能同时应答这些人的电话呼叫。在JavaScript的异步事件模型中也是同样的道理，不同的是，电影中是留下电话号码，JavaScript中是提供一个在适当的时机被调用的回调函数。有时甚至可以提供比实际需要更多的回调函数，因为可能某个特定的事件永远不会发生。比如，假设用户一直不点击“购买”，那么你之前写的用来验证信用卡号格式的函数就永远不会被调用执行。（译注：这段话有点不好翻译，前面的比喻看不懂。后面有两个方面的意思，一方面指回调函数并不一定会被执行，如果事件不发生，那么回调函数就永远不会被执行；另一方面指可以通过多个事件来绑定同一个回调函数，因为你无法确定用户会触发哪一个事件，比如到底是键盘操作还是鼠标操作。）</p>
<h3 id="延时">延时</h3><p>另外一个最常用的回调模式是在调用延时函数的时候。延时函数是浏览器<code>window</code>对象的方法，共有两个：<code>setTimeout()</code>和<code>setInterval()</code>。这两个方法的参数都是回调函数。</p>
<pre><code><span class="keyword">var</span> thePlotThickens = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">'500ms later...'</span>);
};
setTimeout(thePlotThickens, <span class="number">500</span>);
</code></pre><p>再次提醒，函数名<code>thePlotThickens</code>是作为变量传入<code>setTimeout</code>的，它不带括号，如果带括号的话就被立即执行了，而这里只是用到这个函数的引用，以便在<code>setTimeout()</code>的逻辑中调用它。也可以传入字符串<code>&quot;thePlotThickens()&quot;</code>，但这是一种反模式，和<code>eval()</code>一样不推荐使用。</p>
<h3 id="类库中的回调">类库中的回调</h3><p>回调模式非常简单，但又很强大，可以信手拈来灵活运用，因此这种模式在类库的设计中也非常得宠。类库的代码要尽可能保持通用和可复用，而回调模式则可帮助库的作者达成这个目标。你不必预料并实现你所想到的所有情形，这会让类库变得臃肿，而且大多数用户并不需要这些多余的特性支持。相反，你将精力放在核心功能的实现上，提供回调的入口作为“钩子”，可以让类库的方法变得可扩展、可定制。</p>
<h2 id="返回函数">返回函数</h2><p>函数是对象，因此可以作为返回值。也就是说，函数不一定非要返回一坨数据，函数也可以返回另外一个函数，或者可以根据输入的不同按需创造另外一个函数。</p>
<p>这里有一个简单的例子：一个函数完成了某种功能，可能是一次性初始化，然后做了一些对返回值的操作，而这个返回值恰巧是另一个函数：</p>
<pre><code><span class="keyword">var</span> setup = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    alert(<span class="number">1</span>);
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        alert(<span class="number">2</span>);
    };
};

<span class="comment">// 使用setup()函数</span>
<span class="keyword">var</span> my = setup(); <span class="comment">// alerts 1</span>
my(); <span class="comment">// alerts 2</span>
</code></pre><p>因为<code>setup()</code>包裹了返回的函数，因此它创建了一个闭包，我们可以用这个闭包来存储一些私有数据，这些私有数据可以通过返回的函数进行操作，但在函数外部不能直接读取到这些私有数据。比如这个例子中提供了一个计数器，每次调用这个函数时，计数器都会加一：</p>
<pre><code><span class="keyword">var</span> setup = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="keyword">var</span> count = <span class="number">0</span>;
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        <span class="keyword">return</span> (count += <span class="number">1</span>);
    };
};

<span class="comment">// 使用</span>
<span class="keyword">var</span> next = setup();
next(); <span class="comment">// 返回 1</span>
next(); <span class="comment">// 2</span>
next(); <span class="comment">// 3</span>
</code></pre><h2 id="重定义函数">重定义函数</h2><p>函数可以被动态定义，也可以被赋值给变量。如果将你定义的函数赋值给已经存在的函数变量的话，则新函数会覆盖旧函数。这样做的结果是，旧函数的引用被丢弃掉，变量中所存储的引用值替换成了新的函数。这样看起来这个变量指代的函数逻辑就发生了变化，或者说函数进行了“重新定义”或“重写”。听起来很麻烦，但实际上并不复杂，来看一个例子：</p>
<pre><code><span class="keyword">var</span> scareMe = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    alert(<span class="string">"Boo!"</span>);
    scareMe = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        alert(<span class="string">"Double boo!"</span>);
    };
};
<span class="comment">// 使用重定义函数</span>
scareMe(); <span class="comment">// Boo!</span>
scareMe(); <span class="comment">// Double boo!</span>
</code></pre><p>当函数中包含一些初始化操作，并希望这些初始化操作只执行一次，那么这种模式是非常合适的，因为我们要避免重复执行不需要的代码。在这个场景中，函数执行一次后就被重写为另外一个函数了。</p>
<p>使用这种模式可以帮助提高应用的执行效率，因为重新定义的函数执行的代码量更少。</p>
<blockquote>
<p>这种模式的另外一个名字是“函数的懒惰定义”，因为直到函数执行一次后才重新定义，可以说它是“某个时间点之后才存在”，简称“懒惰定义”。</p>
</blockquote>
<p>这种模式有一个明显的缺陷，就是之前给原函数添加的功能在重定义之后都丢失了。同时，如果这个函数被重定义为不同的名字，被赋值给不同的变量，或者是作为对象的方法使用，那么重定义的部分并不会生效，原来的函数依然会被执行。</p>
<p>让我们来看一个例子，<code>scareMe()</code>函数在这里作为一等对象来使用：</p>
<ol>
<li>给他增加了一个属性</li>
<li>函数对象被赋值给一个新变量</li>
<li>函数还被作为方法来调用</li>
</ol>
<p>看一下这段代码：</p>
<pre><code><span class="comment">// 1. 添加一个新属性</span>
scareMe.property = <span class="string">"properly"</span>;

<span class="comment">// 2. 被赋值给一个不同名的变量</span>
<span class="keyword">var</span> prank = scareMe;

<span class="comment">// 3. 作为方法使用</span>
<span class="keyword">var</span> spooky = {
    boo: scareMe
};

<span class="comment">// 使用新名字调用</span>
prank(); <span class="comment">// "Boo!"</span>
prank(); <span class="comment">// "Boo!"</span>
<span class="built_in">console</span>.log(prank.property); <span class="comment">// "properly"</span>

<span class="comment">// 作为方法调用</span>
spooky.boo(); <span class="comment">// "Boo!"</span>
spooky.boo(); <span class="comment">// "Boo!"</span>
<span class="built_in">console</span>.log(spooky.boo.property);    <span class="comment">// "properly"</span>

<span class="comment">// 使用重定义函数</span>
scareMe(); <span class="comment">// Double boo!</span>
scareMe(); <span class="comment">// Double boo!</span>
<span class="built_in">console</span>.log(scareMe.property); <span class="comment">// undefined</span>
</code></pre><p>从结果来看，当重定义函数被赋值给一个新的变量的时候，这段使用重定义函数的代码的执行结果与我们期望的结果可能并不一样。每当<code>prank()</code>被调用的时候，它都弹出“Boo!”。同时它也重写了<code>scareMe()</code>函数，但是<code>prank()</code>自己仍然能够使用之前的定义，包括属性<code>property</code>。在这个函数被作为<code>spooky</code>对象的<code>boo()</code>方法调用的时候，结果也一样。所有的这些调用，在第一次的时候就已经修改了全局的<code>scareMe()</code>的指向，所以当它最终被调用的时候，它的函数体已经被修改为弹出“Double boo”，也就不能获取到新添加的属性<code>scareMe.property</code>。</p>
<h2 id="即时函数">即时函数</h2><p>即时函数是一种语法模式，它会使函数在定义后立即执行。看这个例子：</p>
<pre><code><span class="list">(<span class="keyword">function</span> <span class="list">()</span> <span class="collection">{
    alert<span class="list">(<span class="keyword">'watch</span> out!')</span><span class="comment">;</span>
}</span><span class="list">()</span>)</span><span class="comment">;</span>
</code></pre><p>这种模式本质上只是一个在创建后就被执行的函数表达式（具名或者匿名）。“即时函数”这种说法并没有在ECMAScript标准中被定义，但它作为一个名词，有助于我们的描述和讨论。</p>
<p>这种模式由以下几个部分组成：</p>
<ul>
<li>使用函数表达式定义一个函数。（不能使用函数声明。）</li>
<li>在最后加入一对括号，这会使函数立即被执行。</li>
<li>把整个函数包裹到一对括号中（只在没有将函数赋值给变量时需要）。</li>
</ul>
<p>下面这种语法也很常见（注意右括号的位置），但是JSLint倾向于第一种：</p>
<pre><code><span class="list">(<span class="keyword">function</span> <span class="list">()</span> <span class="collection">{
    alert<span class="list">(<span class="keyword">'watch</span> out!')</span><span class="comment">;</span>
}</span>)</span><span class="list">()</span><span class="comment">;</span>
</code></pre><p>这种模式很有用，它为我们提供一个作用域的沙箱，可以在执行一些初始化代码的时候使用。设想这样的场景：当页面加载的时候，你需要运行一些代码，比如绑定事件、创建对象等等。所有的这些代码都只需要运行一次，所以没有必要创建一个带有名字的函数。但是这些代码需要一些临时变量，而这些变量在初始化完之后又不会再次被用到。显然，把这些变量作为全局变量声明是不合适的。正因为如此，我们才需要即时函数。它可以把你所有的代码包裹到一个作用域里面，而不会暴露任何变量到全局作用域中：</p>
<pre><code><span class="list">(<span class="keyword">function</span> <span class="list">()</span> {

    var days = [<span class="quoted">'Sun</span>', <span class="quoted">'Mon</span>', <span class="quoted">'Tue</span>', <span class="quoted">'Wed</span>', <span class="quoted">'Thu</span>', <span class="quoted">'Fri</span>', <span class="quoted">'Sat</span>'],
        today = new Date<span class="list">()</span>,
        msg = <span class="quoted">'Today</span> is ' + days[today.getDay<span class="list">()</span>] + ', ' + today.getDate<span class="list">()</span><span class="comment">;</span>

    alert<span class="list">(<span class="keyword">msg</span>)</span><span class="comment">;</span>

}<span class="list">()</span>)</span><span class="comment">; // "Today is Fri, 13"</span>
</code></pre><p>如果这段代码没有被包裹到立即执行函数中，那么变量<code>days</code>、<code>today</code>、<code>msg</code>都会是全局变量，而这些变量仅仅是因为初始化而遗留下来的垃圾，没有任何用处。</p>
<h3 id="即时函数的参数">即时函数的参数</h3><p>即时函数也可以接受参数，看这个例子：</p>
<pre><code><span class="comment">// 打印出：</span>
<span class="comment">// I met Joe Black on Fri Aug 13 2010 23:26:59 GMT-0800 (PST)</span>

(<span class="function"><span class="keyword">function</span> (<span class="params">who, when</span>) </span>{

    <span class="built_in">console</span>.log(<span class="string">"I met "</span> + who + <span class="string">" on "</span> + when);

}(<span class="string">"Joe Black"</span>, <span class="keyword">new</span> <span class="built_in">Date</span>()));
</code></pre><p>通常我们会把全局对象当作一个参数传给即时函数，以保证在函数内部也可以访问到全局对象，而不是使用<code>window</code>对象，这样可以使得代码在非浏览器环境中使用时更具可移植性。</p>
<p>值得注意的是，一般情况下尽量不要给即时函数传入太多的参数，否则会有一件麻烦的事情，就是你在阅读代码的时候需要频繁地上下滚动代码。</p>
<h3 id="即时函数的返回值">即时函数的返回值</h3><p>和其它的函数一样，即时函数也可以返回值，并且这些返回值也可以被赋值给变量：</p>
<pre><code><span class="keyword">var</span> <span class="literal">result</span> = (function () {
    <span class="keyword">return</span> <span class="number">2</span> + <span class="number">2</span>;
}());
</code></pre><p>如果省略括号的话也可以达到同样的目的，因为如果需要将返回值赋给变量，那么第一对括号就不是必需的。省略括号的代码是这样子：</p>
<pre><code><span class="keyword">var</span> <span class="literal">result</span> = function () {
    <span class="keyword">return</span> <span class="number">2</span> + <span class="number">2</span>;
}();
</code></pre><p>这种写法更简洁，但是同时也容易造成误解。如果有人在阅读代码的时候忽略了最后的一对括号，那么他会以为<code>result</code>指向了一个函数。而事实上<code>result</code>是指向这个函数运行后的返回值，在这个例子中是4。</p>
<p>还有一种写法也可以得到同样的结果：</p>
<pre><code><span class="keyword">var</span> <span class="literal">result</span> = (function () {
    <span class="keyword">return</span> <span class="number">2</span> + <span class="number">2</span>;
})();
</code></pre><p>前面的例子中，即时函数返回的是一个基本类型的数值。但事实上，一个即时函数可以返回任意类型的值，甚至返回一个函数都可以。你可以利用即时函数的作用域来存储一些私有的数据，这些数据只能在返回的内层函数中被访问。</p>
<p>在下面的例子中，即时函数的返回值是一个函数，这个函数会简单地返回<code>res</code>的值，并且这个值被赋给了变量<code>getResult</code>。而<code>res</code>是一个预先计算好的变量，它被存储在即时函数的闭包中：</p>
<pre><code><span class="keyword">var</span> getResult = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="keyword">var</span> res = <span class="number">2</span> + <span class="number">2</span>;
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        <span class="keyword">return</span> res;
    };
}());
</code></pre><p>在定义一个对象属性的时候也可以使用即时函数。设想一下这样的场景：你需要定义一个对象的属性，这个属性在对象的生命周期中都不会改变，但是在定义之前，你需要做一些计算来得到它的值。这种情况下你就可以使用即时函数来包裹那些额外的计算工作，然后将它的返回值作为对象属性的值。下面是一个例子：</p>
<pre><code><span class="keyword">var</span> o = {
    message: (<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        <span class="keyword">var</span> who = <span class="string">"me"</span>,
            what = <span class="string">"call"</span>;
        <span class="keyword">return</span> what + <span class="string">" "</span> + who;
    }()),
    getMsg: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="keyword">this</span>.message;
    }
};

<span class="comment">// 使用对象</span>
o.getMsg(); <span class="comment">// "call me"</span>
o.message; <span class="comment">// "call me"</span>
</code></pre><p>在这个例子中，<code>o.message</code>是一个字符串，而不是一个函数，但是它需要一个函数在脚本载入后通过计算得到这个属性值。</p>
<h3 id="好处和用法">好处和用法</h3><p>即时函数应用很广泛。它可以帮助我们做一些不想留下全局变量的工作。所有定义的变量都只是即时函数的本地变量，你完全不用担心临时变量会污染全局对象。</p>
<blockquote>
<p>即时函数还有一些名字，比如“自调用函数”或者“自执行函数”，因为这些函数会在被定义后立即执行自己。</p>
</blockquote>
<p>这种模式也经常被用到书签代码中，因为书签代码有可能会运行在任何一个页面中，所以需要非常苛刻地保持全局命名空间干净。</p>
<p>这种模式也可以让你包裹一些独立的特性到一个封闭的模块中。设想你的页面是静态的，在没有JavaScript的时候工作正常，然后，本着渐进增强的精神，你给页面加入了一点增强代码。这时候，你就可以把你的代码（也可以叫“模块”或者“特性”）放到一个即时函数中并且保证页面在有没有它的时候都可以正常工作。然后你就可以加入更多的增强特性，或者对它们进行移除、进行独立测试或者允许用户禁用等等。</p>
<p>你可以使用下面的模板定义一段函数代码，我们叫它module1：</p>
<pre><code><span class="comment">// 在module1.js中定义module1</span>
(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{

    <span class="comment">// 所有module 1的代码……</span>

}());
</code></pre><p>你可以套用这个模板来编写其它的模块，然后在发布到线上的时候，再决定在这个时间节点上哪些特性是稳定可用的，然后使用发布脚本将它们打包上线。</p>
<h2 id="对象即时初始化">对象即时初始化</h2><p>还有另外一种可以避免污染全局作用域的方法，和前面描述的即时函数相似，叫做“对象即时初始化”模式。这种模式使用一个带有<code>init()</code>方法的对象来实现，这个方法在对象被创建后立即执行。初始化的工作由<code>init()</code>函数来完成。</p>
<p>下面是一个对象即时初始化模式的例子：</p>
<pre><code>({
    <span class="comment">// 这里可以定义一些设置项，比如常量</span>
    maxwidth: <span class="number">600</span>,
    maxheight: <span class="number">400</span>,

    <span class="comment">// 你也可以定义一些方法</span>
    gimmeMax: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
        <span class="keyword">return</span> <span class="keyword">this</span>.maxwidth + <span class="string">"x"</span> + <span class="keyword">this</span>.maxheight;
    },

    <span class="comment">// 初始化</span>
    init: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
        <span class="built_in">console</span>.log(<span class="keyword">this</span>.gimmeMax());
        <span class="comment">// 更多的初始化任务……</span>
    }
}).init();
</code></pre><p>在语法上，当你使用这种模式的时候就像在使用对象字面量创建一个普通对象一样。不同之处在于，需要将对象字面量用括号括起来，这样能让JavaScript引擎知道这是一个对象字面量，而不是一个代码块（<code>if</code>或者<code>for</code>循环之类）。在括号后面，紧接着就执行了<code>init()</code>方法。</p>
<p>你也可以将对象字面量和<code>init()</code>调用一起写到括号里面。简单地说，下面两种语法都是有效的：</p>
<pre><code>(<span class="decorator">{...}</span>).init();
(<span class="decorator">{...}</span>.init());
</code></pre><p>这种模式的好处和即时函数模式是一样的：在做一些一次性的初始化工作的时候保护全局作用域不被污染。从语法上看，这种模式似乎比即时函数要复杂一些，但是如果你的初始化工作比较复杂（这种情况很常见），它会给整个初始化工作一个比较清晰的结构。比如，一些私有的辅助性函数可以被很轻易地看出来，因为它们是这个临时对象的属性，但是如果是在即时函数模式中，它们很可能只是一些散落的函数。</p>
<p>这种模式的一个弊端是，JavaScript压缩工具可能不能像压缩一段包裹在函数中的代码一样有效地压缩这种模式的代码。这些私有的属性和方法不被会重命名为一些更短的名字，因为从压缩工具的角度来看，保证压缩的可靠性更重要。在写作本书的时候，Google出品的Closure Compiler的“advanced”模式是唯一会重命名立即初始化的对象的属性的压缩工具。一个压缩后的样例是这样：</p>
<pre><code>({d:<span class="number">600</span>,c:<span class="number">400</span>,a:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{<span class="keyword">return</span> <span class="keyword">this</span>.d+<span class="string">"x"</span>+<span class="keyword">this</span>.c},b:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{<span class="built_in">console</span>.log(<span class="keyword">this</span>.a())}}).b();
</code></pre><blockquote>
<p>这种模式主要用于一些一次性的工作，并且在<code>init()</code>方法执行完后就无法再次访问到这个对象。如果希望在这些工作完成后保持对对象的引用，只需要简单地在<code>init()</code>的末尾加上<code>return this;</code>即可。</p>
</blockquote>
<h2 id="条件初始化">条件初始化</h2><p>条件初始化（也叫条件加载）是一种优化模式。当你知道某种条件在整个程序生命周期中都不会变化的时候，那么对这个条件的探测只做一次就很有意义。浏览器探测（或者特征检测）是一个典型的例子。</p>
<p>举例说明，当你探测到<code>XMLHttpRequest</code>被作为一个本地对象支持时，就知道浏览器不会在程序执行过程中改变这一情况，也不会出现突然需要去处理ActiveX对象的情况。当环境不发生变化的时候，你的代码就没有必要在需要在每次初始化XHR对象时探测一遍（并且得到同样的结果）。</p>
<p>另外一些可以从条件初始化中获益的场景是获得一个DOM元素的computed styles或者是绑定事件处理函数。大部分程序员在他们的编程生涯中都编写过事件绑定和取消绑定相关的组件，像下面的例子：</p>
<pre><code><span class="comment">// 优化前的代码</span>
<span class="keyword">var</span> utils = {
    addListener: <span class="function"><span class="keyword">function</span> (<span class="params">el, <span class="keyword">type</span>, fn</span>) </span>{
        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.addEventListener === <span class="string">'function'</span>) {
            el.addEventListener(<span class="keyword">type</span>, fn, <span class="literal">false</span>);
        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">document</span>.attachEvent === <span class="string">'function'</span>) { <span class="comment">// IE</span>
            el.attachEvent(<span class="string">'on'</span> + <span class="keyword">type</span>, fn);
        } <span class="keyword">else</span> { <span class="comment">// 老的浏览器</span>
            el[<span class="string">'on'</span> + <span class="keyword">type</span>] = fn;
        }
    },
    removeListener: <span class="function"><span class="keyword">function</span> (<span class="params">el, <span class="keyword">type</span>, fn</span>) </span>{
        <span class="comment">// 和上面很类似的代码……</span>
    }
};
</code></pre><p>这段代码的问题就是效率不高。每当你执行<code>utils.addListener()</code>或者<code>utils.removeListener()</code>时，同样的检查都会被重复执行。</p>
<p>如果使用条件初始化，那么浏览器探测的工作只需要在初始化代码的时候执行一次。在初始化的时候，代码探测一次环境，然后重新定义这个函数在剩下来的程序生命周期中应该怎样工作。下面是一个例子，看看如何达到这个目的：</p>
<pre><code><span class="comment">// 优化后的代码</span>

<span class="comment">// 接口</span>
var utils = {
    addListener: <span class="keyword">null</span>,
    removeListener: <span class="keyword">null</span>
};

<span class="comment">// 实现</span>
<span class="keyword">if</span> (typeof window.addEventListener === '<span class="keyword">function</span>') {
    utils.addListener = <span class="keyword">function</span> (el, <span class="class"><span class="keyword">type</span>, <span class="title">fn</span>) {</span>
        el.addEventListener(<span class="class"><span class="keyword">type</span>, <span class="title">fn</span>, <span class="title">false</span>);</span>
    };
    utils.removeListener = <span class="keyword">function</span> (el, <span class="class"><span class="keyword">type</span>, <span class="title">fn</span>) {</span>
        el.removeEventListener(<span class="class"><span class="keyword">type</span>, <span class="title">fn</span>, <span class="title">false</span>);</span>
    };
} <span class="keyword">else</span> <span class="keyword">if</span> (typeof document.attachEvent === '<span class="keyword">function</span>') { <span class="comment">// IE</span>
    utils.addListener = <span class="keyword">function</span> (el, <span class="class"><span class="keyword">type</span>, <span class="title">fn</span>) {</span>
        el.attachEvent('on' + <span class="class"><span class="keyword">type</span>, <span class="title">fn</span>);</span>
    };
    utils.removeListener = <span class="keyword">function</span> (el, <span class="class"><span class="keyword">type</span>, <span class="title">fn</span>) {</span>
        el.detachEvent('on' + <span class="class"><span class="keyword">type</span>, <span class="title">fn</span>);</span>
    };
} <span class="keyword">else</span> { <span class="comment">// older browsers</span>
    utils.addListener = <span class="keyword">function</span> (el, <span class="class"><span class="keyword">type</span>, <span class="title">fn</span>) {</span>
        el['on' + <span class="class"><span class="keyword">type</span>] </span>= fn;
    };
    utils.removeListener = <span class="keyword">function</span> (el, <span class="class"><span class="keyword">type</span>, <span class="title">fn</span>) {</span>
        el['on' + <span class="class"><span class="keyword">type</span>] </span>= <span class="keyword">null</span>;
    };
}
</code></pre><p>说到这里，要特别提醒一下关于浏览器探测的事情。当你使用这个模式的时候，不要对浏览器特性过度假设。举个例子，如果你探测到浏览器不支持<code>window.addEventListener</code>时，不要假设这个浏览器是IE，也不要认为它不支持原生的<code>XMLHttpRequest</code>，虽然这个结论在整个浏览器历史上的某个时间点是正确的。当然，也有一些情况是可以放心地做一些特性假设的，比如<code>.addEventListener</code>和<code>.removeEventListerner</code>，但是通常来讲，浏览器的特性在发生变化时都是独立的。最好的策略就是分别探测每个特性，然后使用条件初始化，使这种探测只做一次。</p>
<h2 id="函数属性——记忆模式（Memoization）">函数属性——记忆模式（Memoization）</h2><p>函数也是对象，所以它们可以有属性。事实上，函数也确实本来就有一些属性。比如，对一个函数来说，不管是用什么语法创建的，它会自动拥有一个<code>length</code>属性来标识这个函数期待接受的参数个数：</p>
<pre><code>function <span class="function"><span class="keyword">func</span><span class="params">(a, b, c)</span> {}</span>
console.<span class="built_in">log</span>(<span class="function"><span class="keyword">func</span>.<span class="title">length</span>); // 3</span>
</code></pre><p>任何时候都可以给函数添加自定义属性。添加自定义属性的一个有用场景是缓存函数的执行结果（返回值），这样下次同样的函数被调用的时候就不需要再做一次那些可能很复杂的计算。缓存一个函数的运行结果也就是为大家所熟知的记忆模式。</p>
<p>在下面的例子中，<code>myFunc</code>函数创建了一个<code>cache</code>属性，可以通过<code>myFunc.cache</code>访问到。这个<code>cache</code>属性是一个对象（hash表），传给函数的参数会作为对象的key，函数执行结果会作为对象的值。函数的执行结果可以是任何的复杂数据结构：</p>
<pre><code><span class="keyword">var</span> myFunc = function (param) {
    <span class="keyword">if</span> (!myFunc.cache[param]) {
        <span class="keyword">var</span> <span class="literal">result</span> = {};
        // ……复杂的计算……
        myFunc.cache[param] = <span class="literal">result</span>;
    }
    <span class="keyword">return</span> myFunc.cache[param];
};

// 缓存
myFunc.cache = {};
</code></pre><p>上面的代码假设函数只接受一个参数<code>param</code>，并且这个参数是原始类型（比如字符串）。如果你有更多更复杂的参数，则通常需要对它们进行序列化。比如，你需要将<code>arguments</code>对象序列化为JSON字符串，然后使用JSON字符串作为<code>cache</code>对象的key：</p>
<pre><code><span class="keyword">var</span> myFunc = function () {

    <span class="keyword">var</span> cachekey = <span class="type">JSON</span>.stringify(<span class="type">Array</span>.prototype.slice.call(arguments)),
        <span class="literal">result</span>;

    <span class="keyword">if</span> (!myFunc.cache[cachekey]) {
        <span class="literal">result</span> = {};
        // ……复杂的计算……
        myFunc.cache[cachekey] = <span class="literal">result</span>;
    }
    <span class="keyword">return</span> myFunc.cache[cachekey];
};

// 缓存
myFunc.cache = {};
</code></pre><p>需要注意的是，在序列化的过程中，对象的“标识”将会丢失。如果你有两个不同的对象，却碰巧有相同的属性，那么他们会共享同样的缓存内容。</p>
<p>前面代码中的函数名还可以使用<code>arguments.callee</code>来替代，这样就不用将函数名硬编码。不过尽管现阶段这个办法可行，但是仍然需要注意，<code>arguments.callee</code>在ECMAScript5的严格模式中是不被允许的：</p>
<pre><code><span class="keyword">var</span> myFunc = function (param) {

    <span class="keyword">var</span> f = arguments.callee,
        <span class="literal">result</span>;

    <span class="keyword">if</span> (!f.cache[param]) {
        <span class="literal">result</span> = {};
        // ……复杂的计算……
        f.cache[param] = <span class="literal">result</span>;
    }
    <span class="keyword">return</span> f.cache[param];
};

// 缓存
myFunc.cache = {};
</code></pre><h2 id="配置对象">配置对象</h2><p>配置对象模式是一种为自己的代码提供更简洁的API的方法，如果你正在写一个即将被其它程序调用的类库之类的代码的时候就特别有用。</p>
<p>软件在开发和维护过程中需要不断改变是一个不争的事实。这样的事情总是以一些有限的需求开始，但是随着开发的进行，越来越多的功能会不断被加进来。</p>
<p>设想一下你正在写一个名为<code>addPerson()</code>的函数，它接受一个姓和一个名，然后在列表中加入一个人：</p>
<pre><code>function addPerson(first, last) <span class="decorator">{...}</span>
</code></pre><p>然后你意识到，生日也必须要存储，此外，性别和地址也作为可选项存储。所以你修改了函数，添加了一些新的参数（还得非常小心地将可选参数放到最后）：</p>
<pre><code>function addPerson(first, last, dob, gender, address) <span class="decorator">{...}</span>
</code></pre><p>这个时候，函数已经显得有点长了。然后，你又被告知需要添加一个用户名，并且不是可选的。现在这个函数的调用者需要将所有的可选参数传进来，并且得非常小心地保证不弄混参数的顺序：</p>
<pre><code>addPerson(<span class="string">"Bruce"</span>, <span class="string">"Wayne"</span>, <span class="keyword">new</span> <span class="built_in">Date</span>(), <span class="literal">null</span>, <span class="literal">null</span>, <span class="string">"batman"</span>);
</code></pre><p>这样传一大串的参数真的很不方便。一个更好的办法就是将它们替换成一个参数对象，我们叫它<code>conf</code>，是“configuration”（配置）的缩写：</p>
<pre><code>addPerson<span class="list">(<span class="keyword">conf</span>)</span><span class="comment">;</span>
</code></pre><p>然后这个函数的使用者就可以这样：</p>
<pre><code><span class="keyword">var</span> <span class="keyword">conf</span> = {
    username: <span class="string">"batman"</span>,
    first: <span class="string">"Bruce"</span>,
    last: <span class="string">"Wayne"</span>
};
addPerson(<span class="keyword">conf</span>);
</code></pre><p>配置对象模式的好处是：</p>
<ul>
<li>不需要记住参数的顺序</li>
<li>可以很安全地跳过可选参数</li>
<li>拥有更好的可读性和可维护性</li>
<li>更容易添加和移除参数</li>
</ul>
<p>配置对象模式的坏处是：</p>
<ul>
<li>需要记住参数的名字</li>
<li>参数名字不能被压缩</li>
</ul>
<p>在实践中，这个模式对创建DOM元素的函数或者是给元素设定CSS样式的函数会非常实用，因为元素和CSS样式可能会有很多属性，但是大部分属性是可选的。</p>
<h2 id="柯里化_（Curry）">柯里化 （Curry）</h2><p>在本章剩下的部分，我们将讨论一下关于柯里化和部分应用的话题。但是在我们开始这个话题之前，先看一下什么是函数应用。</p>
<h3 id="函数应用">函数应用</h3><p>在一些纯粹的函数式编程语言中，对函数的描述不是被调用（<code>called</code>或者<code>invoked</code>），而是被应用（<code>applied</code>）。在JavaScript中也有同样的东西——我们可以使用<code>Function.prototype.apply()</code>来应用一个函数，因为在JavaScript中，函数实际上是对象，并且他们拥有方法。</p>
<p>下面是一个函数应用的例子：</p>
<pre><code><span class="comment">// 定义函数</span>
<span class="keyword">var</span> sayHi = <span class="function"><span class="keyword">function</span> <span class="params">(who)</span> </span>{
    <span class="keyword">return</span> <span class="string">"Hello"</span> + (who ? <span class="string">", "</span> + who : <span class="string">""</span>) + <span class="string">"!"</span>;
};

<span class="comment">// 调用函数</span>
sayHi(); <span class="comment">// "Hello"</span>
sayHi(<span class="string">'world'</span>); <span class="comment">// "Hello, world!"</span>

<span class="comment">// 应用函数</span>
sayHi.apply(<span class="literal">null</span>, [<span class="string">"hello"</span>]); <span class="comment">// "Hello, hello!"</span>
</code></pre><p>从上面的例子中可以看出来，调用一个函数和应用一个函数有相同的结果。<code>apply()</code>接受两个参数：第一个是在函数内部绑定到<code>this</code>上的对象，第二个是一个参数数组，参数数组会在函数内部变成一个类似数组的<code>arguments</code>对象。如果第一个参数为<code>null</code>，那么<code>this</code>将指向全局对象，这正是当你调用一个函数（且这个函数不是某个对象的方法）时发生的事情。</p>
<p>当一个函数是一个对象的方法时，我们不再像前面的例子一样传入<code>null</code>。（译注：主要是为了保证方法中的<code>this</code>绑定到一个有效的对象而不是全局对象。）在下面的例子中，对象被作为第一个参数传给<code>apply()</code>：</p>
<pre><code><span class="keyword">var</span> alien = {
    sayHi: <span class="function"><span class="keyword">function</span> <span class="params">(who)</span> </span>{
        <span class="keyword">return</span> <span class="string">"Hello"</span> + (who ? <span class="string">", "</span> + who : <span class="string">""</span>) + <span class="string">"!"</span>;
    }
};

alien.sayHi(<span class="string">'world'</span>); <span class="comment">// "Hello, world!"</span>
sayHi.apply(alien, [<span class="string">"humans"</span>]); <span class="comment">// "Hello, humans!"</span>
</code></pre><p>在这个例子中，<code>sayHi()</code>中的<code>this</code>指向<code>alien</code>。而在上一个例子中，<code>this</code>是指向的全局对象。（译注：这个例子的代码有误，最后一行的<code>sayHi</code>并不能访问到<code>alien</code>的<code>sayHi</code>方法，需要使用<code>alien.sayHi.apply(alien, [&quot;humans&quot;])</code>才可正确运行。另外，在<code>sayHi</code>中也没有出现<code>this</code>。）</p>
<p>正如上面两个例子所展现出来的一样，我们将所谓的函数调用当作函数应用的一种语法糖来理解也没有什么太大的问题。</p>
<p>需要注意的是，除了<code>apply()</code>之外，<code>Function.prototype</code>对象还有一个<code>call()</code>方法，但是它仍然只是<code>apply()</code>的一种语法糖。（译注：这两个方法的区别在于，<code>apply()</code>只接受两个参数，第二个参数为需要传给函数的参数数组，而<code>call()</code>则接受任意多个参数，从第二个开始将参数依次传给函数。）不过有种情况下使用这个语法糖会更好：当你的函数只接受一个参数的时候，你可以省去为唯一的一个元素创建数组的工作：</p>
<pre><code><span class="comment">// 第二种更高效，因为节省了一个数组</span>
sayHi.apply(alien, [<span class="string">"humans"</span>]); <span class="comment">// "Hello, humans!"</span>
sayHi.<span class="keyword">call</span>(alien, <span class="string">"humans"</span>); <span class="comment">// "Hello, humans!"</span>
</code></pre><h3 id="部分应用">部分应用</h3><p>现在我们知道了，调用一个函数实际上就是给它应用一堆参数，那是否能够只传一部分参数而不传全部呢？这实际上跟我们手工处理数学函数非常类似。</p>
<p>假设已经有了一个<code>add()</code>函数，它的工作是把<code>x</code>和<code>y</code>两个数加到一起。下面的代码片段展示了当<code>x</code>为5、<code>y</code>为4时的计算步骤：</p>
<pre><code><span class="comment">// 并不是合法的JavaScript代码，仅用于演示</span>

<span class="comment">// 假设有一个add()函数</span>
<span class="function">function <span class="title">add</span><span class="params">(x, y)</span> </span>{
    <span class="keyword">return</span> x + y;
}

<span class="comment">// 给定参数</span>
add(<span class="number">5</span>, <span class="number">4</span>);

<span class="comment">// 第一步 传入一个参数</span>
<span class="function">function <span class="title">add</span><span class="params">(<span class="number">5</span>, y)</span> </span>{
    <span class="keyword">return</span> <span class="number">5</span> + y;
}

<span class="comment">// 第二步 传入另一个参数</span>
<span class="function">function <span class="title">add</span><span class="params">(<span class="number">5</span>, <span class="number">4</span>)</span> </span>{
    <span class="keyword">return</span> <span class="number">5</span> + <span class="number">4</span>;
}
</code></pre><p>在这个代码片段中，第一步和第二步并不是有效的JavaScript代码，但是它展示了我们手工计算的过程。首先获得第一个参数的值，然后在函数中将未知的<code>x</code>值替换为5。然后重复这个过程，直到替换掉所有的参数。</p>
<p>第一步是一个所谓的部分应用的例子：我们只应用了第一个参数。当你执行一个部分应用的时候并不能获得结果（或者是解决方案），取而代之的是另一个函数。</p>
<p>下面的代码片段展示了一个虚拟的<code>partialApply()</code>方法的用法：</p>
<pre><code><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> <span class="params">(x, y)</span> </span>{
    <span class="keyword">return</span> x + y;
};

<span class="comment">// 完整应用</span>
add.apply(<span class="literal">null</span>, [<span class="number">5</span>, <span class="number">4</span>]); <span class="comment">// 9</span>

<span class="comment">// 部分应用</span>
<span class="keyword">var</span> newadd = add.partialApply(<span class="literal">null</span>, [<span class="number">5</span>]);
<span class="comment">// 为新函数传入一个参数</span>
newadd.apply(<span class="literal">null</span>, [<span class="number">4</span>]); <span class="comment">// 9</span>
</code></pre><p>正如你所看到的一样，部分应用给了我们另一个函数，这个函数可以在稍后调用的时候接受其它的参数。这实际上跟<code>add(5)(4)</code>是等价的，因为<code>add(5)</code>返回了一个函数，这个函数可以使用<code>(4)</code>来调用。我们又一次看到，熟悉的<code>add(5, 4)</code>也差不多是<code>add(5)(4)</code>的一种语法糖。</p>
<p>现在，让我们回到地球：并不存在这样的一个<code>partialApply()</code>函数，并且函数的默认表现也不会像上面的例子中那样。但是你完全可以自己去写，因为JavaScript的动态特性完全可以做到这样。</p>
<p>让函数理解并且处理部分应用的过程，叫柯里化（Currying）。</p>
<h3 id="柯里化（Currying）">柯里化（Currying）</h3><p>柯里化这个名字来自数学家Haskell Curry。（Haskell编程语言也是因他而得名。）柯里化是一个变换函数的过程。柯里化的另外一个名字也叫schönfinkelisation，来自另一位数学家——Moses Schönfinkelisation——这种变换的最初发明者。</p>
<p>所以我们怎样对一个函数进行柯里化呢？其它的函数式编程语言也许已经原生提供了支持并且所有的函数已经默认柯里化了。在JavaScript中我们可以修改一下<code>add()</code>函数使它柯里化，然后支持部分应用。</p>
<p>来看一个例子：</p>
<pre><code><span class="comment">// 柯里化过的add()方法，可以接受部分参数</span>
<span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(x, y)</span> </span>{
    <span class="keyword">var</span> oldx = x, oldy = y;
    <span class="keyword">if</span> (<span class="keyword">typeof</span> oldy === <span class="string">"undefined"</span>) { <span class="comment">// 部分应用</span>
        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(newy)</span> </span>{
            <span class="keyword">return</span> oldx + newy;
        };
    }
    <span class="comment">// 完整应用</span>
    <span class="keyword">return</span> x + y;
}

<span class="comment">// 测试</span>
<span class="keyword">typeof</span> add(<span class="number">5</span>); <span class="comment">// "function"</span>
add(<span class="number">3</span>)(<span class="number">4</span>); <span class="comment">// 7</span>

<span class="comment">// 创建并保存函数</span>
<span class="keyword">var</span> add2000 = add(<span class="number">2000</span>);
add2000(<span class="number">10</span>); <span class="comment">// 2010</span>
</code></pre><p>在这段代码中，第一次调用<code>add()</code>时，在返回的内层函数那里创建了一个闭包。这个闭包将原来的<code>x</code>和<code>y</code>的值存储到了<code>oldx</code>和<code>oldy</code>中。当内层函数执行的时候，<code>oldx</code>会被使用。如果没有部分应用，即<code>x</code>和<code>y</code>都传了值，那么这个函数会简单地将他们相加。这个<code>add()</code>函数的实现显得有些冗余，仅仅是为了更好地说明问题。下面的代码片段中展示了一个更简洁的版本，没有<code>oldx</code>和<code>oldy</code>，因为原始的<code>x</code>已经被存储到了闭包中，此外我们复用了<code>y</code>作为本地变量，而不用像之前那样新定义一个变量<code>newy</code>：</p>
<pre><code><span class="comment">// 柯里化过的add()方法，可以接受部分参数</span>
<span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(x, y)</span> </span>{
    <span class="keyword">if</span> (<span class="keyword">typeof</span> y === <span class="string">"undefined"</span>) { <span class="comment">// 部分应用</span>
        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(y)</span> </span>{
            <span class="keyword">return</span> x + y;
        };
    }
    <span class="comment">// 完整应用</span>
    <span class="keyword">return</span> x + y;
}
</code></pre><p>在这些例子中，<code>add()</code>函数自己处理了部分应用。有没有可能用一种更为通用的方式来做同样的事情呢？换句话说，我们能不能对任意一个函数进行处理，得到一个新函数，使它可以处理部分参数？下面的代码片段展示了一个通用函数的例子，我们叫它<code>schonfinkelize()</code>，它正是用来做这个的。我们使用<code>schonfinkelize()</code>这个名字，一部分原因是它比较难发音，另一部分原因是它听起来比较像动词（使用“curry”则不是那么明确），而我们刚好需要一个动词来表明这是一个函数转换的过程。</p>
<p>这是一个通用的柯里化函数：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">schonfinkelize</span>(<span class="params">fn</span>) </span>{
    <span class="keyword">var</span> slice = <span class="built_in">Array</span>.prototype.slice,
    stored_args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
        <span class="keyword">var</span> new_args = slice.call(<span class="built_in">arguments</span>),
        args = stored_args.concat(new_args);
        <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, args);
    };
}
</code></pre><p>这个<code>schonfinkelize()</code>可能显得比较复杂了，只是因为在JavaScript中<code>arguments</code>不是一个真的数组。从<code>Array.prototype</code>中借用<code>slice()</code>方法帮助我们将<code>arguments</code>转换成数组，以便能更好地对它进行操作。当<code>schonfinkelize()</code>第一次被调用的时候，它使用<code>slice</code>变量存储了对<code>slice()</code>方法的引用，同时也存储了调用时的除去第一个之外的参数（<code>stored_args</code>），因为第一个参数是要被柯里化的函数。<code>schonfinkelize()</code>返回了一个函数，当这个返回的函数被调用的时候，它可以（通过闭包）访问到已经存储的参数<code>stored_args</code>和<code>slice</code>。新的函数只需要合并老的部分应用的参数（<code>stored_args</code>）和新的参数（<code>new_args</code>），然后将它们应用到原来的函数<code>fn</code>（也可以在闭包中访问到）即可。</p>
<p>现在有了通用的柯里化函数，就可以做一些测试了：</p>
<pre><code><span class="comment">// 普通函数</span>
<span class="function">function <span class="title">add</span><span class="params">(x, y)</span> </span>{
    <span class="keyword">return</span> x + y;
}

<span class="comment">// 柯里化得到新函数</span>
var newadd = schonfinkelize(add, <span class="number">5</span>);
newadd(<span class="number">4</span>); <span class="comment">// 9</span>

<span class="comment">// 另一种选择 直接调用新函数</span>
schonfinkelize(add, <span class="number">6</span>)(<span class="number">7</span>); <span class="comment">// 13</span>
</code></pre><p>用来做函数转换的<code>schonfinkelize()</code>并不局限于单个参数或者单步的柯里化。这里有些更多用法的例子：</p>
<pre><code><span class="comment">// 普通函数</span>
<span class="function">function <span class="title">add</span><span class="params">(a, b, c, d, e)</span> </span>{
    <span class="keyword">return</span> a + b + c + d + e;
}

<span class="comment">// 参数个数可以随意分割</span>
schonfinkelize(add, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)(<span class="number">5</span>, <span class="number">5</span>); <span class="comment">// 16</span>

<span class="comment">// 两步柯里化</span>
var addOne = schonfinkelize(add, <span class="number">1</span>);
addOne(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>); <span class="comment">// 41</span>
var addSix = schonfinkelize(addOne, <span class="number">2</span>, <span class="number">3</span>);
addSix(<span class="number">5</span>, <span class="number">5</span>); <span class="comment">// 16</span>
</code></pre><h3 id="什么时候使用柯里化">什么时候使用柯里化</h3><p>当你发现自己在调用同样的函数并且传入的参数大部分都相同的时候，就是考虑柯里化的理想场景了。你可以通过传入一部分的参数动态地创建一个新的函数。这个新函数会存储那些重复的参数（所以你不需要再每次都传入），然后再在调用原始函数的时候将整个参数列表补全。</p>
<p>##小结</p>
<p>在JavaScript中，对开发者在函数这个话题的理解和运用的要求是比较苛刻的。在本章中，主要讨论了有关函数的一些背景知识和术语。介绍了JavaScript函数中两个重要的特性，也就是：</p>
<ol>
<li>函数是一等对象，他们可以被作为值传递，也可以拥有属性和方法。</li>
<li>函数拥有本地作用域，而大括号不产生块级作用域。另外需要注意的是，变量的声明会被提前到本地作用域顶部。</li>
</ol>
<p>创建一个函数的语法有：</p>
<ol>
<li>具名函数表达式</li>
<li>匿名函数表达式（和上一种一样，但是没有名字），也就是为大家熟知的“匿名函数”</li>
<li>函数声明，与其它语言的函数语法相似</li>
</ol>
<p>在介绍完背景和函数的语法后，介绍了一些有用的模式，按分类列出：</p>
<ol>
<li><p>API模式，它们帮助我们为函数给出更干净的接口，包括：</p>
<ul>
<li><p>回调模式</p>
<pre><code>传入一个函数作为参数
</code></pre></li>
<li><p>配置对象</p>
<pre><code>帮助保持函数的参数数量可控
</code></pre></li>
<li><p>返回函数</p>
<pre><code>函数的返回值是另一个函数
</code></pre></li>
<li><p>柯里化</p>
<pre><code>新函数在已有函数的基础上再加上一部分参数构成
</code></pre></li>
</ul>
</li>
<li><p>初始化模式，这些模式帮助我们用一种干净的、结构化的方法来做一些初始化工作（在web页面和应用中非常常见），通过一些临时变量来保证不污染全局命名空间。这些模式包括：</p>
<ul>
<li><p>即时函数</p>
<pre><code>当它们被定义后立即执行
</code></pre></li>
<li><p>对象即时初始化</p>
<pre><code>初始化工作被放入一个匿名对象，这个对象提供一个可以立即被执行的方法
</code></pre></li>
<li><p>条件初始化</p>
<pre><code>使分支代码只在初始化的时候执行一次，而不是在整个程序生命周期中反复执行
</code></pre></li>
</ul>
</li>
<li><p>性能模式，这些模式帮助提高代码的执行速度，包括：</p>
<ul>
<li><p>记忆模式</p>
<pre><code>利用函数的属性，使已经计算过的值不用再次计算
</code></pre></li>
<li><p>自定义函数</p>
<pre><code>重写自身的函数体，使第二次及后续的调用做更少的工作
</code></pre></li>
</ul>
</li>
</ol>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/06/javascript/javascript-patterns/chapter5/" itemprop="url">
                第五章 对象创建模式
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-06T22:08:29+08:00" content="2015-12-06">
            2015-12-06
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/12/06/javascript/javascript-patterns/chapter5/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/12/06/javascript/javascript-patterns/chapter5/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>在JavaScript中创建对象是件很容易的事情，直接通过对象字面量或者构造函数就可以。本章将在此基础上介绍一些常用的对象创建模式。</p>
<p>JavaScript语言本身很简单、直观，也没有其他语言的一些语言特性：命名空间、模块、包、私有属性以及静态成员。本章将介绍一些常用的模式，以此实现这些语言特性。</p>
<p>我们将对命名空间、依赖声明、模块模式以及沙箱模式进行初探——它们可以帮助我们更好地组织应用程序的代码，有效地减少全局污染的问题。除此之外，还会讨论私有和特权成员、静态和私有静态成员、对象常量、链式调用以及一种像类式语言一样定义构造函数的方法等话题。  </p>
<h2 id="命名空间模式">命名空间模式</h2><p>使用命名空间可以减少全局变量的数量，与此同时，还能有效地避免命名冲突和前缀的滥用。</p>
<p>JavaScript没有原生的命名空间语法，但很容易可以实现这个特性。为了避免产生全局污染，你可以为应用或者类库创建一个（通常是唯一一个）全局对象，然后将所有的功能都添加到这个对象上，而不是到处声明大量的全局函数、全局对象以及其他的全局变量。</p>
<p>看如下例子：</p>
<pre><code><span class="comment">// 重构前：5个全局变量</span>
<span class="comment">// 注意：反模式</span>
<span class="comment">// 构造函数</span>
<span class="function"><span class="keyword">function</span> <span class="title">Parent</span><span class="params">()</span> </span>{} 
<span class="function"><span class="keyword">function</span> <span class="title">Child</span><span class="params">()</span> </span>{}
<span class="comment">// 一个变量</span>
<span class="keyword">var</span> some_var = <span class="number">1</span>;

<span class="comment">// 一些对象</span>
<span class="keyword">var</span> module1 = {}; 
module1.data = {a: <span class="number">1</span>, b: <span class="number">2</span>}; 
<span class="keyword">var</span> module2 = {};
</code></pre><p>可以通过创建一个全局对象（通常代表应用名）比如<code>MYAPP</code>来重构上述这类代码，然后将上述例子中的函数和变量都变为该全局对象的属性：</p>
<pre><code><span class="comment">// 重构后：一个全局变量</span>
<span class="comment">// 全局对象</span>
<span class="keyword">var</span> MYAPP = <span class="comment">{}</span>;

<span class="comment">// 构造函数</span>
MYAPP.Parent = <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="comment">{}</span>;</span> 
MYAPP.Child = <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="comment">{}</span>;</span>

<span class="comment">// 一个变量</span>
MYAPP.some_var = <span class="number">1</span>;

<span class="comment">// 一个对象容器</span>
MYAPP.modules = <span class="comment">{}</span>;

<span class="comment">// 嵌套的对象</span>
MYAPP.modules.module1 = <span class="comment">{}</span>; 
MYAPP.modules.module1.data = <span class="comment">{a: 1, b: 2}</span>; 
MYAPP.modules.module2 = <span class="comment">{}</span>;
</code></pre><p>这里的<code>MYAPP</code>就是命名空间对象，对象名可以随便取，可以是应用名、类库名、域名或者是公司名都可以。开发者经常约定全局变量都采用大写（所有字母都大写），这样可以显得比较突出（不过要记住，大写的变量也常用于表示常量）。</p>
<p>这种模式是一种很好的提供命名空间的方式，避免了自身代码的命名冲突，同时还避免了同一个页面上自身代码和第三方代码（比如JavaScript类库或者widget）的冲突。这种模式在大多数情况下非常适用，但也有它的缺点：</p>
<ul>
<li>代码量稍有增加；在每个函数和变量前加上这个命名空间对象的前缀，会增加代码量，增大文件大小</li>
<li>该全局实例可以被随时修改</li>
<li>命名的深度嵌套会减慢属性值的查询</li>
</ul>
<p>本章后续要介绍的沙箱模式则可以避免这些缺点。</p>
<h3 id="通用命名空间函数">通用命名空间函数</h3><p>随着程序复杂度的提高，代码会被分拆在不同的文件中以按照页面需要来加载，这样一来，就不能保证你的代码一定是第一个定义命名空间或者某个属性的，甚至会发生属性覆盖的问题。所以，在创建命名空间或者添加属性的时候，最好先检查下是否存在，如下所示：</p>
<pre><code><span class="comment">// 不安全的做法</span>
<span class="variable"><span class="keyword">var</span> MYAPP</span> = {};
<span class="comment">// 更好的做法</span>
<span class="keyword">if</span> (typeof MYAPP === <span class="string">"undefined"</span>) {
    <span class="variable"><span class="keyword">var</span> MYAPP</span> = {}; 
}
<span class="comment">// 简写</span>
<span class="variable"><span class="keyword">var</span> MYAPP</span> = MYAPP || {};
</code></pre><p>如上所示，如果每次做类似操作都要这样检查一下就会有很多重复的代码。例如，要声明<code>MYAPP.modules.module2</code>，就要重复三次这样的检查。所以，我们需要一个可复用的<code>namespace()</code>函数来专门处理这些检查工作，然后用它来创建命名空间，如下所示：</p>
<pre><code><span class="comment">// 使用命名空间函数</span>
MYAPP.<span class="keyword">namespace</span>(<span class="string">'MYAPP.modules.module2'</span>);

<span class="comment">// 等价于：</span>
<span class="comment">// var MYAPP = {</span>
<span class="comment">//     modules: {</span>
<span class="comment">//         module2: {}</span>
<span class="comment">//     }</span>
<span class="comment">// };</span>
</code></pre><p>下面是上述<code>namespace</code>函数的实现示例。这种实现是非破坏性的，意味着如果要创建的命名空间已经存在，则不会再重复创建：</p>
<pre><code><span class="keyword">var</span> MYAPP = MYAPP || {};
MYAPP.namespace = <span class="function"><span class="keyword">function</span> <span class="params">(ns_string)</span> </span>{ 
    <span class="keyword">var</span> parts = ns_string.split(<span class="string">'.'</span>),
        <span class="keyword">parent</span> = MYAPP, 
        i;

    <span class="comment">// 去除不必要的全局变量层</span>
    <span class="comment">// 译注：因为namespace已经属于MYAPP</span>
    <span class="keyword">if</span> (parts[<span class="number">0</span>] === <span class="string">"MYAPP"</span>) {
        parts = parts.slice(<span class="number">1</span>); 
    }

    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; parts.length; i += <span class="number">1</span>) {
        <span class="comment">// 如果属性不存在则创建它</span>
        <span class="keyword">if</span> (typeof <span class="keyword">parent</span>[parts[i]] === <span class="string">"undefined"</span>) {
            <span class="keyword">parent</span>[parts[i]] = {}; 
        }
        <span class="keyword">parent</span> = <span class="keyword">parent</span>[parts[i]];
    }
    <span class="keyword">return</span> <span class="keyword">parent</span>;
};
</code></pre><p>上述实现支持如下几种用法：</p>
<pre><code><span class="comment">// 将返回值赋给本地变量</span>
<span class="keyword">var</span> module2 = MYAPP.<span class="keyword">namespace</span>(<span class="string">'MYAPP.modules.module2'</span>); 
module2 === MYAPP.modules.module2; <span class="comment">// true</span>

<span class="comment">// 省略全局命名空间`MYAPP`</span>
MYAPP.<span class="keyword">namespace</span>(<span class="string">'modules.module51'</span>);

<span class="comment">// 长命名空间</span>
MYAPP.<span class="keyword">namespace</span>(<span class="string">'once.upon.a.time.there.was.this.long.nested.property'</span>);
</code></pre><p>图5-1 展示了上述代码创建的命名空间对象在Firebug下的可视化结果</p>
<p><img src="./Figure/chapter5/5-1.jpg" alt="MYAPP命名空间在Firebug下的可视结果"></p>
<p>图5-1 MYAPP命名空间在Firebug下的可视化结果</p>
<h2 id="依赖声明">依赖声明</h2><p>JavaScript库往往是模块化而且有用到命名空间的，这使得你可以只使用你需要的模块。比如在YUI2中，全局变量<code>YAHOO</code>就是一个命名空间，各个模块都是全局变量的属性，比如<code>YAHOO.util.Dom</code>（DOM模块）、<code>YAHOO.util.Event</code>（事件模块）。</p>
<p>将你的代码依赖在函数或者模块的顶部进行声明是一个好主意。声明就是创建一个本地变量，指向你需要用到的模块：</p>
<pre><code><span class="keyword">var</span> myFunction = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="comment">// 依赖</span>
    <span class="keyword">var</span> event = YAHOO.util.Event,
        dom = YAHOO.util.Dom;

    <span class="comment">// 在函数后面的代码中使用event和dom……</span>
};
</code></pre><p>这是一个相当简单的模式，但是有很多的好处：</p>
<ul>
<li>明确的依赖声明是告知使用你代码的开发者，需要保证指定的脚本文件被包含在页面中。</li>
<li>将声明放在函数顶部使得依赖很容易被查找和解析。</li>
<li>本地变量（如<code>dom</code>）永远会比全局变量（如<code>YAHOO</code>）要快，甚至比全局变量的属性（如<code>YAHOO.util.Dom</code>）还要快，这样会有更好的性能。使用了依赖声明模式之后，全局变量的解析在函数中只会进行一次，在此之后将会使用更快的本地变量。</li>
<li>一些高级的代码压缩工具比如YUI Compressor和Google Closure compiler会重命名本地变量（比如<code>event</code>可能会被压缩成一个字母，如<code>A</code>），这会使代码更精简，但这个操作不会对全局变量进行，因为这样做不安全。</li>
</ul>
<p>下面的代码片段是关于是否使用依赖声明模式对压缩影响的展示。尽管使用了依赖声明模式的<code>test2()</code>看起来复杂，因为需要更多的代码行数和一个额外的变量，但在压缩后它的代码量却会更小，意味着用户只需要下载更少的代码：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">test1</span><span class="params">()</span> </span>{
    alert(MYAPP.modules.m1);
    alert(MYAPP.modules.m2);
    alert(MYAPP.modules.m51);
}

<span class="comment">/*
test1()压缩后的函数体：
alert(MYAPP.modules.m1);alert(MYAPP.modules.m2);alert(MYAPP.modules.m51)
*/</span>

<span class="function"><span class="keyword">function</span> <span class="title">test2</span><span class="params">()</span> </span>{
    <span class="keyword">var</span> modules = MYAPP.modules;
    alert(modules.m1);
    alert(modules.m2);
    alert(modules.m51);
}

<span class="comment">/*
test2()压缩后的函数体：
var a=MYAPP.modules;alert(a.m1);alert(a.m2);alert(a.m51)
*/</span>
</code></pre><h2 id="私有属性和方法">私有属性和方法</h2><p>JavaScript不像Java或者其它语言，它没有专门的提供私有、保护、公有属性和方法的语法。所有的对象成员都是公有的：</p>
<pre><code><span class="keyword">var</span> myobj = {
    myprop: <span class="number">1</span>,
    getProp: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
        <span class="keyword">return</span> <span class="keyword">this</span>.myprop;
    }
};
<span class="built_in">console</span>.log(myobj.myprop); <span class="comment">// myprop是公有的</span>
<span class="built_in">console</span>.log(myobj.getProp()); <span class="comment">// getProp()也是公有的</span>
</code></pre><p>当你使用构造函数创建对象的时候也是一样的，所有的成员都是公有的：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Gadget</span>(<span class="params"></span>) </span>{
    <span class="keyword">this</span>.name = <span class="string">'iPod'</span>;
    <span class="keyword">this</span>.stretch = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
        <span class="keyword">return</span> <span class="string">'iPad'</span>;
    };
}
<span class="keyword">var</span> toy = <span class="keyword">new</span> Gadget();
<span class="built_in">console</span>.log(toy.name); <span class="comment">// name是公有的</span>
<span class="built_in">console</span>.log(toy.stretch()); <span class="comment">// stretch()也是公有的</span>
</code></pre><h3 id="私有成员">私有成员</h3><p>尽管语言并没有用于私有成员的专门语法，但你可以通过闭包来实现。在构造函数中创建一个闭包，任何在这个闭包中的部分都不会暴露到构造函数之外。但是，这些私有变量却可以被公有方法访问，也就是在构造函数中定义的并且作为返回对象一部分的那些方法。我们来看一个例子，<code>name</code>是一个私有成员，在构造函数之外不能被访问：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Gadget</span>(<span class="params"></span>) </span>{
    <span class="comment">// 私有成员</span>
    <span class="keyword">var</span> name = <span class="string">'iPod'</span>;
    <span class="comment">// 公有函数</span>
    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
        <span class="keyword">return</span> name;
    };
}
<span class="keyword">var</span> toy = <span class="keyword">new</span> Gadget();

<span class="comment">// name是是私有的</span>
<span class="built_in">console</span>.log(toy.name); <span class="comment">// undefined</span>
<span class="comment">// 公有方法可以访问到name</span>
<span class="built_in">console</span>.log(toy.getName()); <span class="comment">// "iPod"</span>
</code></pre><p>如你所见，在JavaScript创建私有成员很容易。你需要做的只是将私有成员放在一个函数中，保证它是函数的本地变量，也就是说让它在函数之外不可以被访问。</p>
<h3 id="特权方法">特权方法</h3><p>特权方法的概念不涉及到任何语法，它只是一个给可以访问到私有成员的公有方法的名字（就好像它们有更多权限一样）。</p>
<p>在前面的例子中，<code>getName()</code>就是一个特权方法，因为它有访问<code>name</code>属性的特殊权限。</p>
<h3 id="私有成员失效">私有成员失效</h3><p>当你使用私有成员时，需要考虑一些极端情况：</p>
<ul>
<li>在Firefox的一些早期版本中，允许通过给<code>eval()</code>传递第二个参数的方法来指定上下文对象，从而允许访问函数的私有作用域。比如在Mozilla Rhino（译注：一个JavaScript引擎）中，允许使用<code>__parent__</code>来访问私有作用域。这些极端情况现在并没有广泛存在于浏览器中。</li>
<li>当你直接通过特权方法返回一个私有变量，而这个私有变量恰好是一个对象或者数组时，外部的代码可以修改这个私有变量，因为它是按引用传递的。</li>
</ul>
<p>我们来看一下第二种情况。下面的<code>Gadget</code>的实现看起来没有问题：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Gadget</span><span class="params">()</span> </span>{
    <span class="comment">// 私有成员</span>
    <span class="keyword">var</span> specs = {
        screen_width: <span class="number">320</span>,
        screen_height: <span class="number">480</span>,
        color: <span class="string">"white"</span>
    };

    <span class="comment">// 公有函数</span>
    <span class="keyword">this</span>.getSpecs = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        <span class="keyword">return</span> specs;
    };
}
</code></pre><p>这里的问题是<code>getSpecs()</code>返回了一个<code>specs</code>对象的引用。这使得<code>Gadget()</code>的使用者可以修改貌似隐藏起来的私有成员<code>specs</code>：</p>
<pre><code><span class="keyword">var</span> toy = <span class="keyword">new</span> Gadget(),
    specs = toy.getSpecs();

specs.color = <span class="string">"black"</span>;
specs.price = <span class="string">"free"</span>;

<span class="built_in">console</span>.dir(toy.getSpecs());
</code></pre><p>在Firebug控制台中打印出来的结果如图5-2：</p>
<p><img src="./Figure/chapter5/5-2.jpg" alt="图5-2 私有对象被修改了"></p>
<p>图5-2 私有对象被修改了</p>
<p>这个问题有点出乎意料，解决方法就是不要将你想保持私有的对象或者数组的引用传递出去。达到这个目标的一种方法是让<code>getSpecs()</code>返回一个新对象，这个新对象只包含对象的使用者需要的数据。这也是众所周知的“最低授权原则”（Principle of Least Authority，简称POLA），指永远不要给出比真实需要更多的东西。在这个例子中，如果<code>Gadget()</code>的使用者关注它是否适应一个特定的盒子，它只需要知道尺寸即可。所以你应该创建一个<code>getDimensions()</code>，用它返回一个只包含<code>width</code>和<code>height</code>的新对象，而不是把什么都给出去。也就是说，也许你根本不需要实现<code>getSpecs()</code>方法。</p>
<p>当你需要传递所有的数据时，有另外一种方法，就是使用通用的对象复制函数创建<code>specs</code>对象的一个副本。下一章提供了两个这样的函数——一个叫<code>extend()</code>，它会浅复制一个给定的对象（只复制顶层的成员），另一个叫<code>extendDeep()</code>，它会做深复制，遍历所有的属性和嵌套的属性。</p>
<h3 id="对象字面量和私有成员">对象字面量和私有成员</h3><p>到目前为止，我们只看了使用构建函数创建私有成员的示例。如果使用对象字面量创建对象时会是什么情况呢？是否有可能含有私有成员？</p>
<p>如你前面所看到的那样，私有数据使用一个函数来包裹。所以在使用对象字面量时，你也可以使用一个即时函数创建的闭包。例如：</p>
<pre><code><span class="keyword">var</span> myobj; <span class="comment">// 一个对象</span>
(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="comment">// 私有成员</span>
    <span class="keyword">var</span> name = <span class="string">"my, oh my"</span>;

    <span class="comment">// 实现公有部分，注意没有var</span>
    myobj = {
        <span class="comment">// 特权方法</span>
        getName: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
            <span class="keyword">return</span> name;
        }
    };
}());

myobj.getName(); <span class="comment">// "my, oh my"</span>
</code></pre><p>还有一个原理一样但看起来不一样的实现示例：</p>
<pre><code><span class="keyword">var</span> myobj = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="comment">// 私有成员</span>
    <span class="keyword">var</span> name = <span class="string">"my, oh my"</span>;

    <span class="comment">// 实现公有部分</span>
    <span class="keyword">return</span> {
        getName: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
            <span class="keyword">return</span> name;
        }
    };
}());

myobj.getName(); <span class="comment">// "my, oh my"</span>
</code></pre><p>这个例子也是所谓的“模块模式”的基础，我们稍后将讲到它。</p>
<h3 id="原型和私有成员">原型和私有成员</h3><p>使用构造函数创建私有成员的一个弊端是，每一次调用构造函数创建对象时这些私有成员都会被创建一次。</p>
<p>这对在构建函数中添加到<code>this</code>的成员来说是一个问题。为了避免重复劳动，节省内存，你可以将共用的属性和方法添加到构造函数的<code>prototype</code>（原型）属性中。这样的话这些公共的部分会在使用同一个构造函数创建的所有实例中共享。你也同样可以在这些实例中共享私有成员，甚至可以将两种模式联合起来达到这个目的，同时使用构造函数中的私有属性和对象字面量中的私有属性。因为<code>prototype</code>属性也只是一个对象，可以使用对象字面量创建。</p>
<p>这是一个示例：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Gadget</span>(<span class="params"></span>) </span>{
    <span class="comment">// 私有成员</span>
    <span class="keyword">var</span> name = <span class="string">'iPod'</span>;
    <span class="comment">// 公有函数</span>
    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
        <span class="keyword">return</span> name;
    };
}

Gadget.prototype = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    <span class="comment">// 私有成员</span>
    <span class="keyword">var</span> browser = <span class="string">"Mobile Webkit"</span>;
    <span class="comment">// 公有函数</span>
    <span class="keyword">return</span> {
        getBrowser: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
            <span class="keyword">return</span> browser;
        }
    };
}());

<span class="keyword">var</span> toy = <span class="keyword">new</span> Gadget();
<span class="built_in">console</span>.log(toy.getName()); <span class="comment">// 自有的特权方法 </span>
<span class="built_in">console</span>.log(toy.getBrowser()); <span class="comment">// 来自原型的特权方法</span>
</code></pre><h3 id="将私有函数暴露为公有方法">将私有函数暴露为公有方法</h3><p>“暴露模式”是指将已经有的私有函数暴露为公有方法，它在你希望尽量保护对象内的一些方法不被外部修改干扰的时候很有用。你希望能提供一些功能给外部访问，因为它们会被用到，如果你把这些方法公开，就会使得它们不再健壮，因为你的API的使用者可能修改它们。在ECMAScript5中，你可以选择冻结一个对象，但在之前的版本中这种方法不可用。下面进入暴露模式（原来是由Christian Heilmann创造的模式，叫“暴露模块模式”）。</p>
<p>我们来看一个例子，它建立在对象字面量的私有成员模式之上：</p>
<pre><code><span class="keyword">var</span> myarray;

(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{

    <span class="keyword">var</span> astr = <span class="string">"[object Array]"</span>,
        toString = <span class="built_in">Object</span>.prototype.toString;

    <span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">a</span>) </span>{
        <span class="keyword">return</span> toString.call(a) === astr;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">indexOf</span>(<span class="params">haystack, needle</span>) </span>{
        <span class="keyword">var</span> i = <span class="number">0</span>,
            max = haystack.length;
        <span class="keyword">for</span> (; i &lt; max; i += <span class="number">1</span>) {
            <span class="keyword">if</span> (haystack[i] === needle) {
                <span class="keyword">return</span> i;
            }
        }
        <span class="keyword">return</span> −<span class="number">1</span>;
    }

    myarray = {
        isArray: isArray,
        indexOf: indexOf,
        inArray: indexOf
    };

}());
</code></pre><p>这里有两个私有变量（私有函数）——<code>isArray()</code>和<code>indexOf()</code>。在包裹函数的最后，用那些允许被从外部访问的函数填充<code>myarray</code>对象。在这个例子中，同一个私有函数    <code>indexOf()</code>同时被暴露为ECMAScript5风格的<code>indexOf()</code>和PHP风格的<code>inArry()</code>。测试一下<code>myarray</code>对象：</p>
<pre><code>myarray.isArray([<span class="number">1</span>,<span class="number">2</span>]); <span class="comment">// true</span>
myarray.isArray({<span class="number">0</span>: <span class="number">1</span>}); <span class="comment">// false</span>
myarray.indexOf([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"z"</span>], <span class="string">"z"</span>); <span class="comment">// 2</span>
myarray.inArray([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"z"</span>], <span class="string">"z"</span>); <span class="comment">// 2</span>
</code></pre><p>现在假如有一些意外的情况发生在暴露的<code>indexOf()</code>方法上，私有的<code>indexOf()</code>方法仍然是安全的，因此<code>inArray()</code>仍然可以正常工作：</p>
<pre><code>myarray.indexOf = <span class="literal">null</span>;
myarray.inArray([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"z"</span>], <span class="string">"z"</span>); <span class="comment">// 2</span>
</code></pre><h2 id="模块模式">模块模式</h2><p>模块模式使用得很广泛，因为它可以为代码提供特定的结构，帮助组织日益增长的代码。不像其它语言，JavaScript没有专门的“包”（package）的语法，但模块模式提供了用于创建独立解耦的代码片段的工具，这些代码可以被当成黑盒，当你正在写的软件需求发生变化时，这些代码可以被添加、替换、移除。</p>
<p>模块模式是我们目前讨论过的好几种模式的组合，即：</p>
<ul>
<li>命名空间模式</li>
<li>即时函数模式</li>
<li>私有和特权成员模式</li>
<li>依赖声明模式</li>
</ul>
<p>第一步是初始化一个命名空间。我们使用本章前面部分的<code>namespace()</code>函数，创建一个提供数组相关方法的套件模块：</p>
<pre><code>MYAPP.<span class="keyword">namespace</span>(<span class="string">'MYAPP.utilities.array'</span>);
</code></pre><p>下一步是定义模块。使用一个即时函数来提供私有作用域供私有成员使用。即时函数返回一个对象，也就是带有公有接口的真正的模块，可以供其它代码使用：</p>
<pre><code>MYAPP.utilities.<span class="keyword">array</span> = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="keyword">return</span> {
        <span class="comment">// todo...</span>
    };
}());
</code></pre><p>下一步，给公有接口添加一些方法：</p>
<pre><code>MYAPP.utilities.<span class="keyword">array</span> = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="keyword">return</span> {
        inArray: <span class="function"><span class="keyword">function</span> <span class="params">(needle, haystack)</span> </span>{
            <span class="comment">// ...</span>
        },
        isArray: <span class="function"><span class="keyword">function</span> <span class="params">(a)</span> </span>{
            <span class="comment">// ...</span>
        }
    };
}());
</code></pre><p>如果需要的话，你可以在即时函数提供的闭包中声明私有属性和私有方法。同样，依赖声明放置在函数顶部，在变量声明的下方可以选择性地放置辅助初始化模块的一次性代码。函数最终返回的是一个包含模块公共API的对象：</p>
<pre><code>MYAPP.<span class="keyword">namespace</span>(<span class="string">'MYAPP.utilities.array'</span>);
MYAPP.utilities.array = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{

        <span class="comment">// 依赖声明</span>
    <span class="keyword">var</span> uobj = MYAPP.utilities.object,
        ulang = MYAPP.utilities.lang,

        <span class="comment">// 私有属性</span>
        array_string = <span class="string">"[object Array]"</span>,
        ops = Object.prototype.toString;

        <span class="comment">// 私有方法</span>
        <span class="comment">// ……</span>

        <span class="comment">// 结束变量声明</span>

    <span class="comment">// 选择性放置一次性初始化的代码</span>
    <span class="comment">// ……</span>

    <span class="comment">// 公有API</span>
    <span class="keyword">return</span> {

        inArray: <span class="function"><span class="keyword">function</span> <span class="params">(needle, haystack)</span> </span>{
            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, max = haystack.length; i &lt; max; i += <span class="number">1</span>) {
                <span class="keyword">if</span> (haystack[i] === needle) {
                    <span class="keyword">return</span> <span class="literal">true</span>;
                }
            }
        },

        isArray: <span class="function"><span class="keyword">function</span> <span class="params">(a)</span> </span>{
            <span class="keyword">return</span> ops.call(a) === array_string;
        }
        <span class="comment">// ……更多的方法和属性</span>
    };
}());
</code></pre><p>模块模式被广泛使用，是一种值得强烈推荐的模式，它可以帮助我们组织代码，尤其是代码量在不断增长的时候。</p>
<h3 id="暴露模块模式">暴露模块模式</h3><p>我们在本章中讨论私有成员模式时已经讨论过暴露模式。模块模式也可以用类似的方法来组织，将所有的方法保持私有，只在最后暴露需要使用的方法来初始化API。</p>
<p>上面的例子可以变成这样：</p>
<pre><code>MYAPP.utilities.array = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{

        <span class="comment">// 私有属性</span>
    <span class="keyword">var</span> array_string = <span class="string">"[object Array]"</span>,
        ops = <span class="built_in">Object</span>.prototype.toString,

        <span class="comment">// 私有方法</span>
        inArray = <span class="function"><span class="keyword">function</span> (<span class="params">haystack, needle</span>) </span>{
            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, max = haystack.length; i &lt; max; i += <span class="number">1</span>) {
                <span class="keyword">if</span> (haystack[i] === needle) {
                    <span class="keyword">return</span> i;
                }
            }
            <span class="keyword">return</span> −<span class="number">1</span>;
        },
        isArray = <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>{
            <span class="keyword">return</span> ops.call(a) === array_string;
        };
        <span class="comment">// 结束变量定义</span>

    <span class="comment">// 暴露公有API</span>
    <span class="keyword">return</span> {
        isArray: isArray,
        indexOf: inArray
    };
}());
</code></pre><h3 id="创建构造函数的模块">创建构造函数的模块</h3><p>前面的例子创建了一个对象<code>MYAPP.utilities.array</code>，但有时候使用构造函数来创建对象会更方便。你也可以同样使用模块模式来做。唯一的区别是包裹模块的即时函数会在最后返回一个函数，而不是一个对象。</p>
<p>看下面的模块模式的例子，创建了一个构造函数<code>MYAPP.utilities.Array</code>：</p>
<pre><code>MYAPP.namespace(<span class="string">'MYAPP.utilities.Array'</span>);

MYAPP.utilities.Array = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{

        <span class="comment">// 依赖声明</span>
    <span class="keyword">var</span> uobj = MYAPP.utilities.object,
        ulang = MYAPP.utilities.lang,

        <span class="comment">// 私有属性和方法……</span>
        Constr;

        <span class="comment">// 结束变量定义</span>

    <span class="comment">// 选择性放置一次性初始化代码</span>
    <span class="comment">// ……</span>

    <span class="comment">// 公有API——构造函数</span>
    Constr = <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>{
        <span class="keyword">this</span>.elements = <span class="keyword">this</span>.toArray(o);
    };
    <span class="comment">// 公有API——原型</span>
    Constr.prototype = {
        <span class="constructor"><span class="keyword">constructor</span>: MYAPP.utilities.Array,
        version: "2.0",
        toArray: function (obj) </span>{
            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, a = [], len = obj.length; i &lt; len; i += <span class="number">1</span>) {
                a[i] = obj[i];
            }
            <span class="keyword">return</span> a;
        }
    };

    <span class="comment">// 返回构造函数</span>
    <span class="keyword">return</span> Constr;

}());
</code></pre><p>像这样使用这个新的构造函数：</p>
<pre><code><span class="built_in">var</span> arr = <span class="literal">new</span> MYAPP<span class="built_in">.</span>utilities<span class="built_in">.</span><span class="built_in">Array</span>(obj);
</code></pre><h3 id="在模块中引入全局上下文">在模块中引入全局上下文</h3><p>作为这种模式的一个常见的变种，你可以给包裹模块的即时函数传递参数。你可以传递任何值，但通常情况下会传递全局变量甚至是全局对象本身。引入全局上下文可以加快函数内部的全局变量的解析，因为引入之后会作为函数的本地变量：</p>
<pre><code>MYAPP.utilities.<span class="keyword">module</span> = (<span class="function"><span class="keyword">function</span> <span class="params">(app, <span class="keyword">global</span>)</span> <span class="comment">{

    // 全局对象和全局命名空间都作为本地变量存在

}</span><span class="params">(MYAPP, this)</span>);</span>
</code></pre><h2 id="沙箱模式">沙箱模式</h2><p>沙箱模式主要着眼于命名空间模式的短处，即：</p>
<ul>
<li>依赖一个全局变量成为应用的全局命名空间。在命名空间模式中，没有办法在同一个页面中运行同一个应用或者类库的不同版本，因为它们都会需要同一个全局变量名，比如<code>MYAPP</code>。</li>
<li>代码中以点分隔的名字比较长，无论写代码还是解析都需要处理这个很长的名字，比如<code>MYAPP.utilities.array</code>。</li>
</ul>
<p>顾名思义，沙箱模式为模块提供了一个环境，模块在这个环境中的任何行为都不会影响其它的模块和其它模块的沙箱。</p>
<p>这个模式在YUI3中用得很多，但是需要记住的是，下面的讨论只是一些示例实现，并不讨论YUI3中的沙箱是如何实现的。</p>
<h3 id="全局构造函数">全局构造函数</h3><p>在命名空间模式中 ，有一个全局对象，而在沙箱模式中，唯一的全局变量是一个构造函数，我们把它命名为<code>Sandbox()</code>。我们使用这个构造函数来创建对象，同时也要传入一个回调函数，这个函数会成为代码运行的独立空间。</p>
<p>使用沙箱模式是像这样：</p>
<pre><code><span class="keyword">new</span> Sandbox(<span class="function"><span class="keyword">function</span> <span class="params">(box)</span> </span>{
    <span class="comment">// 你的代码……</span>
});
</code></pre><p><code>box</code>对象和命名空间模式中的<code>MYAPP</code>类似，它包含了所有你的代码需要用到的功能。</p>
<p>我们要多做两件事情：</p>
<ul>
<li>通过一些手段（第3章中的强制使用<code>new</code>的模式），你可以在创建对象的时候不要求一定有<code>new</code>。</li>
<li>让<code>Sandbox()</code>构造函数可以接受一个（或多个）额外的配置参数，用于指定这个对象需要用到的模块名字。我们希望代码是模块化的，因此绝大部分<code>Sandbox()</code>提供的功能都会被包含在模块中。</li>
</ul>
<p>有了这两个额外的特性之后，我们来看一下实例化对象的代码是什么样子。</p>
<p>你可以在创建对象时省略<code>new</code>并像这样使用已有的<code>ajax</code>和<code>event</code>模块：</p>
<pre><code>Sandbox<span class="list">([<span class="quoted">'ajax</span>', <span class="quoted">'event</span>'], function <span class="list">(<span class="keyword">box</span>)</span> {
    // console.log<span class="list">(<span class="keyword">box</span>)</span><span class="comment">;</span>
})</span><span class="comment">;</span>
</code></pre><p>下面的例子和前面的很像，但是模块名字是作为独立的参数传入的：</p>
<pre><code>Sandbox<span class="list">(<span class="quoted">'ajax</span>', <span class="quoted">'dom</span>', function <span class="list">(<span class="keyword">box</span>)</span> {
    // console.log<span class="list">(<span class="keyword">box</span>)</span><span class="comment">;</span>
})</span><span class="comment">;</span>
</code></pre><p>使用通配符“＊”来表示“使用所有可用的模块”是个不错的想法，为了方便，我们也假设没有任何模块传入时，沙箱使用“＊”。所以有两种使用所有可用模块的方法：</p>
<pre><code>Sandbox<span class="list">(<span class="quoted">'*</span>', function <span class="list">(<span class="keyword">box</span>)</span> {
    // console.log<span class="list">(<span class="keyword">box</span>)</span><span class="comment">;</span>
})</span><span class="comment">;</span>

Sandbox<span class="list">(<span class="keyword">function</span> <span class="list">(<span class="keyword">box</span>)</span> {
    // console.log<span class="list">(<span class="keyword">box</span>)</span><span class="comment">;</span>
})</span><span class="comment">;</span>
</code></pre><p>下面的例子展示了如何实例化多个沙箱对象，你甚至可以将它们嵌套起来而互不影响：</p>
<pre><code>Sandbox(<span class="string">'dom'</span>, <span class="string">'event'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(box)</span> </span>{

    <span class="comment">// 使用dom和event模块</span>

    Sandbox(<span class="string">'ajax'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(box)</span> </span>{
        <span class="comment">// 另一个沙箱中的box，这个box和外面的box不一样</span>

        <span class="comment">//...</span>

        <span class="comment">// 使用ajax模块的代码到此为止</span>

    });

    <span class="comment">// 这里的代码与ajax模块无关</span>
});
</code></pre><p>从这些例子中看到，使用沙箱模式可以通过将代码包裹在回调函数中的方式来保护全局命名空间。</p>
<p>如果需要的话，你也可以利用函数也是对象这一事实，将一些数据作为静态属性存放到<code>Sandbox()</code>构造函数。</p>
<p>最后，你可以根据需要的模块类型创建不同的实例，这些实例都是相互独立的。</p>
<p>现在我们来看一下如何实现<code>Sandbox()</code>构造函数和它的模块来支持上面讲到的所有功能。</p>
<h3 id="添加模块">添加模块</h3><p>在动手实现构造函数之前，我们先来看一下如何添加模块。</p>
<p><code>Sandbox()</code>构造函数也是一个对象，所以可以给它添加一个<code>modules</code>静态属性。这个属性也是一个包含名值（key-value）对的对象，其中key是模块的名字，value是模块的功能实现。</p>
<pre><code>Sandbox.modules = {};

Sandbox.modules.dom = <span class="function"><span class="keyword">function</span> <span class="params">(box)</span> </span>{
    box.getElement = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{};
    box.getStyle = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{};
    box.foo = <span class="string">"bar"</span>;
};

Sandbox.modules.event = <span class="function"><span class="keyword">function</span> <span class="params">(box)</span> </span>{
    <span class="comment">// 如果有需要的话可以访问Sandbox的原型</span>
    <span class="comment">// box.constructor.prototype.m = "mmm";</span>
    box.attachEvent = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{};
    box.dettachEvent = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{};
};

Sandbox.modules.ajax = <span class="function"><span class="keyword">function</span> <span class="params">(box)</span> </span>{
    box.makeRequest = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{};
    box.getResponse = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{};
};
</code></pre><p>在这个例子中我们添加了<code>dom</code>、<code>event</code>和<code>ajax</code>模块，这些模块在每个类库或者复杂的web应用中都很常见。</p>
<p>每个模块功能函数接受一个实例<code>box</code>作为参数，并给这个实例添加属性和方法。</p>
<h3 id="实现构造函数">实现构造函数</h3><p>最后，我们来实现<code>Sandbox()</code>构造函数（你可能会很自然地想将这类构造函数命名为对你的类库或者应用有意义的名字）：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Sandbox</span>(<span class="params"></span>) </span>{
    <span class="comment">// 将参数转换为数组</span>
    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>),
        <span class="comment">// 最后一个参数是回调函数</span>
        callback = args.pop(),
        <span class="comment">// 参数可以作为数组或者单独的参数传递</span>
        modules = (args[<span class="number">0</span>] &amp;&amp; <span class="keyword">typeof</span> args[<span class="number">0</span>] === <span class="string">"string"</span>) ? args : args[<span class="number">0</span>], i;

    <span class="comment">// 保证函数是作为构造函数被调用</span>
    <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Sandbox)) {
        <span class="keyword">return</span> <span class="keyword">new</span> Sandbox(modules, callback);
    }

    <span class="comment">// 根据需要给this添加属性</span>
    <span class="keyword">this</span>.a = <span class="number">1</span>;
    <span class="keyword">this</span>.b = <span class="number">2</span>;

    <span class="comment">// 给this对象添加模块</span>
    <span class="comment">// 未指明模块或者*都表示“使用所有模块”</span>
    <span class="keyword">if</span> (!modules || modules[<span class="number">0</span>] === <span class="string">'*'</span>) {
        modules = [];
        <span class="keyword">for</span> (i <span class="keyword">in</span> Sandbox.modules) {
            <span class="keyword">if</span> (Sandbox.modules.hasOwnProperty(i)) {
                modules.push(i);
            }
        }
    }

    <span class="comment">// 初始化指定的模块</span>
    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; modules.length; i += <span class="number">1</span>) {
        Sandbox.modules[modules[i]](<span class="keyword">this</span>);
    }

    <span class="comment">// 调用回调函数</span>
    callback(<span class="keyword">this</span>);
}

<span class="comment">// 需要添加在原型上的属性</span>
Sandbox.prototype = {
    name: <span class="string">"My Application"</span>,
    version: <span class="string">"1.0"</span>,
    getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
        <span class="keyword">return</span> <span class="keyword">this</span>.name;
    }
};
</code></pre><p>这个实现中的一些关键点：</p>
<ul>
<li>有一个检查<code>this</code>是否是<code>Sandbox()</code>实例的过程，如果不是（也就是调用<code>Sandbox()</code>时没有加<code>new</code>），我们将这个函数作为构造函数再调用一次。</li>
<li>你可以在构造函数中给<code>this</code>添加属性，也可以给构造函数的原型添加属性。</li>
<li>被依赖的模块可以以数组的形式传递，也可以作为单独的参数传递，甚至以<code>*</code>通配符（或者省略）来表示加载所有可用的模块。值得注意的是，我们在这个示例实现中并没有考虑从外部文件中加载模块，但明显这是一个值得考虑的事情。比如YUI3就支持这种情况，你可以只加载最基本的模块（作为“种子”），其余需要的任何模块都通过将模块名和文件名对应的方式从外部文件中加载。</li>
<li>当我们知道依赖的模块之后就初始化它们，也就是调用实现每个模块的函数。</li>
<li>构造函数的最后一个参数是回调函数。这个回调函数会在最后使用新创建的实例来调用。事实上这个回调函数就是用户的沙箱，它被传入一个<code>box</code>对象，这个对象包含了所有依赖的功能。</li>
</ul>
<h2 id="静态成员">静态成员</h2><p>静态属性和方法是指那些在所有的实例中都一样的成员。在基于类的语言中，静态成员是用专门的语法来创建，使用时就像是类自己的成员一样。比如<code>MathUtils</code>类的<code>max()</code>方法会被像这样调用：<code>MathUtils.max(3, 5)</code>。这是一个公有静态成员的示例，即可以在不实例化类的情况下使用。同样也可以有私有的静态方法，即对类的使用者不可见，而在类的所有实例间是共享的。我们来看一下如何在JavaScript中实现公有和私有静态成员。</p>
<h3 id="公有静态成员">公有静态成员</h3><p>在JavaScript中没有专门用于静态成员的语法。但通过给构造函数添加属性的方法，可以拥有和基于类的语言一样的使用语法。之所以可以这样做是因为构造函数和其它的函数一样，也是对象，可以拥有属性。前一章讨论过的记忆模式也使用了同样的方法，即给函数添加属性。</p>
<p>下面的例子定义了一个构造函数<code>Gadget()</code>，它有一个静态方法<code>isShiny()</code>和一个实例方法<code>setPrice()</code>。<code>isShiny()</code>是一个静态方法，因为它不需要指定一个具体的对象就能工作（你不需要先拿到一个特定的小工具（gadget）才知道所有小工具是不是有光泽的（shiny））。但setPrice()却需要一个对象，因为小工具可能有不同的定价：</p>
<pre><code><span class="comment">// 构造函数</span>
<span class="keyword">var</span> Gadget = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{};

<span class="comment">// 静态方法</span>
Gadget.isShiny = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="keyword">return</span> <span class="string">"you bet"</span>;
};

<span class="comment">// 添加到原型的普通方法</span>
Gadget.prototype.setPrice = <span class="function"><span class="keyword">function</span> <span class="params">(price)</span> </span>{
    <span class="keyword">this</span>.price = price;
};
</code></pre><p>现在我们来调用这些方法。静态方法<code>isShiny()</code>可以直接在构造函数上调用，但其它的方法需要一个实例：</p>
<pre><code><span class="comment">// 调用静态方法</span>
Gadget.isShiny(); <span class="comment">// "you bet"</span>

<span class="comment">// 创建实例并调用方法</span>
<span class="keyword">var</span> iphone = <span class="keyword">new</span> Gadget();
iphone.setPrice(<span class="number">500</span>);
</code></pre><p>使用静态方法的调用方式去调用实例方法并不能正常工作，同样，用调用实例方法的方式来调用静态方法也不能正常工作：</p>
<pre><code><span class="keyword">typeof</span> Gadget.setPrice; <span class="comment">// "undefined"</span>
<span class="keyword">typeof</span> iphone.isShiny; <span class="comment">// "undefined"</span>
</code></pre><p>有时候让静态方法也能用在实例上会很方便。我们可以通过在原型上加一个新方法来很容易地做到这点，这个新方法作为原来的静态方法的一个包装：</p>
<pre><code>Gadget.prototype.isShiny = Gadget.isShiny<span class="comment">;</span>
iphone.isShiny()<span class="comment">; // "you bet"</span>
</code></pre><p>在这种情况下，你需要很小心地处理静态方法内的<code>this</code>。当你运行<code>Gadget.isShiny()</code>时，在<code>isShiny()</code>内部的<code>this</code>指向<code>Gadget</code>构造函数。而如果你运行<code>iphone.isShiny()</code>，那么<code>this</code>会指向<code>iphone</code>。</p>
<p>下面的例子展示了同一个方法被静态调用和非静态调用时明显不同的行为，这取决于调用的方式。这里的<code>instanceof</code>用于获取方法是如何被调用的：</p>
<pre><code><span class="comment">// 构造函数</span>
<span class="keyword">var</span> Gadget = <span class="function"><span class="keyword">function</span> <span class="params">(price)</span> </span>{
    <span class="keyword">this</span>.price = price;
};

<span class="comment">// 静态方法</span>
Gadget.isShiny = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{

    <span class="comment">// 这句始终正常工作</span>
    <span class="keyword">var</span> msg = <span class="string">"you bet"</span>;

    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Gadget) {
        <span class="comment">// 这句只有在非静态方式调用时正常工作</span>
        msg += <span class="string">", it costs $"</span> + <span class="keyword">this</span>.price + <span class="string">'!'</span>;
    }

    <span class="keyword">return</span> msg;
};

<span class="comment">// 原型上添加的方法</span>
Gadget.prototype.isShiny = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="keyword">return</span> Gadget.isShiny.call(<span class="keyword">this</span>);
};
</code></pre><p>测试一下静态方法调用：</p>
<pre><code>Gadget.isShiny(); <span class="comment">// "you bet"</span>
</code></pre><p>测试一下实例中的非静态调用：</p>
<pre><code><span class="keyword">var</span> a = <span class="keyword">new</span> Gadget(<span class="string">'499.99'</span>);
a.isShiny(); <span class="comment">// "you bet, it costs $499.99!"</span>
</code></pre><h3 id="私有静态成员">私有静态成员</h3><p>到目前为止，我们都只讨论了公有的静态方法，现在我们来看一下如何实现私有静态成员。所谓私有静态成员是指：</p>
<ul>
<li>被所有由同一构造函数创建的对象共享</li>
<li>不允许在构造函数外部访问</li>
</ul>
<p>我们来看一个例子，<code>counter</code>是<code>Gadget()</code>构造函数的一个私有静态属性。在本章中我们已经讨论过私有属性，这里的做法也是一样，需要一个函数提供的闭包来包裹私有成员。然后让这个包裹函数立即执行并返回一个新的函数。将这个返回的函数赋值给<code>Gadget()</code>作为构造函数。</p>
<pre><code><span class="keyword">var</span> Gadget = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{

    <span class="comment">// 静态变量/属性</span>
    <span class="keyword">var</span> counter = <span class="number">0</span>;

    <span class="comment">// 返回构造函数的新实现</span>
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
        <span class="built_in">console</span>.log(counter += <span class="number">1</span>);
    };

}()); <span class="comment">// 立即执行</span>
</code></pre><p>这个<code>Gadget()</code>构造函数只简单地增加私有变量<code>counter</code>的值然后打印出来。用多个实例测试的话你会看到<code>counter</code>在实例之间是共享的：</p>
<pre><code><span class="keyword">var</span> g1 = <span class="keyword">new</span> Gadget();<span class="comment">// logs 1</span>
<span class="keyword">var</span> g2 = <span class="keyword">new</span> Gadget();<span class="comment">// logs 2</span>
<span class="keyword">var</span> g3 = <span class="keyword">new</span> Gadget();<span class="comment">// logs 3</span>
</code></pre><p>因为我们在创建每个实例的时候<code>counter</code>的值都会加1，所以它实际上成了唯一标识使用<code>Gadget</code>构造函数创建的对象的ID。这个唯一标识可能会很有用，那为什么不把它通过一个特权方法暴露出去呢？（译注：严格来讲，这里不能叫ID，只是一个记录有多少个实例的数字而已，因为如果有多个实例被创建的话，没有办法取到除了最后一个之外的实例的标识。）下面的例子是基于前面的例子，增加了用于访问私有静态属性的<code>getLastId()</code>方法：</p>
<pre><code><span class="comment">// 构造函数</span>
<span class="keyword">var</span> Gadget = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{

    <span class="comment">// 静态变量/属性</span>
    <span class="keyword">var</span> counter = <span class="number">0</span>,
        NewGadget;

    <span class="comment">// 这将是Gadget的新实现</span>
    NewGadget = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        counter += <span class="number">1</span>;
    };

    <span class="comment">// 特权方法</span>
    NewGadget.prototype.getLastId = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        <span class="keyword">return</span> counter;
    };

    <span class="comment">// 重写构造函数</span>
    <span class="keyword">return</span> NewGadget;

}()); <span class="comment">// 立即执行</span>
</code></pre><p>测试这个新的实现：</p>
<pre><code><span class="keyword">var</span> iphone = <span class="keyword">new</span> Gadget(); 
iphone.getLastId(); <span class="comment">// 1</span>
<span class="keyword">var</span> ipod = <span class="keyword">new</span> Gadget(); 
ipod.getLastId(); <span class="comment">// 2</span>
<span class="keyword">var</span> ipad = <span class="keyword">new</span> Gadget(); 
ipad.getLastId(); <span class="comment">// 3</span>
</code></pre><p>静态属性（包括私有和公有）有时候会非常方便，它们可以包含和具体实例无关的方法和数据，而不用在每次实例中再创建一次。当我们在第七章中讨论单例模式时，你可以看到使用静态属性实现类式单例构造函数的例子。</p>
<h2 id="对象常量">对象常量</h2><p>在一些比较现代的环境中可能会提供<code>const</code>来创建常量，但在其它的环境中，JavaScript是没有常量的。</p>
<p>一种常用的解决办法是通过命名规范，让不应该变化的变量使用全大写。这个规范实际上也用在JavaScript原生对象中：</p>
<pre><code><span class="built_in">Math</span>.PI; <span class="comment">// 3.141592653589793</span>
<span class="built_in">Math</span>.SQRT2; <span class="comment">// 1.4142135623730951</span>
<span class="built_in">Number</span>.MAX_VALUE; <span class="comment">// 1.7976931348623157e+308</span>
</code></pre><p>你自己的常量也可以用这种规范，然后将它们作为静态属性加到构造函数中：</p>
<pre><code><span class="comment">// 构造函数</span>
<span class="keyword">var</span> Widget = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="comment">// 实现……</span>
};

<span class="comment">// 常量</span>
Widget.MAX_HEIGHT = <span class="number">320</span>;
Widget.MAX_WIDTH = <span class="number">480</span>;
</code></pre><p>同样的规范也适用于使用字面量创建的对象，常量会是使用大写名字的属性。</p>
<p>如果你真的希望有一个不能被改变的值，那么可以创建一个私有属性，然后提供一个取值的方法（getter），但不给赋值的方法（setter）。这种方法在很多可以用命名规范解决的情况下可能有些矫枉过正，但不失为一种选择。</p>
<p>下面是一个通用的<code>constant</code>对象的实现，它提供了这些方法：</p>
<ul>
<li><p>set(name, value)</p>
<p>  定义一个新的常量</p>
</li>
<li><p>isDefined(name)</p>
<p>  检查一个常量是否存在</p>
</li>
<li><p>get(name)</p>
<p>  取常量的值</p>
</li>
</ul>
<p>在这个实现中，只允许基本类型的值成为常量。同时还要使用<code>hasOwnProperty()</code>小心地处理那些恰好是原生属性的常量名，比如<code>toString</code>或者<code>hasOwnProperty</code>，然后给所有的常量名加上一个随机生成的前缀：</p>
<pre><code><span class="keyword">var</span> constant = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="keyword">var</span> constants = {},
        ownProp = Object.prototype.hasOwnProperty,
        allowed = {
            string: <span class="number">1</span>,
            number: <span class="number">1</span>,
            boolean: <span class="number">1</span>
        },
        prefix = (Math.random() + <span class="string">"_"</span>).slice(<span class="number">2</span>);
    <span class="keyword">return</span> {
        <span class="keyword">set</span>: <span class="function"><span class="keyword">function</span> <span class="params">(name, value)</span> </span>{
            <span class="keyword">if</span> (<span class="keyword">this</span>.isDefined(name)) {
                <span class="keyword">return</span> <span class="literal">false</span>;
            }
            <span class="keyword">if</span> (!ownProp.call(allowed, <span class="keyword">typeof</span> value)) {
                <span class="keyword">return</span> <span class="literal">false</span>;
            }
            constants[prefix + name] = value;
            <span class="keyword">return</span> <span class="literal">true</span>;
        },
        isDefined: <span class="function"><span class="keyword">function</span> <span class="params">(name)</span> </span>{
            <span class="keyword">return</span> ownProp.call(constants, prefix + name);
        },
        <span class="keyword">get</span>: <span class="function"><span class="keyword">function</span> <span class="params">(name)</span> </span>{
            <span class="keyword">if</span> (<span class="keyword">this</span>.isDefined(name)) {
                <span class="keyword">return</span> constants[prefix + name];
            }
            <span class="keyword">return</span> <span class="literal">null</span>;
        }
    };
}());
</code></pre><p>测试这个实现：</p>
<pre><code>// 检查是否定义
<span class="built_in">constant</span>.isDefined(<span class="string">"maxwidth"</span>);<span class="comment"> // false</span>
<span class="comment">
// 定义</span>
<span class="built_in">constant</span>.<span class="built_in">set</span>(<span class="string">"maxwidth"</span>, <span class="number">480</span>);<span class="comment"> // true</span>
<span class="comment">
// 再次检查</span>
<span class="built_in">constant</span>.isDefined(<span class="string">"maxwidth"</span>);<span class="comment"> // true</span>
<span class="comment">
// 尝试重定义</span>
<span class="built_in">constant</span>.<span class="built_in">set</span>(<span class="string">"maxwidth"</span>, <span class="number">320</span>);<span class="comment"> // false</span>
<span class="comment">
// 看看这个值是否被改变</span>
<span class="built_in">constant</span>.<span class="built_in">get</span>(<span class="string">"maxwidth"</span>);<span class="comment"> // 480</span>
</code></pre><h2 id="链式调用模式">链式调用模式</h2><p>使用链式调用模式可以让你在一对个象上连续调用多个方法，不需要将前一个方法的返回值赋给变量，也不需要将多个方法调用分散在多行：</p>
<pre><code><span class="tag">myobj</span><span class="class">.method1</span>("<span class="tag">hello</span>")<span class="class">.method2</span>()<span class="class">.method3</span>("<span class="tag">world</span>")<span class="class">.method4</span>();
</code></pre><p>当你创建了一个没有有意义的返回值的方法时，你可以让它返回<code>this</code>，也就是这些方法所属的对象。这使得对象的使用者可以将下一个方法的调用和前一次调用链起来：</p>
<pre><code><span class="keyword">var</span> obj = {
    value: <span class="number">1</span>,
    increment: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        <span class="keyword">this</span>.value += <span class="number">1</span>;
        <span class="keyword">return</span> <span class="keyword">this</span>;
    },
    add: <span class="function"><span class="keyword">function</span> <span class="params">(v)</span> </span>{
        <span class="keyword">this</span>.value += v;
        <span class="keyword">return</span> <span class="keyword">this</span>;
    },
    shout: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        alert(<span class="keyword">this</span>.value);
    }
};

<span class="comment">// 链式方法调用</span>
obj.increment().add(<span class="number">3</span>).shout(); <span class="comment">// 5</span>

<span class="comment">// 单独调用每个方法</span>
obj.increment();
obj.add(<span class="number">3</span>);
obj.shout(); <span class="comment">// 5</span>
</code></pre><h3 id="链式调用模式的利弊">链式调用模式的利弊</h3><p>使用链式调用模式的一个好处就是可以节省代码量，使得代码更加简洁和易读，读起来就像在读句子一样。</p>
<p>另外一个好处就是帮助你思考如何拆分你的函数，创建更小、更有针对性的函数，而不是一个什么都做的函数。长时间来看，这会提升代码的可维护性。</p>
<p>一个弊端是调试这样写的代码会更困难。你可能知道一个错误出现在某一行，但这一行要做很多的事情。当链式调用的方法中的某一个出现问题而又没报错时，你无法知晓到底是哪一个出问题了。《代码整洁之道》的作者Robert Martion甚至叫这种模式为“train wreck”模式。（译注：直译为“火车事故”，指负面影响比较大。）</p>
<p>不管怎样，认识这种模式总是好的，当你写的方法没有明显的有意义的返回值时，你就可以返回<code>this</code>。这个模式应用得很广泛，比如jQuery库。如果你去看DOM的API的话，你会发现它也会以这样的形式倾向于链式调用：</p>
<pre><code><span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(newnode);
</code></pre><h2 id="method()方法">method()方法</h2><p>JavaScript对于习惯于用类来思考的人来说可能会比较费解，这也是很多开发者希望将JavaScript代码变得更像基于类的语言的原因。其中的一种尝试就是由Douglas Crockford提出来的<code>method()</code>方法。其实，他也承认将JavaScript变得像基于类的语言是不推荐的方法，但不管怎样，这都是一种有意思的模式，你可能会在一些应用中见到。</p>
<p>使用构造函数就像Java中使用类一样。它也允许你在构造函数体的<code>this</code>中添加实例属性。但是在<code>this</code>中添加方法却是不高效的，因为最终这些方法会在每个实例中被重新创建一次，这样会花费更多的内存。这也是为什么可重用的方法应该被放到构造函数的<code>prototype</code>属性（原型）中的原因。但对很多开发者来说，<code>prototype</code>可能跟个外星人一样陌生，所以你可以通过一个方法将它隐藏起来。</p>
<blockquote>
<p>给语言添加一个使用起来更方便的方法一般叫作“语法糖”。在这个例子中，你可以将<code>method()</code>方法称为一个语法糖方法。</p>
</blockquote>
<p>使用这个语法糖方法<code>method()</code>来定义一个“类”是像这样：</p>
<pre><code><span class="keyword">var</span> <span class="type">Person</span> = function (name) {
    this.name = name;
}.
    <span class="keyword">method</span>('getName', function () {
        <span class="keyword">return</span> this.name;
    }).
    <span class="keyword">method</span>('setName', function (name) {
        this.name = name;
        <span class="keyword">return</span> this;
    });
</code></pre><p>注意构造函数和调用<code>method()</code>是如何链起来的，接下来又链式调用了下一个<code>method()</code>方法。这就是我们前面讨论的链式调用模式，可以帮助我们用一个语句完成对整个“类”的定义。</p>
<p><code>method()</code>方法接受两个参数：</p>
<ul>
<li>新方法的名字</li>
<li>新方法的实现</li>
</ul>
<p>然后这个新方法被添加到<code>Person</code>“类”。新方法的实现也只是一个函数，在这个函数里面<code>this</code>指向由<code>Person()</code>创建的对象，正如我们期望的那样。</p>
<p>下面是使用<code>Person()</code>创建和使用新对象的代码：</p>
<pre><code><span class="keyword">var</span> a = <span class="keyword">new</span> Person(<span class="string">'Adam'</span>);
a.getName(); <span class="comment">// 'Adam'</span>
a.setName(<span class="string">'Eve'</span>).getName(); <span class="comment">// 'Eve'</span>
</code></pre><p>同样地注意链式调用，因为<code>setName()</code>返回了<code>this</code>就可以链式调用了。</p>
<p>最后是<code>method()</code>方法的实现：</p>
<pre><code><span class="keyword">if</span> (typeof <span class="type">Function</span>.prototype.<span class="keyword">method</span> !== <span class="string">"function"</span>) {
    <span class="type">Function</span>.prototype.<span class="keyword">method</span> = function (name, implementation) {
        this.prototype[name] = implementation;
        <span class="keyword">return</span> this;
    };
}
</code></pre><p>在<code>method()</code>的实现中，我们首先检查这个方法是否已经被实现过，如果没有则继续，将传入的参数<code>implementation</code>加到构造函数的原型中。在这里<code>this</code>指向构造函数，而我们要增加的功能正好在这个构造函数的原型上。</p>
<h2 id="小结">小结</h2><p>在本章中你看到了好几种除了字面量和构造函数之外的创建对象的方法。</p>
<p>你看到了使用命名空间模式来保持全局空间干净和帮助组织代码，看到了简单而又有用的依赖声明模式。然后我们详细讨论了有关私有成员的模式，包括私有成员、特权方法以及一些涉及私有成员的极端情况，还有使用对象字面量创建私有成员以及将私有方法暴露为公有方法。所有这些模式都是搭建起现在流行而强大的模块模式的积木。</p>
<p>然后你看到了使用沙箱模式作为长命名空间的另一种选择，它可以为你的代码和模块提供独立的环境。</p>
<p>在最后，我们深入讨论了对象常量、静态成员（公有和私有）、链式调用模式，以及神奇的<code>method()</code>方法。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/06/javascript/javascript-patterns/chapter6/" itemprop="url">
                第六章 代码复用模式
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-06T22:08:29+08:00" content="2015-12-06">
            2015-12-06
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/12/06/javascript/javascript-patterns/chapter6/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/12/06/javascript/javascript-patterns/chapter6/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>代码复用是一个既重要又有趣的话题。如果你面对自己或者别人已经写好的代码，而这些代码又是经过测试的、可维护的、可扩展的、有文档的，这时候你只想写尽量少且可以被复用的代码就是一个再自然不过的想法。</p>
<p>当我们说到代码复用的时候，想到的第一件事就是继承，本章会有很大篇幅讲述这个话题，你将看到好多种方法来实现“类式（classical）”和一些其它方式的继承。但是，最最重要的事情，是你需要记住终极目标——代码复用。继承是达到这个目标的一种方法，但是不是唯一的。在本章，你将看到怎样基于其它对象来构建新对象，怎样使用混元，以及怎样在不使用继承的情况下只复用你需要的功能。</p>
<p>在做代码复用的工作的时候，谨记Gang of Four在书中给出的关于对象创建的建议：“优先使用对象创建而不是类继承”。（译注：《设计模式：可复用面向对象软件的基础》（Design Patterns: Elements of Reusable Object-Oriented Software）是一本设计模式的经典书籍，该书作者为Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides，被称为“Gang of Four”，简称“GoF”。）</p>
<h2 id="类式继承_vs_现代继承模式">类式继承 vs 现代继承模式</h2><p>在讨论JavaScript的继承这个话题的时候，经常会听到“类式继承”的概念，那我们先看一下什么是类式（classical）继承。classical一词并不是来自某些古老的、固定的或者是被广泛接受的解决方案，而仅仅是来自单词“class”。（译注：classical也有“经典”的意思。）</p>
<p>很多编程语言都有原生的类的概念，以此作为对象的蓝本。在这些语言中，每个对象都是一个指定类的实例（instance），并且（以Java为例）一个对象不能在不存在对应的类的情况下存在。在JavaScript中，因为没有类，所以类的实例的概念没什么意义。JavaScript的对象仅仅是简单的键值对，这些键值对都可以动态创建或者是改变。</p>
<p>但是JavaScript拥有构造函数（constructor functions），并且有语法和使用类非常相似的<code>new</code>运算符。</p>
<p>在Java中你可能会这样写：</p>
<pre><code><span class="keyword">Person</span> adam = new <span class="keyword">Person</span>();
</code></pre><p>在JavaScript中你可以这样：</p>
<pre><code><span class="keyword">var</span> adam = <span class="keyword">new</span> Person();
</code></pre><p>除了Java是强类型语言需要给<code>adam</code>添加类型<code>Person</code>外，其它的语法看起来是一样的。JavaScript的构造函数调用方式看起来让人感觉<code>Person()</code>是一个类，但事实上，<code>Person()</code>仅仅是一个函数。语法上的相似使得非常多的开发者陷入对JavaScript类的思考，并且给出了很多模拟类的继承方案。这样的实现方式，我们叫它“类式继承”。顺便也提一下，所谓“现代”继承模式是指那些不需要你去想类这个概念的模式。</p>
<p>当需要给项目选择一个继承模式时，有不少的备选方案。你应该尽量选择那些现代继承模式，除非团队已经觉得“无类不欢”。</p>
<p>本章先讨论类式继承，然后再关注现代继承模式。</p>
<h2 id="类式继承的期望结果">类式继承的期望结果</h2><p>实现类式继承的目标是基于构造函数<code>Child()</code>来创建一个对象，然后从另一个构造函数<code>Parent()</code>获得属性。</p>
<blockquote>
<p>尽管我们是在讨论类式继承，但还是尽量避免使用“类”这个词。“构造函数”或者“constructor”虽然更长，但是更准确，不会让人迷惑。通常情况下，应该努力避免在跟团队沟通的时候使用“类”这个词，因为在JavaScript中，很可能每个人都会有不同的理解。</p>
</blockquote>
<p>下面是定义两个构造函数<code>Parent()</code>和<code>Child()</code>的例子：</p>
<pre><code><span class="comment">//Parent构造函数</span>
<span class="function"><span class="keyword">function</span> <span class="title">Parent</span><span class="params">(name)</span> </span>{
    <span class="keyword">this</span>.name = name || <span class="string">'Adam'</span>;
}

<span class="comment">//给原型增加方法</span>
Parent.prototype.say = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="keyword">return</span> <span class="keyword">this</span>.name;
};

<span class="comment">//空的Child构造函数</span>
<span class="function"><span class="keyword">function</span> <span class="title">Child</span><span class="params">(name)</span> </span>{}

<span class="comment">//继承</span>
inherit(Child, Parent);
</code></pre><p>上面的代码定义了两个构造函数<code>Parent()</code>和<code>Child()</code>，<code>say()</code>方法被添加到了<code>Parent()</code>构建函数的原型（<code>prototype</code>）中，<code>inherit()</code>函数完成了继承的工作。<code>inherit()</code>函数并不是原生提供的，需要自己实现。让我们来看一看比较常见的实现它的几种方法。</p>
<h2 id="类式继承1——默认模式">类式继承1——默认模式</h2><p>最常用的一种模式是使用<code>Parent()</code>构造函数来创建一个对象，然后把这个对象设为<code>Child()</code>的原型。这是可复用的<code>inherit()</code>函数的第一种实现方法：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">inherit</span><span class="params">(C, P)</span> </span>{
    C.prototype = <span class="keyword">new</span> P();
}
</code></pre><p>需要强调的是原型（<code>prototype</code>属性）应该指向一个对象，而不是函数，所以它需要指向由被继承的构造函数创建的实例（对象），而不是构造函数自己。换句话说，请注意<code>new</code>运算符，有了它这种模式才可以正常工作。</p>
<p>之后在应用中使用<code>new Child()</code>创建对象的时候，它将通过原型拥有<code>Parent()</code>实例的功能，像下面的例子一样：</p>
<pre><code><span class="keyword">var</span> kid = <span class="keyword">new</span> Child();
kid.say(); <span class="comment">// "Adam"</span>
</code></pre><h3 id="跟踪原型链">跟踪原型链</h3><p>在这种模式中，子对象既继承了（父对象的）“自有属性”（添加给<code>this</code>的实例属性，比如<code>name</code>），也继承了原型中的属性和方法（比如<code>say()</code>）。</p>
<p>我们来看一下在这种继承模式中原型链是怎么工作的。为了讨论方便，我们假设对象是内存中的一块空间，它包含数据和指向其它空间的引用。当使用<code>new Parent()</code>创建一个对象时，这样的一块空间就被分配了（图6-1中的2号），它保存着<code>name</code>属性的数据。如果你尝试访问<code>say()</code>方法（比如通过<code>(new Parent).say()</code>），2号空间中并没有这个方法。但是在通过隐藏的链接<code>__proto__</code>指向<code>Parent()</code>构建函数的原型<code>prototype</code>属性时，就可以访问到包含<code>say()</code>方法的1号空间（<code>Parent.prototype</code>）了。所有的这一块都是在幕后发生的，不需要任何额外的操作，但是知道它是怎样工作的有助于让你明白你正在访问或者修改的数据在哪，这是很重要的。注意，<code>__proto__</code>在这里只是为了解释原型链而存在，这个属性在语言本身中是不可用的，尽管有一些环境提供了（比如Firefox）。</p>
<p><img src="./Figure/chapter6/6-1.jpg" alt="图6-1 Parent()构造函数的原型链"></p>
<p>图6-1 Parent()构造函数的原型链</p>
<p>现在我们来看一下在使用<code>inherit()</code>函数之后再使用<code>var kid = new Child()</code>创建一个新对象时会发生什么。见图6-2。</p>
<p><img src="./Figure/chapter6/6-2.jpg" alt="图6-2 继承后的原型链"></p>
<p>图6-2 继承后的原型链</p>
<p><code>Child()</code>构造函数是空的，也没有属性添加到<code>Child.prototype</code>上，这样，使用<code>new Child()</code>创建出来的对象都是空的，除了有隐藏的链接<code>__proto__</code>。在这个例子中，<code>__proto__</code>指向在<code>inherit()</code>函数中创建的<code>new Parent()</code>对象。</p>
<p>现在使用<code>kid.say()</code>时会发生什么？3号对象没有这个方法，所以通过原型链找到2号。2号对象也没有这个方法，所以也通过原型链找到1号，刚好有这个方法。接下来<code>say()</code>方法引用了<code>this.name</code>，这个变量也需要解析，于是沿原型链查找的过程又走了一遍。在这个例子中，<code>this</code>指向3号对象，它没有<code>name</code>属性，然后2号对象被访问，并且有<code>name</code>属性，值为“Adam”。</p>
<p>最后，我们看一点额外的东西，假如我们有如下的代码：</p>
<pre><code><span class="keyword">var</span> kid = <span class="keyword">new</span> Child();
kid.name = <span class="string">"Patrick"</span>;
kid.say(); <span class="comment">// "Patrick"</span>
</code></pre><p>图6-3展现了这个例子的原型链：</p>
<p><img src="./Figure/chapter6/6-3.jpg" alt="图6-3 继承并且给子对象添加属性后的原型链"></p>
<p>图6-3 继承并且给子对象添加属性后的原型链</p>
<p>设定<code>kid.name</code>并没有改变2号对象的<code>name</code>属性，但是却直接在3号对象上添加了自有的<code>name</code>属性。当<code>kid.say()</code>执行时，<code>say()</code>方法会依次在3号对象中找，然后是2号，最后到1号，像前面说的一样。但是这一次在找<code>this.name</code>（和<code>kid.name</code>一样）时很快，因为这个属性在3号对象中就被找到了。</p>
<p>如果通过<code>delete kid.name</code>的方式移除新添加的属性，那么2号对象的<code>name</code>属性就将被暴露出来并且在查找的时候被找到。</p>
<h3 id="这种模式的缺点">这种模式的缺点</h3><p>这种模式的一个缺点是既继承了（父对象的）“自有属性”，也继承了原型中的属性。大部分情况下你可能并不需要“自有属性”，因为它们更可能是为实例对象添加的，并不用于复用。</p>
<blockquote>
<p>一个在构造函数上常用的规则是，用于复用的成员（译注：属性和方法）应该被添加到原型上。</p>
</blockquote>
<p>在使用这个<code>inherit()</code>函数时另外一个不便是它不能够让你传参数给子构造函数，这些参数有可能是想再传给父构造函数的。考虑下面的例子：</p>
<pre><code><span class="keyword">var</span> s = <span class="keyword">new</span> Child(<span class="string">'Seth'</span>);
s.say(); <span class="comment">// "Adam"</span>
</code></pre><p>这并不是我们期望的结果。事实上传递参数给父构造函数是可能的，但这样需要在每次需要一个子对象时再做一次继承，很不方便，因为需要不断地创建父对象。</p>
<h2 id="类式继承2——借用构造函数">类式继承2——借用构造函数</h2><p>下面这种模式解决了从子对象传递参数到父对象的问题。它借用了父对象的构造函数，将子对象绑定到<code>this</code>，同时传入参数：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">a, c, b, d</span>) </span>{
    Parent.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);
}
</code></pre><p>使用这种模式时，只能继承在父对象的构造函数中添加到<code>this</code>的属性，不能继承原型上的成员。</p>
<p>使用借用构造函数的模式，子对象通过复制的方式继承父对象的成员，而不是像类式继承1中那样通过引用的方式。下面的例子展示了这两者的不同：</p>
<pre><code><span class="comment">//父构造函数</span>
<span class="function"><span class="keyword">function</span> <span class="title">Article</span><span class="params">()</span> </span>{
    <span class="keyword">this</span>.tags = [<span class="string">'js'</span>, <span class="string">'css'</span>];
}
<span class="keyword">var</span> article = <span class="keyword">new</span> Article();

<span class="comment">//BlogPost通过类式继承1（默认模式）从article继承</span>
<span class="function"><span class="keyword">function</span> <span class="title">BlogPost</span><span class="params">()</span> </span>{}
BlogPost.prototype = article;
<span class="keyword">var</span> blog = <span class="keyword">new</span> BlogPost();
<span class="comment">//注意你不需要使用`new Article()`，因为已经有一个实例了</span>

<span class="comment">//StaticPage通过借用构造函数的方式从Article继承</span>
<span class="function"><span class="keyword">function</span> <span class="title">StaticPage</span><span class="params">()</span> </span>{
    Article.call(<span class="keyword">this</span>);
}
<span class="keyword">var</span> page = <span class="keyword">new</span> StaticPage();

alert(article.hasOwnProperty(<span class="string">'tags'</span>)); <span class="comment">// true</span>
alert(blog.hasOwnProperty(<span class="string">'tags'</span>)); <span class="comment">// false</span>
alert(page.hasOwnProperty(<span class="string">'tags'</span>)); <span class="comment">// true</span>
</code></pre><p>在上面的代码片段中，<code>Article()</code>被用两种方式分别继承。默认模式使<code>blog</code>可以通过原型链访问到<code>tags</code>属性，所以它自己并没有<code>tags</code>属性，<code>hasOwnProperty()</code>返回<code>false</code>。<code>page</code>对象有自己的<code>tags</code>属性，因为它是使用借用构造函数的方式继承，复制（而不是引用）了<code>tags</code>属性。</p>
<p>注意在修改继承后的<code>tags</code>属性时的不同表现：</p>
<pre><code>blog.<span class="keyword">tags</span>.push(<span class="string">'html'</span>);
page.<span class="keyword">tags</span>.push(<span class="string">'php'</span>);
alert(article.<span class="keyword">tags</span>.<span class="built_in">join</span>(<span class="string">', '</span>)); // <span class="string">"js, css, html"</span>
</code></pre><p>在这个例子中，<code>blog</code>对象修改了<code>tags</code>属性，同时，它也修改了父对象，因为实际上<code>blog.tags</code>和<code>article.tags</code>是引向同一个数组。而对<code>pages.tags</code>的修改并不影响父对象<code>article</code>，因为<code>pages.tags</code>在继承的时候是一份独立的拷贝。</p>
<h3 id="原型链">原型链</h3><p>我们来看一下当我们使用熟悉的Parent()和Child()构造函数和这种继承模式时原型链是什么样的。为了使用这种继承模式，<code>Child()</code>有明显变化：</p>
<pre><code><span class="comment">//父构造函数</span>
<span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>{
    <span class="keyword">this</span>.name = name || <span class="string">'Adam'</span>;
}

<span class="comment">//在原型上添加方法</span>
Parent.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    <span class="keyword">return</span> <span class="keyword">this</span>.name;
};

<span class="comment">//子构造函数</span>
<span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>{
    Parent.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);
}

<span class="keyword">var</span> kid = <span class="keyword">new</span> Child(<span class="string">"Patrick"</span>);
    kid.name; <span class="comment">// "Patrick"</span>
<span class="keyword">typeof</span> kid.say; <span class="comment">// "undefined"</span>
</code></pre><p>如果看一下图6-4，就能发现<code>new Child()</code>对象和<code>Parent()</code>之间不再有链接。这是因为<code>Child.prototype</code>根本就没有被使用，它指向一个空对象。使用这种模式，<code>kid</code>拥有了自有的<code>name</code>属性，但是并没有继承<code>say()</code>方法，如果尝试调用它的话会出错。这种继承方式只是一种一次性地将父对象的属性复制为子对象的属性，并没有<code>__proto__</code>链接。</p>
<p><img src="./Figure/chapter6/6-4.jpg" alt="图6-4 使用借用构造函数模式时没有被关联的原型链"></p>
<p>图6-4 使用借用构造函数模式时没有被关联的原型链</p>
<h3 id="利用借用构造函数模式实现多继承">利用借用构造函数模式实现多继承</h3><p>使用借用构造函数模式，可以通过借用多个构造函数的方式来实现多继承：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>{
    <span class="keyword">this</span>.legs = <span class="number">4</span>;
    <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
        <span class="keyword">return</span> <span class="string">"meaowww"</span>;
    }
}

<span class="function"><span class="keyword">function</span> <span class="title">Bird</span>(<span class="params"></span>) </span>{
    <span class="keyword">this</span>.wings = <span class="number">2</span>;
    <span class="keyword">this</span>.fly = <span class="literal">true</span>;
}

<span class="function"><span class="keyword">function</span> <span class="title">CatWings</span>(<span class="params"></span>) </span>{
    Cat.apply(<span class="keyword">this</span>);
    Bird.apply(<span class="keyword">this</span>);
}

<span class="keyword">var</span> jane = <span class="keyword">new</span> CatWings();
<span class="built_in">console</span>.dir(jane);
</code></pre><p>结果如图6-5，任何重复的属性都会以最后的一个值为准。</p>
<p><img src="./Figure/chapter6/6-5.jpg" alt="图6-5 在Firebug中查看CatWings对象"></p>
<p>图6-5 在Firebug中查看CatWings对象</p>
<h3 id="借用构造函数的利与弊">借用构造函数的利与弊</h3><p>这种模式的一个明显的弊端就是无法继承原型。如前面所说，原型往往是添加可复用的方法和属性的地方，这样就不用在每个实例中再创建一遍。</p>
<p>这种模式的一个好处是获得了父对象自有成员的拷贝，不存在子对象意外改写父对象属性的风险。</p>
<p>那么，在上一个例子中，怎样使一个子对象也能够继承原型属性呢？怎样能使<code>kid</code>可以访问到<code>say()</code>方法呢？下一种继承模式解决了这个问题。</p>
<h2 id="类式继承3——借用并设置原型">类式继承3——借用并设置原型</h2><p>综合以上两种模式，首先借用父对象的构造函数，然后将子对象的原型设置为父对象的一个新实例：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">a, c, b, d</span>) </span>{
    Parent.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);
}
Child.prototype = <span class="keyword">new</span> Parent();
</code></pre><p>这样做的好处是子对象获得了父对象的自有成员，也获得了父对象中可复用的（在原型中实现的）方法。子对象也可以传递任何参数给父构造函数。这种行为可能是最接近Java的，子对象继承了父对象的所有东西，同时可以安全地修改自己的属性而不用担心修改到父对象。</p>
<p>一个弊端是父构造函数被调用了两次，所以不是很高效。最后，（父对象的）自有属性（比如这个例子中的<code>name</code>）也被继承了两次。</p>
<p>我们来看一下代码并做一些测试：</p>
<pre><code><span class="comment">//父构造函数</span>
<span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>{
    <span class="keyword">this</span>.name = name || <span class="string">'Adam'</span>;
}

<span class="comment">//在原型上添加方法</span>
Parent.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    <span class="keyword">return</span> <span class="keyword">this</span>.name;
};

<span class="comment">//子构造函数</span>
<span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>{
    Parent.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);
}
Child.prototype = <span class="keyword">new</span> Parent();

<span class="keyword">var</span> kid = <span class="keyword">new</span> Child(<span class="string">"Patrick"</span>);
kid.name; <span class="comment">// "Patrick"</span>
kid.say(); <span class="comment">// "Patrick"</span>
<span class="keyword">delete</span> kid.name;
kid.say(); <span class="comment">// "Adam"</span>
</code></pre><p>跟前一种模式不一样，现在<code>say()</code>方法被正确地继承了。可以看到<code>name</code>也被继承了两次，在删除掉自己的拷贝后，在原型链上的另一个就被暴露出来了。</p>
<p>图6-6展示了这些对象之间的关系。这些关系有点像图6-3中展示的，但是获得这种关系的方法是不一样的。</p>
<p><img src="./Figure/chapter6/6-6.jpg" alt="图6-6 除了继承“自己的属性”外，原型链也被保留了"></p>
<p>图6-6 除了继承“自己的属性”外，原型链也被保留了</p>
<h2 id="类式继承4——共享原型">类式继承4——共享原型</h2><p>不像前一种类式继承模式需要调用两次父构造函数，下面这种模式根本不会涉及到调用父构造函数的问题。</p>
<p>一般的经验是将可复用的成员放入原型中而不是<code>this</code>。从继承的角度来看，则是任何应该被继承的成员都应该放入原型中。这样你只需要设定子对象的原型和父对象的原型一样即可：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">inherit</span><span class="params">(C, P)</span> </span>{
    C.prototype = P.prototype;
}
</code></pre><p>这种模式的原型链很短并且查找很快，因为所有的对象实际上共享着同一个原型。但是这样也有弊端，那就是如果子对象或者在继承关系中的某个地方的任何一个子对象修改这个原型，将影响所有的继承关系中的父对象。（译注：指会影响到所有从这个原型中继承的对象所依赖的共享原型上的成员。）</p>
<p>如图6-7，子对象和父对象共享同一个原型，都可以访问<code>say()</code>方法。但是，子对象不继承<code>name</code>属性。</p>
<p><img src="./Figure/chapter6/6-7.jpg" alt="图6-7 （父子对象）共享原型时的关系"></p>
<p>图6-7 （父子对象）共享原型时的关系</p>
<h2 id="类式继承5——临时构造函数">类式继承5——临时构造函数</h2><p>下一种模式通过打断父对象和子对象原型的直接链接解决了共享原型时的问题，同时还从原型链中获得其它的好处。</p>
<p>下面是这种模式的一种实现方式，<code>F()</code>函数是一个空函数，它充当了子对象和父对象的代理。<code>F()</code>的<code>prototype</code>属性指向父对象的原型。子对象的原型是这个空函数的一个实例：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">inherit</span><span class="params">(C, P)</span> </span>{
    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{};
    F.prototype = P.prototype;
    C.prototype = <span class="keyword">new</span> F();
}
</code></pre><p>这种模式有一种和默认模式（类式继承1）明显不一样的行为，因为在这里子对象只继承原型中的属性（图6-8）。</p>
<p><img src="./Figure/chapter6/6-8.jpg" alt="图6-8 使用临时（代理）构造函数F()实现类式继承"></p>
<p>图6-8 使用临时（代理）构造函数F()实现类式继承</p>
<p>这种模式通常情况下都是一种很棒的选择，因为原型本来就是存放复用成员的地方。在这种模式中，父构造函数添加到<code>this</code>中的任何成员都不会被继承。</p>
<p>我们来创建一个子对象并且检查一下它的行为：</p>
<pre><code><span class="keyword">var</span> kid = <span class="keyword">new</span> Child();
</code></pre><p>如果你访问<code>kid.name</code>将得到<code>undefined</code>。在这个例子中，<code>name</code>是父对象自己的属性，而在继承的过程中我们并没有调用<code>new Parent()</code>，所以这个属性并没有被创建。当访问<code>kid.say()</code>时，它在3号对象中不可用，所以在原型链中查找，4号对象也没有，但是1号对象有，它在内存中的位置会被所有从<code>Parent()</code>创建的构造函数和子对象所共享。</p>
<h3 id="存储父类（Superclass）">存储父类（Superclass）</h3><p>在上一种模式的基础上，还可以添加一个指向原始父对象的引用。这很像其它语言中访问超类（superclass）的情况，有时候很方便。</p>
<p>我们将这个属性命名为“uber”，因为“super”是一个保留字，而“superclass”则可能误导别人认为JavaScript拥有类。下面是这种类式继承模式的一个改进版实现：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">inherit</span><span class="params">(C, P)</span> </span>{
    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{};
    F.prototype = P.prototype;
    C.prototype = <span class="keyword">new</span> F();
    C.uber = P.prototype;
}
</code></pre><h3 id="重置构造函数引用">重置构造函数引用</h3><p>这个近乎完美的模式上还需要做的最后一件事情就是重置构造函数（<code>constructor</code>）的指向，以便未来在某个时刻能被正确地使用。</p>
<p>如果不重置构造函数的指向，那所有的子对象都会认为<code>Parent()</code>是它们的构造函数，而这个结果完全没有用。使用前面的<code>inherit()</code>的实现，你可以观察到这种行为：</p>
<pre><code><span class="comment">// Parent，Child，实现继承</span>
<span class="function"><span class="keyword">function</span> <span class="title">Parent</span><span class="params">()</span> </span>{}
<span class="function"><span class="keyword">function</span> <span class="title">Child</span><span class="params">()</span> </span>{}
inherit(Child, <span class="keyword">Parent</span>);

<span class="comment">// 测试</span>
<span class="keyword">var</span> kid = <span class="keyword">new</span> Child();
kid.constructor.name; <span class="comment">// "Parent"</span>
kid.constructor === <span class="keyword">Parent</span>; <span class="comment">// true</span>
</code></pre><p><code>constructor</code>属性很少被用到，但是在运行时检查对象很方便。你可以重新将它指向期望的构造函数而不影响功能，因为这个属性更多是“信息性”的。（译注：即它更多的时候是在提供信息而不是参与到函数功能中。）</p>
<p>最终，这种类式继承的Holy Grail版本看起来是这样的：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">inherit</span><span class="params">(C, P)</span> </span>{
    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{};
    F.prototype = P.prototype;
    C.prototype = <span class="keyword">new</span> F();
    C.uber = P.prototype;
    C.prototype.constructor = C;
}
</code></pre><p>类似这样的函数也存在于YUI库（也许还有其它库）中，它将类式继承的方法带给了没有类的语言。如果你决定使用类式继承，那么这是最好的方法。</p>
<blockquote>
<p>“代理函数”或者“代理构造函数”也是指这种模式，因为临时构造函数是被用作获取父构造函数原型的代理。</p>
</blockquote>
<p>一种常见的对Holy Grail模式的优化是避免每次需要继承的时候都创建一个临时（代理）构造函数。事实上创建一次就足够了，以后只需要修改它的原型即可。你可以用一个即时函数来将代理函数存储到闭包中：</p>
<pre><code><span class="keyword">var</span> inherit = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{};
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(C, P)</span> </span>{
        F.prototype = P.prototype;
        C.prototype = <span class="keyword">new</span> F();
        C.uber = P.prototype;
        C.prototype.constructor = C;
    }
}());
</code></pre><h2 id="Klass">Klass</h2><p>有很多JavaScript类库模拟了类，创造了新的语法糖。这些类库具体的实现方式可能会不一样，但是基本上都有一些共性，包括：</p>
<ul>
<li>有一个约定好的方法，如<code>initialize</code>、<code>_init</code>或者其它相似的名字，会被自动调用，来充当类的构造函数</li>
<li>类可以从其它类继承</li>
<li>在子类中可以访问到父类（superclass）</li>
</ul>
<blockquote>
<p>我们在这里做一点变化，在本章的这部分自由地使用“class”这个词，因为主题就是模拟类。</p>
</blockquote>
<p>为避免讨论太多细节，我们来看一下JavaScript中一种模拟类的实现。首先，看一下这种方案将如何被使用？</p>
<pre><code><span class="keyword">var</span> Man = klass(<span class="literal">null</span>, {
    __construct: <span class="function"><span class="keyword">function</span> (<span class="params">what</span>) </span>{
        <span class="built_in">console</span>.log(<span class="string">"Man's constructor"</span>);
        <span class="keyword">this</span>.name = what;
    },
    getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
        <span class="keyword">return</span> <span class="keyword">this</span>.name;
    }
});
</code></pre><p>这种语法糖的形式是一个名为<code>klass()</code>的函数。在一些其它的实现方式中，它可能是<code>Klass()</code>构造函数或者是增强的<code>Object.prototype</code>，但是在这个例子中，我们让它只是一个简单的函数。</p>
<p>这个函数接受两个参数：一个被继承的类和通过对象字面量提供的新类的实现。受PHP的影响，我们约定类的构造函数必须是一个名为<code>__construct()</code>的方法。在前面的代码片段中，建立了一个名为<code>Man</code>的新类，并且它不继承任何类（意味着继承自<code>Object</code>）。<code>Man</code>类有一个在<code>__construct()</code>建立的自有属性<code>name</code>和一个方法<code>getName()</code>。这个类是一个构造函数，所以下面的代码将正常工作（并且看起来像类实例化的过程）：</p>
<pre><code>var <span class="keyword">first</span> = <span class="built_in">new</span> Man(<span class="string">'Adam'</span>);<span class="comment"> // logs "Man's constructor"</span>
<span class="keyword">first</span>.getName();<span class="comment"> // "Adam"</span>
</code></pre><p>现在我们来扩展这个类，创建一个<code>SuperMan</code>类：</p>
<pre><code><span class="keyword">var</span> SuperMan = klass(Man, {
    __construct: <span class="function"><span class="keyword">function</span> (<span class="params">what</span>) </span>{
        <span class="built_in">console</span>.log(<span class="string">"SuperMan's constructor"</span>);
    },
    getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
        <span class="keyword">var</span> name = SuperMan.uber.getName.call(<span class="keyword">this</span>);
        <span class="keyword">return</span> <span class="string">"I am "</span> + name;
    }
});
</code></pre><p>这里，<code>klass()</code>的第一个参数是将被继承的<code>Man</code>类。值得注意的是，在<code>getName()</code>中，父类的<code>getName()</code>方法首先通过<code>SuperMan</code>类的<code>uber</code>静态属性被调用。我们来测试一下：</p>
<pre><code><span class="keyword">var</span> clark = <span class="keyword">new</span> SuperMan(<span class="string">'Clark Kent'</span>);
clark.getName(); <span class="comment">// "I am Clark Kent"</span>
</code></pre><p>第一行在console中记录了“Man’s constructor”，然后是“Superman’s constructor”，在一些语言中，父类的构造函数在子类构造函数被调用的时候会自动执行，这个特性也被模拟了。</p>
<p>用<code>instanceof</code>运算符测试返回希望的结果：</p>
<pre><code>clark <span class="keyword">instanceof</span> Man; <span class="comment">// true</span>
clark <span class="keyword">instanceof</span> SuperMan; <span class="comment">// true</span>
</code></pre><p>最后，我们来看一下<code>klass()</code>函数是怎样实现的：</p>
<pre><code><span class="keyword">var</span> klass = <span class="function"><span class="keyword">function</span> (<span class="params">Parent, props</span>) </span>{

    <span class="keyword">var</span> Child, F, i;

    <span class="comment">// 1. 构造函数</span>
    Child = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
        <span class="keyword">if</span> (Child.uber &amp;&amp; Child.uber.hasOwnProperty(<span class="string">"__construct"</span>)) {
            Child.uber.__construct.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);
        }
        <span class="keyword">if</span> (Child.prototype.hasOwnProperty(<span class="string">"__construct"</span>)) {
            Child.prototype.__construct.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);
        }
    };

    <span class="comment">// 2. 继承</span>
    Parent = Parent || <span class="built_in">Object</span>;
    F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{};
    F.prototype = Parent.prototype;
    Child.prototype = <span class="keyword">new</span> F();
    Child.uber = Parent.prototype;
    Child.prototype.constructor = Child;

    <span class="comment">// 3. 添加方法实现</span>
    <span class="keyword">for</span> (i <span class="keyword">in</span> props) {
        <span class="keyword">if</span> (props.hasOwnProperty(i)) {
            Child.prototype[i] = props[i];
        }
    }

    <span class="comment">// 返回“类”</span>
    <span class="keyword">return</span> Child;
};
</code></pre><p>这个<code>klass()</code>实现有三个明显的部分：</p>
<ol>
<li>创建<code>Child()</code>构造函数，这也是最后返回的将被作为类使用的函数。在这个函数里面，如果<code>__construct()</code>方法存在的话将被调用，同样，如果父类的<code>__construct()</code>存在，也将被调用（通过使用静态属性<code>uber</code>）。也可能存在<code>uber</code>没有定义的情况——比如从<code>Object</code>继承，前例中<code>Man</code>类即是如此。</li>
<li>第二部分主要完成继承。只是简单地使用前面章节讨论过的Holy Grail类式继承模式。只有一个东西是新的：如果<code>Parent</code>没有传值的话，设定<code>Parent</code>为<code>Object</code>。</li>
<li>最后一部分是真正定义类的地方，遍历需要实现的方法（如例子中的<code>__constructor()</code>和<code>getName()</code>），并将它们添加到<code>Child()</code>的原型中。</li>
</ol>
<p>什么时候使用这种模式呢？其实，最好是能避免则避免，因为它带来了在这门语言中不存在的完整的类的概念，会让人疑惑。使用它需要学习新的语法和新的规则，也就是说，如果你或者你的团队习惯于使用类并且对原型感到不习惯，这种模式可能是一个可以探索的方向。这种模式允许你完全忘掉原型，好处就是你可以使用像其它语言那样的（变种）语法。</p>
<h2 id="原型继承">原型继承</h2><p>现在，让我们从一个叫作“原型继承”的模式来讨论没有类的现代继承模式。在这种模式中，没有任何类牵涉进来，一个对象继承自另外一个对象。你可以这样理解它：你有一个想复用的对象，然后你想创建第二个对象，并且获得第一个对象的功能。下面是这种模式的用法：</p>
<pre><code><span class="comment">// 需要继承的对象</span>
<span class="variable"><span class="keyword">var</span> parent</span> = {
    name: <span class="string">"Papa"</span>
};

<span class="comment">// 新对象</span>
<span class="variable"><span class="keyword">var</span> child</span> = <span class="keyword">object</span>(parent);

<span class="comment">// 测试</span>
alert(child.name); <span class="comment">// "Papa"</span>
</code></pre><p>在这个代码片段中，有一个已经存在的使用对象字面量创建的对象叫<code>parent</code>，我们想创建一个和<code>parent</code>有相同的属性和方法的对象叫<code>child</code>。<code>child</code>对象使用<code>object()</code>函数创建。这个函数在JavaScript中并不存在（不要与构造函数<code>Object()</code>混淆），所以我们来看看怎样定义它。</p>
<p>与Holy Grail类式继承相似，可以使用一个空的临时构造函数<code>F()</code>，然后设定<code>F()</code>的原型为<code>parent</code>对象。最后，返回一个临时构造函数的新实例。</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">object</span><span class="params">(o)</span> </span>{
    <span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span> </span>{}
    F.prototype = o;
    <span class="keyword">return</span> <span class="keyword">new</span> F();
}
</code></pre><p>图6-9展示了使用原型继承时的原型链。这样创建的<code>child</code>总是一个空对象，它没有自有属性但通过原型链（<code>__proto__</code>）拥有父对象的所有功能。</p>
<p><img src="./Figure/chapter6/6-9.jpg" alt="图6-9 原型继承模式"></p>
<p>图6-9 原型继承模式</p>
<h3 id="讨论">讨论</h3><p>在原型继承模式中，<code>parent</code>不一定需要使用对象字面量来创建（尽管这是一种常用的方式），也可以使用构造函数来创建。注意，如果你这样做，那么自有属性和原型上的属性都将被继承：</p>
<pre><code><span class="comment">// 父构造函数</span>
<span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">()</span> </span>{
    <span class="comment">// 自有属性</span>
    <span class="keyword">this</span>.name = <span class="string">"Adam"</span>;
}
<span class="comment">// 原型上的属性</span>
Person.prototype.getName = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="keyword">return</span> <span class="keyword">this</span>.name;
};

<span class="comment">// 使用Person()创建一个新对象</span>
<span class="keyword">var</span> papa = <span class="keyword">new</span> Person();
<span class="comment">// 继承</span>
<span class="keyword">var</span> kid = object(papa);

<span class="comment">// 测试：自有属性和原型上的属性都被继承了</span>
kid.getName(); <span class="comment">// "Adam"</span>
</code></pre><p>也可以使用这种模式的一个变种，只继承已存在的构造函数的原型对象。记住，对象继承自对象，而不管父对象是怎么创建的。这是前面例子的一个修改版本：</p>
<pre><code><span class="comment">// 父构造函数</span>
<span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">()</span> </span>{
    <span class="comment">// 自有属性</span>
    <span class="keyword">this</span>.name = <span class="string">"Adam"</span>;
}
<span class="comment">// 原型上的属性</span>
Person.prototype.getName = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{

};

<span class="comment">// 继承</span>
<span class="keyword">var</span> kid = object(Person.prototype);

<span class="keyword">typeof</span> kid.getName; <span class="comment">// "function"，因为它在原型中</span>
<span class="keyword">typeof</span> kid.name; <span class="comment">// "undefined"，因为只有原型中的成员被继承了</span>
</code></pre><h3 id="ECMAScript5中的原型继承">ECMAScript5中的原型继承</h3><p>在ECMAScript5中，原型继承已经正式成为语言的一部分。这种模式使用<code>Object.create()</code>方法来实现。换句话说，你不再需要自己去写类似<code>object()</code>的函数，它是语言原生的部分了：</p>
<pre><code><span class="keyword">var</span> child = <span class="built_in">Object</span>.create(parent);
</code></pre><p><code>Object.create()</code>接收一个额外的参数——一个对象。这个额外对象中的属性将被作为自有属性添加到返回的子对象中。这让我们可以很方便地将继承和创建子对象在一个方法调用中实现。例如：</p>
<pre><code><span class="keyword">var</span> child = Object.create(parent, {
    age: { <span class="keyword">value</span>: <span class="number">2</span> } <span class="comment">// ES5中的属性描述符</span>
});
child.hasOwnProperty(<span class="string">"age"</span>); <span class="comment">// true</span>
</code></pre><p>你可能也会发现原型继承模式已经在一些JavaScript类库中实现了，比如，在YUI3中，它是<code>Y.Object()</code>方法：</p>
<pre><code>YUI().<span class="keyword">use</span>(<span class="string">'*'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(Y)</span> </span>{
    <span class="keyword">var</span> child = Y.Object(<span class="keyword">parent</span>);
});
</code></pre><h2 id="通过复制属性继承">通过复制属性继承</h2><p>让我们来看一下另外一种继承模式——通过复制属性继承。在这种模式中，一个对象通过简单地复制另一个对象来获得功能。下面是一个简单的实现这种功能的<code>extend()</code>函数：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">extend</span><span class="params">(parent, child)</span> </span>{
    <span class="keyword">var</span> i;
    child = child || {};
    <span class="keyword">for</span> (i in <span class="keyword">parent</span>) {
        <span class="keyword">if</span> (<span class="keyword">parent</span>.hasOwnProperty(i)) {
            child[i] = <span class="keyword">parent</span>[i];
        }
    }
    <span class="keyword">return</span> child;
}
</code></pre><p>这是一个简单的实现，仅仅是遍历了父对象的成员然后复制它们。在这个实现中，<code>child</code>是可选参数，如果它没有被传入一个已有的对象，那么一个全新的对象将被创建并返回：</p>
<pre><code><span class="variable"><span class="keyword">var</span> dad</span> = {name: <span class="string">"Adam"</span>};
<span class="variable"><span class="keyword">var</span> kid</span> = extend(dad);
kid.name; <span class="comment">// "Adam"</span>
</code></pre><p>上面给出的实现叫作对象的“浅拷贝”（shallow copy），与之相对，“深拷贝”是指检查准备复制的属性本身是否是对象或者数组，如果是，也遍历它们的属性并复制。如果使用浅拷贝的话（因为在JavaScript中对象是按引用传递），如果你改变子对象的一个属性，而这个属性恰好是一个对象，那么你也会改变父对象。实际上这对方法来说可能很好（因为函数也是对象，也是按引用传递），但是当遇到其它的对象和数组的时候可能会有些意外情况。考虑这种情况：</p>
<pre><code>var dad = {
    counts: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],
    reads: {paper: <span class="literal">true</span>}
};
var kid = extend(dad);
kid.counts.push(<span class="number">4</span>);
dad.counts.toString(); <span class="comment">// "1,2,3,4"</span>
dad.reads === kid.reads; <span class="comment">// true</span>
</code></pre><p>现在让我们来修改一下<code>extend()</code>函数以便实现深拷贝。你需要做的事情只是检查一个属性的类型是否是对象，如果是，则递归遍历它的属性。另外一个需要做的检查是这个对象是真的对象还是数组，可以使用第三章讨论过的数组检查方式。最终深拷贝版的<code>extend()</code>是这样的：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">extendDeep</span><span class="params">(parent, child)</span> </span>{
    <span class="keyword">var</span> i,
        toStr = Object.prototype.toString,
        astr = <span class="string">"[object Array]"</span>;

    child = child || {};

    <span class="keyword">for</span> (i in <span class="keyword">parent</span>) {
        <span class="keyword">if</span> (<span class="keyword">parent</span>.hasOwnProperty(i)) {
            <span class="keyword">if</span> (typeof <span class="keyword">parent</span>[i] === <span class="string">"object"</span>) {
                child[i] = (toStr.call(<span class="keyword">parent</span>[i]) === astr) ? [] : {};
                extendDeep(<span class="keyword">parent</span>[i], child[i]);
            } <span class="keyword">else</span> {
                child[i] = <span class="keyword">parent</span>[i];
            }
        }
    }
    <span class="keyword">return</span> child;
}
</code></pre><p>现在测试时这个新的实现给了我们对象的真实拷贝，所以子对象不会修改父对象：</p>
<pre><code>var dad = {
    counts: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],
    reads: {paper: <span class="literal">true</span>}
};
var kid = extendDeep(dad);

kid.counts.push(<span class="number">4</span>);
kid.counts.toString(); <span class="comment">// "1,2,3,4"</span>
dad.counts.toString(); <span class="comment">// "1,2,3"</span>

dad.reads === kid.reads; <span class="comment">// false</span>
kid.reads.paper = <span class="literal">false</span>;
kid.reads.web = <span class="literal">true</span>;
dad.reads.paper; <span class="comment">// true</span>
</code></pre><p>通过复制属性继承的模式很简单且应用很广泛。例如Firebug（JavaScript写的Firefox扩展）有一个方法叫<code>extend()</code>做浅拷贝，jQuery的<code>extend()</code>方法做深拷贝。YUI3提供了一个叫作<code>Y.clone()</code>的方法，它创建一个深拷贝并且通过绑定到子对象的方式复制函数。（本章后面将有更多关于绑定的内容。）</p>
<p>这种模式并不高深，因为根本没有原型牵涉进来，而只跟对象和它们的属性有关。</p>
<h2 id="混元（Mix-ins）">混元（Mix-ins）</h2><p>既然谈到了通过复制属性来继承，就让我们顺便多说一点，来讨论一下“混元”模式。除了前面说的从一个对象复制，你还可以从任意多数量的对象中复制属性，然后将它们混在一起组成一个新对象。</p>
<p>实现很简单，只需要遍历传入的每个参数然后复制它们的每个属性：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">mix</span>(<span class="params"></span>) </span>{
    <span class="keyword">var</span> arg, prop, child = {};
    <span class="keyword">for</span> (arg = <span class="number">0</span>; arg &lt; <span class="built_in">arguments</span>.length; arg += <span class="number">1</span>) {
        <span class="keyword">for</span> (prop <span class="keyword">in</span> <span class="built_in">arguments</span>[arg]) {
            <span class="keyword">if</span> (<span class="built_in">arguments</span>[arg].hasOwnProperty(prop)) {
                child[prop] = <span class="built_in">arguments</span>[arg][prop];
            }
        }
    }
    <span class="keyword">return</span> child;
}
</code></pre><p>现在我们有了一个通用的混元函数，我们可以传递任意数量的对象进去，返回的结果将是一个包含所有传入对象属性的新对象。下面是用法示例：</p>
<pre><code>var cake = mix(
    {<span class="string">eggs:</span> <span class="number">2</span>, <span class="string">large:</span> <span class="literal">true</span>},
    {<span class="string">butter:</span> <span class="number">1</span>, <span class="string">salted:</span> <span class="literal">true</span>},
    {<span class="string">flour:</span> <span class="string">"3 cups"</span>},
    {<span class="string">sugar:</span> <span class="string">"sure!"</span>}
);
</code></pre><p>图6-10展示了在Firebug的控制台中用<code>console.dir(cake)</code>展示出来的混元后<code>cake</code>对象的属性。</p>
<p><img src="./Figure/chapter6/6-10.jpg" alt="图6-10 在Firebug中查看cake对象"></p>
<p>图6-10 在Firebug中查看cake对象</p>
<blockquote>
<p>如果你习惯了某些将混元作为原生部分的语言，那么你可能期望修改一个或多个父对象时也影响子对象。但在这个实现中这是不会发生的事情。这里我们只是简单地遍历、复制自有属性，并没有与父对象有任何链接。</p>
</blockquote>
<h2 id="借用方法">借用方法</h2><p>有时候会有这样的情况：你希望使用某个已存在的对象的一两个方法，你希望能复用它们，但是又真的不希望和那个对象产生继承关系，因为你只希望使用你需要的那一两个方法，而不继承那些你永远用不到的方法。得益于函数的<code>call()</code>和<code>apply()</code>方法，可以通过借用方法模式实现它。在本书中，你其实已经见过这种模式了，甚至在本章<code>extendDeep()</code>的实现中也有用到。</p>
<p>在JavaScript中函数也是对象，它们有一些有趣的方法，比如<code>call()</code>和<code>apply()</code>。这两个方法的唯一区别是后者接受一个参数数组以传入正在调用的方法，而前者只接受一个一个的参数。你可以使用这两个方法来从已有的对象中借用方法：</p>
<pre><code>// call()示例
<span class="label">notmyobj.doStuff.call</span>(myobj, param1, <span class="literal">p2</span>, <span class="literal">p3</span>)<span class="comment">;</span>
// apply()示例
<span class="label">notmyobj.doStuff.apply</span>(myobj, [param1, <span class="literal">p2</span>, <span class="literal">p3</span>])<span class="comment">;</span>
</code></pre><p>在这个例子中有一个对象<code>myobj</code>，而且<code>notmyobj</code>有一个用得着的方法叫<code>doStuff()</code>。你可以简单地临时借用<code>doStuff()</code>方法，而不用处理继承然后得到一堆<code>myobj</code>中无关的方法。</p>
<p>你传一个对象和任意的参数，这个被借用的方法会将<code>this</code>绑定到你传递的对象上。简单地说，你的对象会临时假装成另一个对象以使用它的方法。这就像实际上获得了继承但又免除了“继承税”（译注：指不需要的属性和方法）。</p>
<h3 id="例：从数组借用">例：从数组借用</h3><p>这种模式的一种常见用法是从数组借用方法。</p>
<p>数组有很多很有用但是一些“类数组”对象（如<code>arguments</code>）不具备的方法。所以<code>arguments</code>可以借用数组的方法，比如<code>slice()</code>。这是一个例子：</p>
<pre><code><span class="function">function <span class="title">f</span><span class="params">()</span> </span>{
    var args = [].slice.call(arguments, <span class="number">1</span>, <span class="number">3</span>);
    <span class="keyword">return</span> args;
}

<span class="comment">// 示例</span>
f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>); <span class="comment">// returns [2,3]</span>
</code></pre><p>在这个例子中，有一个空数组被创建了，因为要借用它的方法。也可以使用一种看起来代码更长的方法来做，那就是直接从数组的原型中借用方法，使用<code>Array.prototype.slice.call(...)</code>。这种方法代码更长一些，但是不用创建一个空数组。</p>
<h3 id="借用并绑定">借用并绑定</h3><p>当借用方法的时候，不管是通过<code>call()</code>/<code>apply()</code>还是通过简单的赋值，方法中的<code>this</code>指向的对象都是基于调用的表达式来决定的。但是有时候最好的使用方式是将<code>this</code>的值锁定或者提前绑定到一个指定的对象上。</p>
<p>我们来看一个例子。这是一个对象<code>one</code>，它有一个<code>say()</code>方法：</p>
<pre><code><span class="keyword">var</span> one = {
    name: <span class="string">"object"</span>,
    say: <span class="function"><span class="keyword">function</span> <span class="params">(greet)</span> </span>{
        <span class="keyword">return</span> greet + <span class="string">", "</span> + <span class="keyword">this</span>.name;
    }
};

<span class="comment">// 测试</span>
one.say(<span class="string">'hi'</span>); <span class="comment">// "hi, object"</span>
</code></pre><p>现在另一个对象<code>two</code>没有<code>say()</code>方法，但是它可以从one借用：</p>
<pre><code><span class="keyword">var</span> <span class="keyword">two</span> = {
    name: <span class="string">"another object"</span>
};

<span class="keyword">one</span>.say.apply(<span class="keyword">two</span>, ['hello']); <span class="comment">// "hello, another object"</span>
</code></pre><p>在这个例子中，<code>say()</code>方法中的<code>this</code>指向了<code>two</code>，<code>this.name</code>是“another object”。但是如果在某些场景下你将函数赋值给了全局变量或者是将这个函数作为回调，会发生什么？在客户端编程中有非常多的事件和回调，所以这种情况经常发生：</p>
<pre><code>// 赋值给变量，this会指向全局对象
<span class="keyword">var</span> say = one.say;
say('hoho'); // <span class="string">"hoho, undefined"</span>

// 作为回调
<span class="keyword">var</span> yetanother = {
    name: <span class="string">"Yet another object"</span>,
    <span class="keyword">method</span>: function (callback) {
        <span class="keyword">return</span> callback('<span class="type">Hola</span>');
    }
};
yetanother.<span class="keyword">method</span>(one.say); // <span class="string">"Holla, undefined"</span>
</code></pre><p>在这两种情况中<code>say()</code>中的<code>this</code>都指向了全局对象，所以代码并不像我们想象的那样正常工作。要修复（绑定）一个方法的对象，我们可以用一个简单的函数，像这样：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">o, m</span>) </span>{
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
        <span class="keyword">return</span> m.apply(o, [].slice.call(<span class="built_in">arguments</span>));
    };
}
</code></pre><p>这个<code>bind()</code>函数接受一个对象<code>o</code>和一个方法<code>m</code>，然后把它们绑定在一起，再返回另一个函数。返回的函数通过闭包可以访问到<code>o</code>和<code>m</code>，也就是说，即使在<code>bind()</code>返回之后，内层的函数仍然可以访问到<code>o</code>和<code>m</code>，而<code>o</code>和<code>m</code>会始终指向原来的对象和方法。让我们用<code>bind()</code>来创建一个新函数：</p>
<pre><code>var twosay = bind<span class="list">(<span class="keyword">two</span>, one.say)</span><span class="comment">;</span>
twosay<span class="list">(<span class="quoted">'yo</span>')</span><span class="comment">; // "yo, another object"</span>
</code></pre><p>正如你看到的，尽管<code>twosay()</code>是作为一个全局函数被创建的，但<code>this</code>并没有指向全局对象，而是指向了通过<code>bind()</code>传入的对象<code>two</code>。不论如何调用<code>twosay()</code>，<code>this</code>将始终指向<code>two</code>。</p>
<p>绑定是奢侈的，你需要付出的代价是一个额外的闭包。</p>
<h3 id="Function-prototype-bind()">Function.prototype.bind()</h3><p>ECMAScript5在<code>Function.prototype</code>中添加了一个方法叫<code>bind()</code>，使用时和<code>apply()</code>/<code>call()</code>一样简单。所以你可以这样写：</p>
<pre><code>var newFunc = obj.someFunc.bind(myobj, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);
</code></pre><p>这意味着将<code>someFunc()</code>和<code>myobj</code>绑定了,并且还传入了<code>someFunc()</code>的前三个参数。这也是一个在第4章讨论过的部分应用的例子。</p>
<p>让我们来看一下当你的程序跑在低于ES5的环境中时如何实现<code>Function.prototype.bind()</code>：</p>
<pre><code><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype.bind === <span class="string">"undefined"</span>) {
    <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">thisArg</span>) </span>{
        <span class="keyword">var</span> fn = <span class="keyword">this</span>,
        slice = <span class="built_in">Array</span>.prototype.slice,
        args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);

        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
            <span class="keyword">return</span> fn.apply(thisArg, args.concat(slice.call(<span class="built_in">arguments</span>)));
        };
    };
}
</code></pre><p>这个实现可能看起来有点熟悉，它使用了部分应用，将传入<code>bind()</code>的参数串起来（除了第一个参数），然后在被调用时传给<code>bind()</code>返回的新函数。这是用法示例：</p>
<pre><code>var twosay2 = one.<span class="keyword">say</span>.<span class="keyword">bind</span>(two);
twosay2(<span class="string">'Bonjour'</span>); <span class="regexp">//</span> <span class="string">"Bonjour, another object"</span>
</code></pre><p>在这个例子中，除了绑定的对象外，我们没有传任何参数给<code>bind()</code>。下一个例子中，我们来传一个用于部分应用的参数：</p>
<pre><code>var twosay3 = one.<span class="keyword">say</span>.<span class="keyword">bind</span>(two, <span class="string">'Enchanté'</span>);
twosay3(); <span class="regexp">//</span> <span class="string">"Enchanté, another object"</span>
</code></pre><p>##小结</p>
<p>在JavaScript中，继承有很多种方案可以选择，在本章中你看到了很多类式继承和现代继承的方案。学习和理解不同的模式是有好处的，因为这可以增强你对这门语言的掌握能力。</p>
<p>但是，也许在开发过程中继承并不是你经常面对的一个问题。一部分是因为这个问题已经被使用某种方式或者某个你使用的类库解决了，另一部分是因为你不需要在JavaScript中建立很长很复杂的继承链。在静态强类型语言中，继承可能是唯一可以复用代码的方法，但在JavaScript中有更多更简单更优化的方法，包括借用方法、绑定、复制属性、混元等。</p>
<p>记住，代码复用才是目标，继承只是达成这个目标的一种手段。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/06/javascript/javascript-patterns/chapter7/" itemprop="url">
                第七章 设计模式
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-06T22:08:29+08:00" content="2015-12-06">
            2015-12-06
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/12/06/javascript/javascript-patterns/chapter7/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/12/06/javascript/javascript-patterns/chapter7/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>在GoF（Gang of Four）的书中提出的设计模式为面向对象的软件设计中遇到的一些普遍问题提供了解决方案。它们已经诞生很久了，而且被证实在很多情况下是很有效的。这正是你需要熟悉它的原因，也是我们要讨论它的原因。</p>
<p>尽管这些设计模式跟语言和具体的实现方式无关，但它们多年来被关注到的方面仍然主要是在强类型静态语言比如C++和Java中的应用。</p>
<p>JavaScript作为一种基于原型的弱类型动态语言，有些时候实现某些模式时相当简单，甚至不费吹灰之力。</p>
<p>让我们从第一个例子——单例模式——来看一下在JavaScript中和静态的基于类的语言有什么不同。</p>
<h2 id="单例">单例</h2><p>单例模式的核心思想是让指定的类只存在唯一一个实例。这意味着当你第二次使用相同的类去创建对象的时候，你得到的应该和第一次创建的是同一个对象。</p>
<p>这如何应用到JavaScript中呢？在JavaScript中没有类，只有对象。当你创建一个对象时，事实上根本没有另一个对象和它一样，这个对象其实已经是一个单例。使用对象字面量创建一个简单的对象也是一种单例的例子：</p>
<pre><code><span class="keyword">var</span> obj = {
    myprop: <span class="string">'my value'</span>
};
</code></pre><p>在JavaScript中，对象永远不会相等，除非它们是同一个对象，所以即使你创建一个看起来完全一样的对象，它也不会和前面的对象相等：</p>
<pre><code>var obj2 = {
    <span class="symbol">myprop:</span> <span class="string">'my value'</span>
};
obj === obj2; <span class="regexp">//</span> <span class="keyword">false</span>
obj == obj2; <span class="regexp">//</span> <span class="keyword">false</span>
</code></pre><p>所以你可以说当你每次使用对象字面量创建一个对象的时候就是在创建一个单例，并没有什么特别的语法牵涉进来。</p>
<blockquote>
<p>需要注意的是，有的时候当人们在JavaScript中提出“单例”的时候，它们可能是在指第五章讨论过的“模块模式”。</p>
</blockquote>
<h3 id="使用new">使用new</h3><p>JavaScript没有类，所以一字一句地说单例的定义并没有什么意义。但是JavaScript有使用<code>new</code>、通过构造函数来创建对象的语法，有时候你可能需要这种语法下的一个单例实现。这也就是说当你使用<code>new</code>、通过同一个构造函数来创建多个对象的时候，你应该只是得到同一个对象的不同引用。</p>
<blockquote>
<p>温馨提示：从一个实用模式的角度来说，下面的讨论并不是那么有用，只是更多地在模拟一些语言中关于这个模式的一些问题的解决方案。这些语言主要是（静态强类型的）基于类的语言，在这些语言中，函数并不是“一等公民”。</p>
</blockquote>
<p>下面的代码片段展示了期望的结果（假设你忽略了多元宇宙的设想，接受了只有一个宇宙的观点）：</p>
<pre><code><span class="keyword">var</span> uni = <span class="keyword">new</span> Universe();
<span class="keyword">var</span> uni2 = <span class="keyword">new</span> Universe();
uni === uni2; <span class="comment">// true</span>
</code></pre><p>在这个例子中，<code>uni</code>只在构造函数第一次被调用时创建。第二次（以及后续更多次）调用时，同一个<code>uni</code>对象被返回。这就是为什么<code>uni === uni2</code>的原因——因为它们实际上是同一个对象的两个引用。那么怎么在JavaScript达到这个效果呢？</p>
<p>当对象实例<code>this</code>被创建时，你需要在<code>Universe()</code>构造函数中缓存它，以便在第二次调用的时候返回。有几种选择可以达到这种效果：</p>
<ul>
<li>你可以使用一个全局变量来存储实例。不推荐使用这种方法，因为通常我们认为使用全局变量是不好的。而且，任何人都可以改写全局变量的值，甚至可能是无意中改写。所以我们不再讨论这种方案。</li>
<li>你也可以将对象实例缓存在构造函数的属性中。在JavaScript中，函数也是对象，所以它们也可以有属性。你可以写一些类似<code>Universe.instance</code>的属性来缓存对象。这是一种漂亮干净的解决方案，不足之处是<code>instance</code>属性仍然是可以被公开访问的，别人写的代码可能修改它，这样就会失去这个实例。</li>
<li>你可以将实例包裹在闭包中。这可以保持实例是私有的，不会在构造函数之外被修改，代价是一个额外的闭包。</li>
</ul>
<p>让我们来看一下第二种和第三种方案的实现示例。</p>
<h3 id="将实例放到静态属性中">将实例放到静态属性中</h3><p>下面是一个将唯一的实例放入<code>Universe()</code>构造函数的一个静态属性中的例子：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Universe</span><span class="params">()</span> </span>{

    <span class="comment">// 实例是否已经存在？</span>
    <span class="keyword">if</span> (<span class="keyword">typeof</span> Universe.instance === <span class="string">"object"</span>) {
        <span class="keyword">return</span> Universe.instance;
    }

    <span class="comment">// 处理普通逻辑</span>
    <span class="keyword">this</span>.start_time = <span class="number">0</span>;
    <span class="keyword">this</span>.bang = <span class="string">"Big"</span>;

    <span class="comment">// 缓存实例</span>
    Universe.instance = <span class="keyword">this</span>;

    <span class="comment">// 隐式return：</span>
    <span class="comment">// return this;</span>
}

<span class="comment">// 测试</span>
<span class="keyword">var</span> uni = <span class="keyword">new</span> Universe();
<span class="keyword">var</span> uni2 = <span class="keyword">new</span> Universe();
uni === uni2; <span class="comment">// true</span>
</code></pre><p>如你所见，这是一种直接有效的解决方案，唯一的缺陷是<code>instance</code>是可被公开访问的。一般来说它被其它代码误删改的可能是很小的（起码比全局变量<code>instance</code>要小得多），但是仍然是有可能的。</p>
<h3 id="将实例放到闭包中">将实例放到闭包中</h3><p>另一种实现基于类的单例模式的方法是使用一个闭包来保护这个唯一的实例。你可以通过第五章讨论过的“私有静态成员模式”来实现。唯一的秘密就是重写构造函数：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Universe</span><span class="params">()</span> </span>{

    <span class="comment">// 缓存实例</span>
    <span class="keyword">var</span> instance = <span class="keyword">this</span>;

    <span class="comment">// 处理普通逻辑</span>
    <span class="keyword">this</span>.start_time = <span class="number">0</span>;
    <span class="keyword">this</span>.bang = <span class="string">"Big"</span>;

    <span class="comment">// 重写构造函数</span>
    Universe = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        <span class="keyword">return</span> instance;
    };
}

<span class="comment">// 测试</span>
<span class="keyword">var</span> uni = <span class="keyword">new</span> Universe();
<span class="keyword">var</span> uni2 = <span class="keyword">new</span> Universe();
uni === uni2; <span class="comment">// true</span>
</code></pre><p>第一次调用时，原来的构造函数被调用并且正常返回<code>this</code>。在后续的调用中，被重写的构造函数被调用。被重写的这个构造函数可以通过闭包访问私有的<code>instance</code>变量并且将它返回。</p>
<p>这个实现实际上也是第四章讨论的重定义函数的又一个例子。如我们讨论过的一样，这种模式的缺点是被重写的函数（在这个例子中就是构造函数<code>Universe()</code>）将丢失那些在初始定义和重新定义之间添加的属性。在这个例子中，任何添加到<code>Universe()</code>的原型上的属性将不会被链接到使用原来的实现创建的实例上。（注：这里的“原来的实现”是指实例是由未被重写的构造函数创建的，而<code>Universe()</code>则是被重写的构造函数。）</p>
<p>下面我们通过一些测试来展示这个问题：</p>
<pre><code><span class="comment">// 添加成员到原型</span>
Universe.prototype.nothing = <span class="keyword">true</span>;

<span class="keyword">var</span> uni = <span class="keyword">new</span> Universe();

<span class="comment">// 在创建一个对象后再添加成员到原型</span>
Universe.prototype.everything = <span class="keyword">true</span>;

<span class="keyword">var</span> uni2 = <span class="keyword">new</span> Universe();

<span class="comment">// 测试：</span>
<span class="comment">// 只有原始的原型被链接到对象上</span>
uni.nothing; <span class="comment">// true</span>
uni2.nothing; <span class="comment">// true</span>
uni.everything; <span class="comment">// undefined</span>
uni2.everything; <span class="comment">// undefined</span>

<span class="comment">// constructor看起来是对的</span>
uni.<span class="keyword">constructor</span>.name; <span class="comment">// "Universe"</span>

<span class="comment">// 但其实不然</span>
uni.<span class="keyword">constructor</span> === Universe; <span class="comment">// false</span>
</code></pre><p><code>uni.constructor</code>不再和<code>Universe()</code>相同的原因是<code>uni.constructor</code>仍然是指向原来的构造函数，而不是被重新定义的那个。</p>
<p>如果一定要让<code>prototype</code>和<code>constructor</code>的指向像我们期望的那样，可以通过一些调整来做到：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Universe</span><span class="params">()</span> </span>{

    <span class="comment">// 缓存实例</span>
    <span class="keyword">var</span> instance;

    <span class="comment">// 重写构造函数</span>
    Universe = <span class="function"><span class="keyword">function</span> <span class="title">Universe</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> instance;
    };

    <span class="comment">// 重写prototype属性</span>
    Universe.prototype = <span class="keyword">this</span>;

    <span class="comment">// 创建实例</span>
    instance = <span class="keyword">new</span> Universe();

    <span class="comment">// 重写constructor属性</span>
    instance.constructor = Universe;

    <span class="comment">// 其它的功能代码</span>
    instance.start_time = <span class="number">0</span>;
    instance.bang = <span class="string">"Big"</span>;

    <span class="keyword">return</span> instance;
}
</code></pre><p>现在所有的测试结果都可以像我们期望的那样了：</p>
<pre><code><span class="comment">// 修改原型，创建对象</span>
Universe.prototype.nothing = <span class="keyword">true</span>; <span class="comment">// true</span>
<span class="keyword">var</span> uni = <span class="keyword">new</span> Universe();
Universe.prototype.everything = <span class="keyword">true</span>; <span class="comment">// true</span>
<span class="keyword">var</span> uni2 = <span class="keyword">new</span> Universe();

<span class="comment">// 它们是同一个实例</span>
uni === uni2; <span class="comment">// true</span>

<span class="comment">// 所有的原型上的属性都正常工作，不管是什么时候在哪添加的</span>
uni.nothing &amp;&amp; uni.everything &amp;&amp; uni2.nothing &amp;&amp; uni2.everything; <span class="comment">// true</span>
<span class="comment">// 普通成员也可以正常工作</span>
uni.bang; <span class="comment">// "Big"</span>
<span class="comment">// constructor指向正确</span>
uni.<span class="keyword">constructor</span> === Universe; <span class="comment">// true</span>
</code></pre><p>另一种可选的解决方案是将构造函数和实例包在一个即时函数中。当构造函数第一次被调用的时候，它返回一个对象并且将私有的<code>instance</code>指向它。在后续调用时，构造函数只是简单地返回这个私有变量。在这种新的实现下，前面所有的测试代码也会和期望的一样：</p>
<pre><code><span class="keyword">var</span> Universe;

(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{

    <span class="keyword">var</span> instance;

    Universe = <span class="function"><span class="keyword">function</span> <span class="title">Universe</span><span class="params">()</span> </span>{

        <span class="keyword">if</span> (instance) {
            <span class="keyword">return</span> instance;
        }

        instance = <span class="keyword">this</span>;

        <span class="comment">// 功能代码</span>
        <span class="keyword">this</span>.start_time = <span class="number">0</span>;
        <span class="keyword">this</span>.bang = <span class="string">"Big"</span>;

    };

}());
</code></pre><h2 id="工厂模式">工厂模式</h2><p>使用工厂模式的目的就是创建对象。它通常被在类或者类的静态方法中实现，目的是：</p>
<ul>
<li>执行在建立相似的对象时进行的一些重复操作</li>
<li>让工厂的使用者在编译阶段创建对象时不必知道它的特定类型（类）</li>
</ul>
<p>第二点在静态的基于类的语言中更重要，因为在（编译阶段）提前不知道类的情况下，创建类的实例是一件多少有些特殊的行为。但在JavaScript中，这部分的实现却是相当容易的事情。</p>
<p>使用工厂方法（或类）创建的对象被设计为从同一个父对象继承；它们是实现一些特定的功能的子类。有些时候这个共同的父对象就是包含工厂方法的同一个类。</p>
<p>我们来看一个示例实现，我们有：</p>
<ul>
<li>一个共同的父构造函数<code>CarMaker()</code>。</li>
<li><code>CarMaker()</code>的一个静态方法叫<code>factory()</code>，用来创建<code>car</code>对象。</li>
<li>特定的从<code>CarMaker()</code>继承而来的构造函数<code>CarMaker.Compact()</code>，<code>CarMaker.SUV()</code>，<code>CarMaker.Convertible()</code>。它们都被定义为父构造函数的静态属性以便保持全局空间干净，同时在需要的时候我们也知道在哪里找到它们。</li>
</ul>
<p>我们来看一下已经完成的实现会怎么被使用：</p>
<pre><code><span class="keyword">var</span> corolla = CarMaker.<span class="literal">factory</span>(<span class="string">'Compact'</span>);
<span class="keyword">var</span> solstice = CarMaker.<span class="literal">factory</span>(<span class="string">'Convertible'</span>);
<span class="keyword">var</span> cherokee = CarMaker.<span class="literal">factory</span>(<span class="string">'SUV'</span>);
corolla.drive(); <span class="comment">// "Vroom, I have 4 doors"</span>
solstice.drive(); <span class="comment">// "Vroom, I have 2 doors"</span>
cherokee.drive(); <span class="comment">// "Vroom, I have 17 doors"</span>
</code></pre><p>这一段：</p>
<pre><code><span class="keyword">var</span> corolla = CarMaker.<span class="literal">factory</span>(<span class="string">'Compact'</span>);
</code></pre><p>可能是工厂模式中最为人熟知的。你有一个方法可以在运行时接受一个表示类型的字符串，然后它创建并返回了一个和请求的类型一样的对象。这里没有使用<code>new</code>的构造函数，也没有看到任何对象字面量，仅仅只有一个函数根据一个字符串指定的类型创建了对象。</p>
<p>这里是一个工厂模式的示例实现，它能让上面的代码片段工作：</p>
<pre><code><span class="comment">// 父构造函数</span>
<span class="function"><span class="keyword">function</span> <span class="title">CarMaker</span><span class="params">()</span> </span>{}

<span class="comment">// 父构造函数的方法</span>
CarMaker.prototype.drive = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="keyword">return</span> <span class="string">"Vroom, I have "</span> + <span class="keyword">this</span>.doors + <span class="string">" doors"</span>;
};

<span class="comment">// 静态工厂方法factory</span>
CarMaker.factory = <span class="function"><span class="keyword">function</span> <span class="params">(type)</span> </span>{
    <span class="keyword">var</span> constr = type,
        newcar;

    <span class="comment">// 如果指定类型的构造函数不存在则报错</span>
    <span class="keyword">if</span> (<span class="keyword">typeof</span> CarMaker[constr] !== <span class="string">"function"</span>) {
        <span class="keyword">throw</span> {
            name: <span class="string">"Error"</span>,
            message: constr + <span class="string">" doesn't exist"</span>
        };
    }

    <span class="comment">// 现在我们确认要用到的构造函数是存在的了</span>
    <span class="comment">// 让它继承自父构造函数，但只继承一次</span>
    <span class="keyword">if</span> (<span class="keyword">typeof</span> CarMaker[constr].prototype.drive !== <span class="string">"function"</span>) {
        CarMaker[constr].prototype = <span class="keyword">new</span> CarMaker();
    }
    <span class="comment">// 创建一个新实例</span>
    newcar = <span class="keyword">new</span> CarMaker[constr]();
    <span class="comment">// 这里可以选择性地调用一些方法，然后返回实例</span>
    <span class="keyword">return</span> newcar;
};

<span class="comment">// 创建特定类型的构造函数</span>
CarMaker.Compact = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="keyword">this</span>.doors = <span class="number">4</span>;
};
CarMaker.Convertible = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="keyword">this</span>.doors = <span class="number">2</span>;
};
CarMaker.SUV = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="keyword">this</span>.doors = <span class="number">24</span>;
};
</code></pre><p>工厂模式的实现中没有什么是特别困难的，你需要做的仅仅是寻找请求类型的对象构造函数。在这个例子中，使用了一个简单的名字转换以便映射对象类型和创建对象的构造函数。继承的部分只是一个公共的重复代码片段的示例，它可以被放到工厂方法中而不是被每个构造函数的类型所重复。（译注：指原型继承的代码可以在<code>factory()</code>方法以外执行，而不是放到<code>factory()</code>中每调用一次都要执行一次。）</p>
<h3 id="内置对象工厂">内置对象工厂</h3><p>为了说明工厂模式应用之广泛，我们来看一下内置的全局构造函数<code>Object()</code>。它的行为很像工厂，因为它根据不同的输入创建不同的对象。如果传入一个数字，它会使用<code>Number()</code>构造函数创建一个对象。在传入字符串和布尔值的时候也会发生类似的事情。任何其它的值（包括空值）将会创建一个正常的对象。</p>
<p>下面是这种行为的例子和测试，注意<code>Object()</code>调用时可以不用加<code>new</code>：</p>
<pre><code><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>(),
    n = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="number">1</span>),
    s = <span class="built_in">Object</span>(<span class="string">'1'</span>),
    b = <span class="built_in">Object</span>(<span class="literal">true</span>);

<span class="comment">// 测试</span>
o.constructor === <span class="built_in">Object</span>; <span class="comment">// true</span>
n.constructor === <span class="built_in">Number</span>; <span class="comment">// true</span>
s.constructor === <span class="built_in">String</span>; <span class="comment">// true</span>
b.constructor === <span class="built_in">Boolean</span>; <span class="comment">// true</span>
</code></pre><p><code>Object()</code>也是一个工厂这一事实可能没有太多实际用处，仅仅是觉得值得作为一个例子提一下，告诉我们工厂模式是随处可见的。</p>
<h2 id="遍历模式">遍历模式</h2><p>在遍历模式中，你有一些含有有序聚合数据的对象。这些数据可能在内部用一种复杂的结构存储着，但是你希望提供一种简单的方法来访问这种结构中的每个元素。数据的使用者不需要知道你是怎样组织你的数据的，他们只需要操作一个个独立的元素。</p>
<p>在遍历模式中，你的对象需要提供一个<code>next()</code>方法。按顺序调用<code>next()</code>方法必须返回序列中的下一个元素，但是“下一个”在你的特定的数据结构中指什么是由你自己来决定的。</p>
<p>假设你的对象叫<code>agg</code>，你可以通过简单地在循环中调用<code>next()</code>来访问每个数据元素，像这样：</p>
<pre><code>var <span class="literal">element</span>;
<span class="keyword">while</span> (<span class="literal">element</span> = agg.<span class="keyword">next</span>()) {
    // 访问element……
    console.log(element);
}
</code></pre><p>在遍历模式中，聚合对象通常也会提供一个方便的方法<code>hasNext()</code>，这样对象的使用者就可以知道他们已经获取到你数据的最后一个元素。当使用<code>hasNext()</code>来按顺序访问所有元素时，是像这样的：</p>
<pre><code><span class="keyword">while</span> (agg.hasNext()) {
    // 访问element……
    console.<span class="built_in">log</span>(agg.<span class="keyword">next</span>())<span class="comment">;</span>
}
</code></pre><h2 id="装饰模式">装饰模式</h2><p>在装饰模式中，一些额外的功能可以在运行时被动态地添加到一个对象中。在静态的基于类的语言中，处理这个问题可能是个挑战，但是在JavaScript中，对象本来就是可变的，所以给一个对象添加额外的功能本身并不是什么问题。</p>
<p>装饰模式的一个很方便的特性是可以对我们需要的特性进行定制和配置。刚开始时，我们有一个拥有基本功能的对象，然后可以从可用的装饰中去挑选一些需要用到的去增强这个对象，如果有必要的话，还可以指定增强的顺序。</p>
<h3 id="用法">用法</h3><p>我们来看一下这个模式的用法示例。假设你正在做一个卖东西的web应用，每个新交易是一个新的<code>sale</code>对象。这个对象“知道”交易的价格并且可以通过调用<code>sale.getPrice()</code>方法返回。根据环境的不同，你可以开始用一些额外的功能来装饰这个对象。假设一个场景是这笔交易是发生在加拿大的一个省Québec，在这种情况下，购买者需要付联邦税和Québec省税。根据装饰模式的用法，你需要指明使用联邦税装饰器和Québec省税装饰器来装饰这个对象。然后你还可以给这个对象装饰一些价格格式的功能。这个场景的使用方式可能是像这样：</p>
<pre><code><span class="keyword">var</span> sale = <span class="keyword">new</span> Sale(<span class="number">100</span>); <span class="comment">// 价格是100美元</span>
sale = sale.decorate(<span class="string">'fedtax'</span>); <span class="comment">// 加上联邦税</span>
sale = sale.decorate(<span class="string">'quebec'</span>); <span class="comment">// 加上省税</span>
sale = sale.decorate(<span class="string">'money'</span>); <span class="comment">// 格式化</span>
sale.getPrice(); <span class="comment">// "$112.88"</span>
</code></pre><p>在另一种场景下，购买者在一个不需要交省税的省，并且你想用加拿大元的格式来显示价格，你可以这样做：</p>
<pre><code><span class="keyword">var</span> sale = <span class="keyword">new</span> Sale(<span class="number">100</span>); <span class="comment">// 价格是100美元</span>
sale = sale.decorate(<span class="string">'fedtax'</span>); <span class="comment">// 加上联邦税</span>
sale = sale.decorate(<span class="string">'cdn'</span>); <span class="comment">// 用加拿大元格式化</span>
sale.getPrice(); <span class="comment">// "CDN$ 105.00"</span>
</code></pre><p>如你所见，这种方法可以在运行时很灵活地添加功能和调整对象。我们来看一下如何来实现这种模式。</p>
<h3 id="实现">实现</h3><p>一种实现装饰模式的方法是让每个装饰器成为一个拥有应该被重写的方法的对象。每个装饰器实际上是继承自已经被前一个装饰器增强过的对象。装饰器的每个方法都会调用父对象（继承自的对象）的同名方法并取得值，然后做一些额外的处理。</p>
<p>最终的效果就是当你在第一个例子中调用<code>sale.getPrice()</code>时，实际上是在调用<code>money</code>装饰器的方法（图7-1）。但是因为每个装饰器会先调用父对象的方法，<code>money</code>的<code>getPrice()</code>先调用<code>quebec</code>的<code>getPrice()</code>，而它又会去调用<code>fedtax</code>的<code>getPrice()</code>方法，依次类推。这个链会一直走到原始的未经装饰的由<code>Sale()</code>构造函数实现的<code>getPrice()</code>。</p>
<p><img src="./Figure/chapter7/7-1.jpg" alt="图7-1 装饰模式的实现"><br>图7-1 装饰模式的实现</p>
<p>这个实现以一个构造函数和一个原型方法开始：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Sale</span><span class="params">(price)</span> </span>{
    <span class="keyword">this</span>.price = price || <span class="number">100</span>;
}
Sale.prototype.getPrice = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="keyword">return</span> <span class="keyword">this</span>.price;
};
</code></pre><p>装饰器对象将都被作为构造函数的属性实现：</p>
<pre><code>Sale.decorators = {}<span class="comment">;</span>
</code></pre><p>我们来看一个装饰器的例子。这是一个对象，实现了一个自定义的<code>getPrice()</code>方法。注意这个方法首先从父对象的方法中取值然后修改这个值：</p>
<pre><code>Sale.decorators.fedtax = {
    getPrice: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        <span class="keyword">var</span> price = <span class="keyword">this</span>.uber.getPrice();
        price += price * <span class="number">5</span> / <span class="number">100</span>;
        <span class="keyword">return</span> price;
    }
};
</code></pre><p>使用类似的方法我们可以实现任意多个需要的装饰器。它们的实现方式像插件一样来扩展核心的<code>Sale()</code>的功能。它们甚至可以被放到额外的文件中，被第三方的开发者来开发和共享：</p>
<pre><code>Sale.decorators.quebec = {
    getPrice: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        <span class="keyword">var</span> price = <span class="keyword">this</span>.uber.getPrice();
        price += price * <span class="number">7.5</span> / <span class="number">100</span>;
        <span class="keyword">return</span> price;
    }
};

Sale.decorators.money = {
    getPrice: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="string">"$"</span> + <span class="keyword">this</span>.uber.getPrice().toFixed(<span class="number">2</span>);
    }
};

Sale.decorators.cdn = {
    getPrice: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="string">"CDN$ "</span> + <span class="keyword">this</span>.uber.getPrice().toFixed(<span class="number">2</span>);
    }
};
</code></pre><p>最后我们来看<code>decorate()</code>这个神奇的方法，它把所有上面说的片段都串起来了。记住它是这样被调用的：</p>
<pre><code><span class="setting">sale = <span class="value">sale.decorate(<span class="string">'fedtax'</span>);</span></span>
</code></pre><p>字符串<code>&#39;fedtax&#39;</code>对应在<code>Sale.decorators.fedtax</code>中实现的对象。被装饰过的最新的对象<code>newobj</code>将从现在有的对象（也就是<code>this</code>对象，它要么是原始的对象，要么是经过最后一个装饰器装饰过的对象）中继承。实现这一部分需要用到前面章节中提到的临时构造函数模式。我们也设置一个<code>uber</code>属性给<code>newobj</code>以便子对象可以访问到父对象。然后我们从装饰器中复制所有额外的属性到被装饰的对象<code>newobj</code>中。最后，在我们的例子中，<code>newobj</code>被返回并且成为被更新过的<code>sale</code>对象。</p>
<pre><code>Sale.prototype.decorate = <span class="function"><span class="keyword">function</span> <span class="params">(decorator)</span> </span>{
    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{},
        overrides = <span class="keyword">this</span>.constructor.decorators[decorator],
        i, newobj;
    F.prototype = <span class="keyword">this</span>;
    newobj = <span class="keyword">new</span> F();
    newobj.uber = F.prototype;
    <span class="keyword">for</span> (i <span class="keyword">in</span> overrides) {
        <span class="keyword">if</span> (overrides.hasOwnProperty(i)) {
            newobj[i] = overrides[i];
        }
    }
    <span class="keyword">return</span> newobj;
};
</code></pre><h3 id="使用列表实现">使用列表实现</h3><p>我们来看另一个明显不同的实现方法，得益于JavaScript的动态特性，它完全不需要使用继承。同时，我们也可以简单地将前一个方面的结果作为参数传给下一个方法，而不需要每一个方法都去调用前一个方法。</p>
<p>这样的实现方法还允许很容易地反装饰（undecorating）或者撤销一个装饰，这仅仅需要从一个装饰器列表中移除一个条目。</p>
<p>用法示例也会明显简单一些，因为我们不需要将<code>decorate()</code>的返回值赋值给对象。在这个实现中，<code>decorate()</code>不对对象做任何事情，它只是简单地将装饰器加入到一个列表中：</p>
<pre><code><span class="keyword">var</span> sale = <span class="keyword">new</span> Sale(<span class="number">100</span>); <span class="comment">// 价格是100美元</span>
sale.decorate(<span class="string">'fedtax'</span>); <span class="comment">// 加上联邦税</span>
sale.decorate(<span class="string">'quebec'</span>); <span class="comment">// 加上省税</span>
sale.decorate(<span class="string">'money'</span>); <span class="comment">// 格式化</span>
sale.getPrice(); <span class="comment">// "$112.88"</span>
</code></pre><p><code>Sale()</code>构造函数现在有了一个作为自己属性存在的装饰器列表：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Sale</span><span class="params">(price)</span> </span>{
    <span class="keyword">this</span>.price = price || <span class="number">100</span>;
    <span class="keyword">this</span>.decorators_list = [];
}
</code></pre><p>可用的装饰器仍然被实现为<code>Sale.decorators</code>的属性。注意<code>getPrice()</code>方法现在更简单了，因为它们不需要调用父对象的<code>getPrice()</code>来获取结果，结果已经作为参数传递给它们了：</p>
<pre><code>Sale.decorators = {};

Sale.decorators.fedtax = {
    getPrice: <span class="function"><span class="keyword">function</span> <span class="params">(price)</span> </span>{
        <span class="keyword">return</span> price + price * <span class="number">5</span> / <span class="number">100</span>;
    }
};

Sale.decorators.quebec = {
    getPrice: <span class="function"><span class="keyword">function</span> <span class="params">(price)</span> </span>{
        <span class="keyword">return</span> price + price * <span class="number">7.5</span> / <span class="number">100</span>;
    }
};

Sale.decorators.money = {
    getPrice: <span class="function"><span class="keyword">function</span> <span class="params">(price)</span> </span>{
        <span class="keyword">return</span> <span class="string">"$"</span> + price.toFixed(<span class="number">2</span>);
    }
};
</code></pre><p>最有趣的部分发生在父对象的<code>decorate()</code>和<code>getPrice()</code>方法上。在前一种实现方式中，<code>decorate()</code>还是多少有些复杂，而<code>getPrice()</code>十分简单。在这种实现方式中事情反过来了：<code>decorate()</code>只需要往列表中添加条目而<code>getPrice()</code>做了其它所有的工作，包括遍历现在添加的装饰器的列表，然后调用它们的<code>getPrice()</code>方法并将结果传递下去：</p>
<pre><code>Sale.prototype.decorate = <span class="function"><span class="keyword">function</span> <span class="params">(decorator)</span> </span>{
    <span class="keyword">this</span>.decorators_list.push(decorator);
};

Sale.prototype.getPrice = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="keyword">var</span> price = <span class="keyword">this</span>.price,
        i,
        max = <span class="keyword">this</span>.decorators_list.length,
        name;
    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; max; i += <span class="number">1</span>) {
        name = <span class="keyword">this</span>.decorators_list[i];
        price = Sale.decorators[name].getPrice(price);
    }
    <span class="keyword">return</span> price;
};
</code></pre><p>装饰模式的第二种实现方式更简单一些，并且没有引入继承。装饰的方法也会简单。所有的工作都由“同意”被装饰的方法来做。在这个示例实现中，<code>getPrice()</code>是唯一被允许装饰的方法。如果你想有更多可以被装饰的方法，那遍历装饰器列表的工作就需要由每个方法重复去做。但是，这可以很容易地被抽象到一个辅助方法中，给它传一个方法然后使这个方法“可被装饰”。如果这样实现的话，<code>decorators_list</code>属性就应该是一个对象，它的属性名字是方法名，值是装饰器对象的数组。</p>
<h2 id="策略模式">策略模式</h2><p>策略模式允许在运行的时候选择算法。你的代码的使用者可以在处理特定任务的时候根据即将要做的事情的上下文来从一些可用的算法中选择一个。</p>
<p>使用策略模式的一个例子是解决表单验证的问题。你可以创建一个<code>validator</code>对象，有一个<code>validate()</code>方法。这个方法被调用时不用区分具体的表单类型，它总是会返回同样的结果——一个没有通过验证的列表和错误信息。</p>
<p>但是根据具体的需要验证的表单和数据，你代码的使用者可以选择进行不同类别的检查。你的<code>validator</code>选择最佳的策略来处理这个任务，然后将具体的数据检查工作交给合适的算法去做。</p>
<h3 id="数据验证示例">数据验证示例</h3><p>假设你有一个下面这样的数据，它可能来自页面上的一个表单，你希望验证它是不是有效的数据：</p>
<pre><code><span class="variable"><span class="keyword">var</span> data</span> = {
    first_name: <span class="string">"Super"</span>,
    last_name: <span class="string">"Man"</span>,
    age: <span class="string">"unknown"</span>,
    username: <span class="string">"o_O"</span>
};
</code></pre><p>对这个例子中的<code>validator</code>而言，它需要知道哪个是最佳策略，因此你需要先配置它，给它设定好规则以确定哪些是有效的数据。</p>
<p>假设你不需要姓，名字可以接受任何内容，但要求年龄是一个数字，并且用户名只允许包含字母和数字。配置可能是这样的：</p>
<pre><code><span class="filename">validator.config = {
    first_name</span>: <span class="string">'isNonEmpty'</span>,
    age: <span class="string">'isNumber'</span>,
    username: <span class="string">'isAlphaNum'</span>
};
</code></pre><p>现在<code>validator</code>对象已经有了用来处理数据的配置，你可以调用<code>validate()</code>方法，然后将验证错误打印到控制台上：</p>
<pre><code>validat<span class="subst">or</span><span class="built_in">.</span>validate(<span class="built_in">data</span>);
<span class="keyword">if</span> (validat<span class="subst">or</span><span class="built_in">.</span>hasErrors()) {
    console<span class="built_in">.</span><span class="keyword">log</span>(validat<span class="subst">or</span><span class="built_in">.</span>messages<span class="built_in">.</span><span class="keyword">join</span>(<span class="string">"\n"</span>));
}
</code></pre><p>它可能会打印出这样的信息：</p>
<pre><code>Invalid <span class="built_in">value</span> <span class="keyword">for</span> *age*, <span class="operator">the</span> <span class="built_in">value</span> can only be <span class="operator">a</span> valid <span class="built_in">number</span>, e.g. <span class="number">1</span>, <span class="number">3.14</span> <span class="operator">or</span> <span class="number">2010</span>
Invalid <span class="built_in">value</span> <span class="keyword">for</span> *username*, <span class="operator">the</span> <span class="built_in">value</span> can only contain <span class="keyword">characters</span> <span class="operator">and</span> numbers, no special symbols
</code></pre><p>现在我们来看一下这个<code>validator</code>是如何实现的。所有可用的用来验证的逻辑都是拥有一个<code>validate()</code>方法的对象，它们还有一行辅助信息用来显示错误信息：</p>
<pre><code><span class="comment">// 验证空值</span>
validator.types.isNonEmpty = {
    validate: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>{
        <span class="keyword">return</span> value !== <span class="string">""</span>;
    },
    instructions: <span class="string">"the value cannot be empty"</span>
};

<span class="comment">// 验证数字</span>
validator.types.isNumber = {
    validate: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>{
        <span class="keyword">return</span> !<span class="built_in">isNaN</span>(value);
    },
    instructions: <span class="string">"the value can only be a valid number, e.g. 1, 3.14 or 2010"</span>
};

<span class="comment">// 验证是否只包含字母和数字</span>
validator.types.isAlphaNum = {
    validate: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>{
        <span class="keyword">return</span> !<span class="regexp">/[^a-z0-9]/i</span>.test(value);
    },
    instructions: <span class="string">"the value can only contain characters and numbers, no special symbols"</span>
};
</code></pre><p>最后，<code>validator</code>对象的核心是这样的：</p>
<pre><code><span class="keyword">var</span> validator = {

    <span class="comment">// 所有可用的验证类型</span>
    types: {},

    <span class="comment">// 本次验证所有的错误消息</span>
    messages: [],

    <span class="comment">// 本次验证的配置，格式为：</span>
    <span class="comment">// name: validation type</span>
    config: {},

    <span class="comment">// 接口方法</span>
    <span class="comment">// `data` 是名值对</span>
    validate: function (data) {

        <span class="keyword">var</span> i, msg, <span class="class"><span class="keyword">type</span>, <span class="title">checker</span>, <span class="title">result_ok</span>;</span>

        <span class="comment">// 重置所有的错误消息</span>
        <span class="keyword">this</span>.messages = [];
        <span class="keyword">for</span> (i in data) {

            <span class="keyword">if</span> (data.hasOwnProperty(i)) {

                <span class="class"><span class="keyword">type</span> =</span> <span class="keyword">this</span>.config[i];
                checker = <span class="keyword">this</span>.types[<span class="class"><span class="keyword">type</span>];</span>

                <span class="keyword">if</span> (!<span class="class"><span class="keyword">type</span>) {</span>
                    <span class="keyword">continue</span>; <span class="comment">// 不需要验证</span>
                }
                <span class="keyword">if</span> (!checker) { <span class="comment">// 没有对应的验证类型</span>
                    <span class="keyword">throw</span> {
                        name: <span class="string">"ValidationError"</span>,
                        message: <span class="string">"No handler to validate type "</span> + <span class="class"><span class="keyword">type</span>
</span>                    };
                }

                result_ok = checker.validate(data[i]);
                <span class="keyword">if</span> (!result_ok) {
                    msg = <span class="string">"Invalid value for *"</span> + i + <span class="string">"*, "</span> + checker.instructions;
                    <span class="keyword">this</span>.messages.push(msg);
                }
            }
        }
        <span class="keyword">return</span> <span class="keyword">this</span>.hasErrors();
    },

    <span class="comment">// 辅助方法</span>
    hasErrors: function () {
        <span class="keyword">return</span> <span class="keyword">this</span>.messages.length !== <span class="number">0</span>;
    }
};
</code></pre><p>如你所见，<code>validator</code>对象是通用的，在所有的需要验证的场景下都可以保持这个样子。改进它的办法就是增加更多类型的检查。如果你将它用在很多页面上，那么很快你就会有一个非常好的验证类型的集合。然后在新的使用场景下使用时你需要做的仅仅是配置<code>validator</code>然后调用<code>validate()</code>方法。</p>
<h2 id="外观模式">外观模式</h2><p>外观模式是一种很简单的模式，它只是为对象提供了更多的可供选择的接口。使方法保持短小而不是处理太多的工作是一种很好的实践。在这种实践的指导下，你会有一大堆的方法，而不是一个有着非常多参数的<code>uber</code>方法。有些时候，两个或者更多的方法会经常被一起调用。在这种情况下，创建另一个将这些重复调用包裹起来的方法就变得意义了。</p>
<p>例如，在处理浏览器事件的时候，有以下的方法：</p>
<ul>
<li><p><code>stopPropagation()</code></p>
<p>  阻止事件冒泡到父节点</p>
</li>
<li><p><code>preventDefault()</code></p>
<p>  阻止浏览器执行默认动作（如打开链接或者提交表单）</p>
</li>
</ul>
<p>这是两个有不同目的的相互独立的方法，他们也应该被保持独立，但与此同时，他们也经常被一起调用。所以为了不在应用中到处重复调用这两个方法，你可以创建一个外观方法来调用它们：</p>
<pre><code><span class="keyword">var</span> myevent =  {
    <span class="comment">// ……</span>
    stop: <span class="function"><span class="keyword">function</span> <span class="params">(e)</span> </span>{
        e.preventDefault();
        e.stopPropagation();
    }
    <span class="comment">// ……</span>
};
</code></pre><p>外观模式也适用于一些浏览器脚本的场景，即将浏览器的差异隐藏在一个外观方法下面。继续前面的例子，你可以添加一些处理IE中事件API的代码：</p>
<pre><code><span class="keyword">var</span> myevent =  {
    <span class="comment">// ……</span>
    stop: function (<span class="keyword">e</span>) {
        <span class="comment">// 其它浏览器</span>
        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">e</span>.preventDefault === <span class="string">"function"</span>) {
            <span class="keyword">e</span>.preventDefault();
        }
        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">e</span>.stopPropagation === <span class="string">"function"</span>) {
            <span class="keyword">e</span>.stopPropagation();
        }
        <span class="comment">// IE</span>
        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">e</span>.returnValue === <span class="string">"boolean"</span>) {
            <span class="keyword">e</span>.returnValue = false;
        }
        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">e</span>.cancelBubble === <span class="string">"boolean"</span>) {
            <span class="keyword">e</span>.cancelBubble = true;
        }
    }
    <span class="comment">// ……</span>
};
</code></pre><p>外观模式在做一些重新设计和重构工作时也很有用。当你想用一个不同的实现来替换某个对象的时候，你可能需要花相当长一段时间才能完成（一个复杂的对象），与此同时，一些使用这个新对象的代码也在被同步编写。你可以先想好新对象的API，然后在旧的对象前面使用新的API创建一个外观方法。使用这种方式，当你完全替换掉旧的对象的时候，你只需要修改少量的调用代码，因为新的代码已经是在使用新的API了。</p>
<h2 id="代理模式">代理模式</h2><p>在代理模式中，一个对象充当了另一个对象的接口的角色。它和外观模式不一样，外观模式带来的方便仅限于将几个方法调用联合起来。而代理对象位于某个对象和它的使用者之间，可以保护对对象的访问。</p>
<p>这个模式看起来开销有点大，但在出于性能考虑时非常有用。代理对象可以作为目标对象的保护者，让目标对象做尽量少的工作。</p>
<p>一种示例用法是“懒初始化”（延迟初始化）。假设负责初始化的对象是开销很大的，并且正好使用者将它初始化后并不真正使用它。在这种情况下，代理对象可以作为目标对象的接口起到帮助作用。代理对象接收到初始化请求，但在目标对象真正被使用之前都不会将请求传递过去。</p>
<p>图7-2展示了这个场景，当使用目标对象的代码发出初始化请求时，代理对象回复一切就绪，但并没有将请求传递过去，只有在真正需要目标对象做些工作的时候才将两个请求一起传递过去。</p>
<p><img src="./Figure/chapter7/7-2.jpg" alt="图7-2 通过代理对象时目标对象与使用者的关系"></p>
<p>图7-2 通过代理对象时目标对象与使用者的关系</p>
<h3 id="一个例子">一个例子</h3><p>在目标对象做某件工作开销很大时，代理模式很有用处。在web应用中，开销最大的操作之一就是网络请求，此时尽可能地合并HTTP请求是有意义的。我们来看一个这种场景下应用代理模式的实例。</p>
<h4 id="一个视频列表（expando）">一个视频列表（expando）</h4><p>我们假设有一个用来播放选中视频的应用。你可以在这里看到真实的例子<a href="http://www.jspatterns.com/book/7/proxy.html" target="_blank" rel="external">http://www.jspatterns.com/book/7/proxy.html</a>。</p>
<p>页面上有一个视频标题的列表，当用户点击视频标题的时候，标题下方的区域会展开并显示视频的更多信息，同时也使得视频可被播放。视频的详细信息和用来播放的URL并不是页面的一部分，它们需要通过网络请求来获取。服务端可以接受多个视频ID，这样我们就可以在合适的时候通过一次请求多个视频信息来减少HTTP请求以加快应用的速度。</p>
<p>我们的应用允许一次展开好几个（或全部）视频，所以这是一个合并网络请求的绝好机会。</p>
<p><img src="./Figure/chapter7/7-3.jpg" alt="图7-3 真实的视频列表"></p>
<p>图7-3 真实的视频列表</p>
<h4 id="没有代理对象的情况">没有代理对象的情况</h4><p>这个应用中最主要的角色是两个对象：</p>
<ul>
<li><p><code>videos</code></p>
<p>  负责对信息区域展开/收起（<code>videos.getInfo()</code>方法）和播放视频的响应（<code>videos.getPlayer()</code>方法）</p>
</li>
<li><p><code>http</code></p>
<p>  负责通过<code>http.makeRequest()</code>方法与服务端通讯</p>
</li>
</ul>
<p>当没有代理对象的时候，<code>videos.getInfo()</code>会为每个视频调用一次<code>http.makeRequest()</code>方法。当我们添加代理对象<code>proxy</code>后，它将位于<code>vidoes</code>和<code>http</code>中间，接手对<code>makeRequest()</code>的调用，并在可能的时候合并请求。</p>
<p>我们首先看一下没有代理对象的代码，然后添加代理对象来提升应用的响应速度。</p>
<h4 id="HTML">HTML</h4><p>HTML代码仅仅是一个链接列表：</p>
<pre><code><span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;<span class="title">span</span> <span class="attribute">id</span>=<span class="value">"toggle-all"</span>&gt;</span>Toggle Checked<span class="tag">&lt;/<span class="title">span</span>&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;<span class="title">ol</span> <span class="attribute">id</span>=<span class="value">"vids"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"checkbox"</span> <span class="attribute">checked</span>&gt;</span><span class="tag">&lt;<span class="title">a</span>
    <span class="attribute">href</span>=<span class="value">"http://new.music.yahoo.com/videos/--2158073"</span>&gt;</span>Gravedigger<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"checkbox"</span> <span class="attribute">checked</span>&gt;</span><span class="tag">&lt;<span class="title">a</span>
    <span class="attribute">href</span>=<span class="value">"http://new.music.yahoo.com/videos/--4472739"</span>&gt;</span>Save Me<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"checkbox"</span> <span class="attribute">checked</span>&gt;</span><span class="tag">&lt;<span class="title">a</span>
    <span class="attribute">href</span>=<span class="value">"http://new.music.yahoo.com/videos/--45286339"</span>&gt;</span>Crush<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"checkbox"</span> <span class="attribute">checked</span>&gt;</span><span class="tag">&lt;<span class="title">a</span>
    <span class="attribute">href</span>=<span class="value">"http://new.music.yahoo.com/videos/--2144530"</span>&gt;</span>Don't Drink The Water<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"checkbox"</span> <span class="attribute">checked</span>&gt;</span><span class="tag">&lt;<span class="title">a</span>
    <span class="attribute">href</span>=<span class="value">"http://new.music.yahoo.com/videos/--217241800"</span>&gt;</span>Funny the Way It Is<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"checkbox"</span> <span class="attribute">checked</span>&gt;</span><span class="tag">&lt;<span class="title">a</span>
    <span class="attribute">href</span>=<span class="value">"http://new.music.yahoo.com/videos/--2144532"</span>&gt;</span>What Would You Say<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ol</span>&gt;</span>
</code></pre><h4 id="事件处理">事件处理</h4><p>现在我们来看一下事件处理的逻辑。首先我们定义一个方便的快捷函数<code>$</code>：</p>
<pre><code><span class="keyword">var</span> $ = <span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>{
    <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(id);
};
</code></pre><p>使用事件代理（第八章有更多关于这个模式的内容），我们将所有<code>id=&quot;vids&quot;</code>的条目上的点击事件统一放到一个函数中处理：</p>
<pre><code>$('vids').onclick = function (<span class="keyword">e</span>) {
    <span class="keyword">var</span> src, id;

    <span class="keyword">e</span> = <span class="keyword">e</span> || <span class="keyword">window</span>.event;
    src = <span class="keyword">e</span>.target || <span class="keyword">e</span>.srcElement;

    <span class="keyword">if</span> (src.nodeName !== <span class="string">"A"</span>) {
        <span class="keyword">return</span>;
    }

    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">e</span>.preventDefault === <span class="string">"function"</span>) {
        <span class="keyword">e</span>.preventDefault();
    }
    <span class="keyword">e</span>.returnValue = false;

    id = src.href.<span class="keyword">split</span>('--')[1];

    <span class="keyword">if</span> (src.className === <span class="string">"play"</span>) {
        src.parentNode.innerHTML = videos.getPlayer(id);
        <span class="keyword">return</span>;
    }

    src.parentNode.id = <span class="string">"v"</span> + id;
    videos.getInfo(id);
};
</code></pre><h4 id="videos对象"><code>videos</code>对象</h4><p><code>videos</code>对象有三个方法：</p>
<ul>
<li><p><code>getPlayer()</code></p>
<p>  返回播放视频需要的HTML代码（跟我们讨论的无关）</p>
</li>
<li><p><code>updateList()</code></p>
<p>  网络请求的回调函数，接受从服务器返回的数据，然后生成用于视频详细信息的HTML代码。这一部分也没有什么需要关注的事情。</p>
</li>
<li><p><code>getInfo()</code></p>
<p>  这个方法切换视频信息的可视状态，同时也调用<code>http</code>对象的方法，并传递<code>updaetList()</code>作为回调函数。</p>
</li>
</ul>
<p>下面是这个对象的代码片段：</p>
<pre><code><span class="keyword">var</span> videos = {

    getPlayer: function (id) <span class="decorator">{...}</span>,
    updateList: function (data) <span class="decorator">{...}</span>,

    getInfo: function (id) {

        <span class="keyword">var</span> info = $('info' + id);

        <span class="keyword">if</span> (!info) {
            http.makeRequest([id], <span class="string">"videos.updateList"</span>);
            <span class="keyword">return</span>;
        }

        <span class="keyword">if</span> (info.style.display === <span class="string">"none"</span>) {
            info.style.display = '';
        } <span class="keyword">else</span> {
            info.style.display = 'none';
        }

    }
};
</code></pre><h4 id="http对象"><code>http</code>对象</h4><p><code>http</code>对象只有一个方法，它向Yahoo!的YQL服务发起一个JSONP请求：</p>
<pre><code><span class="keyword">var</span> http = {
    makeRequest: <span class="function"><span class="keyword">function</span> (<span class="params">ids, callback</span>) </span>{
        <span class="keyword">var</span> url = <span class="string">'http://query.yahooapis.com/v1/public/yql?q='</span>,
            sql = <span class="string">'select * from music.video.id where ids IN ("%ID%")'</span>,
            format = <span class="string">"format=json"</span>,
            handler = <span class="string">"callback="</span> + callback,
            script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);

        sql = sql.replace(<span class="string">'%ID%'</span>, ids.join(<span class="string">'","'</span>));
        sql = <span class="built_in">encodeURIComponent</span>(sql);

        url += sql + <span class="string">'&amp;'</span> + format + <span class="string">'&amp;'</span> + handler;
        script.src = url;

        <span class="built_in">document</span>.body.appendChild(script);
    }
};
</code></pre><blockquote>
<p>YQL（Yahoo! Query Language）是一种web service，它提供了使用类似SQL的语法来调用很多其它web service的能力，使得使用者不需要学习每个service的API。</p>
</blockquote>
<p>当所有的六个视频都被选中后，将会向服务端发起六个独立的像这样的YQL请求：</p>
<pre><code><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> music.video.<span class="keyword">id</span> <span class="keyword">where</span> ids <span class="keyword">IN</span> (<span class="string">"2158073"</span>)</span>
</code></pre><h4 id="代理对象">代理对象</h4><p>前面的代码工作得很好，但我们可以让它工作得更好。<code>proxy</code>对象就在这样的场景中出现，并接管了<code>http</code>和<code>videos</code>对象之间的通讯。它将使用一个简单的逻辑来尝试合并请求：50ms的延迟。<code>videos</code>对象并不直接调用后台接口，而是调用<code>proxy</code>对象的方法。<code>proxy</code>对象在转发这个请求前将会等待一段时间，如果在等待的50ms内有另一个来自<code>videos</code>的调用，则它们将被合并为同一个请求。50ms的延迟对用户来说几乎是无感知的，但是却可以用来合并请求以提升点击“toggle”时的体验，一次展开多个视频。它也可以显著降低服务器的负载，因为web服务器只需要处理更少量的请求。</p>
<p>合并后查询两个视频信息的YQL大概是这样：</p>
<pre><code><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> music.video.<span class="keyword">id</span> <span class="keyword">where</span> ids <span class="keyword">IN</span> (<span class="string">"2158073"</span>, <span class="string">"123456"</span>)</span>
</code></pre><p>在修改后的代码中，唯一的变化是<code>videos.getInfo()</code>现在调用的是<code>proxy.makeRequest()</code>而不是<code>http.makeRequest()</code>，像这样：</p>
<pre><code><span class="tag">proxy</span><span class="class">.makeRequest</span>(<span class="tag">id</span>, <span class="tag">videos</span><span class="class">.updateList</span>, <span class="tag">videos</span>);
</code></pre><p><code>proxy</code>对象创建了一个队列来收集50ms之内接受到的视频ID，然后将这个队列传递给<code>http</code>对象，并提供回调函数，因为<code>videos.updateList()</code>只能处理一个接收到的视频信息。</p>
<p>下面是<code>proxy</code>对象的代码：</p>
<pre><code><span class="keyword">var</span> proxy = {
    ids: [],
    delay: <span class="number">50</span>,
    timeout: <span class="literal">null</span>,
    <span class="keyword">callback</span>: <span class="literal">null</span>,
    context: <span class="literal">null</span>,
    makeRequest: <span class="function"><span class="keyword">function</span> <span class="params">(id, callback, context)</span> </span>{
        <span class="comment">// 添加到队列</span>
        <span class="keyword">this</span>.ids.push(id);

        <span class="keyword">this</span>.<span class="keyword">callback</span> = <span class="keyword">callback</span>;
        <span class="keyword">this</span>.context  = context;

        <span class="comment">// 设置延时</span>
        <span class="keyword">if</span> (!<span class="keyword">this</span>.timeout) {
            <span class="keyword">this</span>.timeout = setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
                proxy.flush();
            }, <span class="keyword">this</span>.delay);
        }
    },
    flush: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{

        http.makeRequest(<span class="keyword">this</span>.ids, <span class="string">"proxy.handler"</span>);

        <span class="comment">// 清除延时和队列</span>
        <span class="keyword">this</span>.timeout = <span class="literal">null</span>;
        <span class="keyword">this</span>.ids = [];

    },
    handler: <span class="function"><span class="keyword">function</span> <span class="params">(data)</span> </span>{
        <span class="keyword">var</span> i, max;

        <span class="comment">// 单个视频</span>
        <span class="keyword">if</span> (parseInt(data.query.count, <span class="number">10</span>) === <span class="number">1</span>) {
            proxy.<span class="keyword">callback</span>.call(proxy.context, data.query.results.Video);
            <span class="keyword">return</span>;
        }

        <span class="comment">// 多个视频</span>
        <span class="keyword">for</span> (i = <span class="number">0</span>, max = data.query.results.Video.length; i &lt; max; i += <span class="number">1</span>) {
            proxy.<span class="keyword">callback</span>.call(proxy.context, data.query.results.Video[i]);
        }
    }
};
</code></pre><p>使用代理模式可以在只改动一处原来代码的情况下，将多个web service请求合并为一个。</p>
<p>图7-4和7-5展示了使用代理模式将与服务器三次数据交互（不用代理模式时）变为一次交互的过程。</p>
<p><img src="./Figure/chapter7/7-4.jpg" alt="图7-4 与服务器三次数据交互"></p>
<p>图7-4 与服务器三次数据交互</p>
<p><img src="./Figure/chapter7/7-5.jpg" alt="图7-5 通过一个代理对象合并请求，减少与服务器数据交互"></p>
<p>图7-5 通过一个代理对象合并请求，减少与服务器数据交互</p>
<h3 id="使用代理对象做缓存">使用代理对象做缓存</h3><p>在这个例子中，目标对象的使用者（<code>videos</code>）已经可以做到不对同一个对象重复发出请求，但现实情况中并不总是这样。其实这个代理对象还可以通过缓存之前的请求结果到<code>cache</code>属性中来进一步保护<code>http</code>对象（图7-6）。然后当<code>videos</code>对象需要对同一个ID的视频请求第二次时，<code>proxy</code>对象可以直接从缓存中取出，从而避免一次网络交互。</p>
<p><img src="./Figure/chapter7/7-6.jpg" alt="图7-6 代理缓存"></p>
<p>图7-6 代理缓存</p>
<h2 id="中介者模式">中介者模式</h2><p>一个应用不论大小，都是由一些彼此独立的对象组成的。所有的对象都需要一个通讯方式来保持可维护性，即你可以安全地修改应用的一部分而不破坏其它部分。随着应用的开发和维护，会有越来越多的对象。然后，在重构代码的时候，对象可能会被移除或者被重新设计。当对象知道其它对象的太多信息并且直接通讯（直接调用彼此的方法或者修改属性）时，会导致我们不愿意看到的紧耦合。当对象耦合很紧时，要修改一个对象而不影响其它的对象是很困难的。此时甚至连一个最简单的修改都变得不那么容易，甚至连一个修改需要用多长时间都难以评估。</p>
<p>中介者模式就是一个缓解此问题的办法，它通过解耦来提升代码的可维护性（见图7-7）。在这个模式中，各个彼此合作的对象并不直接通讯，而是通过一个<code>mediator</code>（中介者）对象通讯。当一个对象改变了状态后，它就通知中介者，然后中介者再将这个改变告知给其它应该知道这个变化的对象。</p>
<p><img src="./Figure/chapter7/7-7.jpg" alt="图7-7 中介者模式中的对象关系"></p>
<p>图7-7 中介者模式中的对象关系</p>
<h3 id="中介者示例">中介者示例</h3><p>我们来看一个使用中介者模式的实例。这个应用是一个游戏，它的玩法是比较两位游戏者在半分钟内按下按键的次数，次数多的获胜。玩家1需要按的是1，玩家2需要按的是0（这样他们的手指不会搅在一起）。当前分数会显示在一个计分板上。</p>
<p>对象列表如下：</p>
<ul>
<li><code>Player1</code></li>
<li><code>Player2</code></li>
<li><code>Scoreboard</code></li>
<li><code>Mediator</code></li>
</ul>
<p>中介者<code>Mediator</code>知道所有的对象，它与输入设备（键盘）打交道，处理<code>keypress</code>事件，决定现在是哪位玩家玩的，然后通知这个玩家（见图7-8）。玩家负责玩（即给自己的分数加一分），然后通知中介者他这一轮已经玩完。中介者再告知计分板最新的分数，计分板更新显示。</p>
<p>除了中介者之外，其它的对象都不知道有别的对象存在。这样就使得更新这个游戏变得很简单，比如要添加一位玩家或者是添加另外一个显示剩余时间的地方。</p>
<p>你可以在这里看到这个游戏的在线演示<a href="http://jspatterns.com/book/7/mediator.html" target="_blank" rel="external">http://jspatterns.com/book/7/mediator.html</a>。</p>
<p><img src="./Figure/chapter7/7-8.jpg" alt="图7-8 游戏涉及的对象"></p>
<p>图7-8 游戏涉及的对象</p>
<p>玩家对象是通过<code>Player()</code>构造函数来创建的，有自己的<code>points</code>和<code>name</code>属性。原型上的<code>play()</code>方法负责给自己加一分然后通知中介者：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Player</span><span class="params">(name)</span> </span>{
    <span class="keyword">this</span>.points = <span class="number">0</span>;
    <span class="keyword">this</span>.name = name;
}
Player.prototype.play = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="keyword">this</span>.points += <span class="number">1</span>;
    mediator.played();
};
</code></pre><p><code>scoreboard</code>对象（计分板）有一个<code>update()</code>方法，它会在每次玩家玩完后被中介者调用。计分板根本不知道玩家的任何信息，也不保存分数，它只负责显示中介者给过来的分数：</p>
<pre><code><span class="keyword">var</span> scoreboard = {

    <span class="comment">// 被更新的HTML元素</span>
    element: <span class="built_in">document</span>.getElementById(<span class="string">'results'</span>),

    <span class="comment">// 更新分数显示</span>
    update: <span class="function"><span class="keyword">function</span> (<span class="params">score</span>) </span>{

        <span class="keyword">var</span> i, msg = <span class="string">''</span>;
        <span class="keyword">for</span> (i <span class="keyword">in</span> score) {

            <span class="keyword">if</span> (score.hasOwnProperty(i)) {
                msg += <span class="string">'&lt;p&gt;&lt;strong&gt;'</span> + i + <span class="string">'&lt;\/strong&gt;: '</span>;
                msg += score[i];
                msg += <span class="string">'&lt;\/p&gt;'</span>;
            }
        }
        <span class="keyword">this</span>.element.innerHTML = msg;
    }
};
</code></pre><p>现在我们来看一下<code>mediator</code>对象（中介者）。在游戏初始化的时候，在<code>setup()</code>方法中创建玩家，然后放入<code>players</code>属性以便后续使用。<code>played()</code>方法会被玩家在每轮玩完后调用，它更新<code>score</code>哈希然表然后将它传给<code>scoreboard</code>用于显示。最后一个方法是<code>keypress()</code>，负责处理键盘事件，决定是哪位玩家玩的，并且通知它：</p>
<pre><code><span class="keyword">var</span> mediator = {

    <span class="comment">// 所有的玩家</span>
    players: {},

    <span class="comment">// 初始化</span>
    setup: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
        <span class="keyword">var</span> players = <span class="keyword">this</span>.players;
        players.home = <span class="keyword">new</span> Player(<span class="string">'Home'</span>);
        players.guest = <span class="keyword">new</span> Player(<span class="string">'Guest'</span>);

    },

    <span class="comment">// 玩家玩完后更新分数</span>
    played: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
        <span class="keyword">var</span> players = <span class="keyword">this</span>.players,
        score = {
            Home: players.home.points,
            Guest: players.guest.points
        };

        scoreboard.update(score);
    },

    <span class="comment">// 处理用户交互</span>
    keypress: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>{
        e = e || <span class="built_in">window</span>.event; <span class="comment">// IE</span>
        <span class="keyword">if</span> (e.which === <span class="number">49</span>) { <span class="comment">// 按键“1”</span>
            mediator.players.home.play();
            <span class="keyword">return</span>;
        }
        <span class="keyword">if</span> (e.which === <span class="number">48</span>) { <span class="comment">// 按键“0”</span>
            mediator.players.guest.play();
            <span class="keyword">return</span>;
        }
    }
};
</code></pre><p>最后一件事是初始化和结束游戏：</p>
<pre><code><span class="comment">// 开始</span>
mediator.setup();
<span class="built_in">window</span>.onkeypress = mediator.keypress;

<span class="comment">// 游戏在30秒后结束</span>
setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    <span class="built_in">window</span>.onkeypress = <span class="literal">null</span>;
    alert(<span class="string">'Game over!'</span>);
}, <span class="number">30000</span>);
</code></pre><h2 id="观察者模式">观察者模式</h2><p>观察者模式被广泛地应用于JavaScript客户端编程中。所有的浏览器事件（<code>mouseover</code>，<code>keypress</code>等）都是使用观察者模式的例子。这种模式的另一个名字叫“自定义事件”，意思是这些事件是被编写出来的，和浏览器触发的事件相对。它还有另外一个名字叫“订阅者/发布者”模式（Pub/Sub）。</p>
<p>使用这个模式的最主要目的就是促进代码解耦。在观察者模式中，一个对象订阅另一个对象的指定活动并得到通知，而不是调用另一个对象的方法。订阅者也被叫作观察者，被观察的对象叫作发布者或者被观察者。当一个特定的事件发生的时候，发布者会通知（调用）所有的订阅者，同时还可能以事件对象的形式传递一些消息。</p>
<h3 id="例1：杂志订阅">例1：杂志订阅</h3><p>为了理解观察者模式的实现方式，我们来看一个具体的例子。我们假设有一个发布者<code>paper</code>，它发行一份日报和一份月刊。无论是日报还是月刊发行，有一个名叫<code>joe</code>的订阅者都会收到通知。</p>
<p><code>paper</code>对象有一个<code>subscribers</code>属性，它是一个数组，用来保存所有的订阅者。订阅的过程就仅仅是将订阅者放到这个数组中而已。当一个事件发生时，<code>paper</code>遍历这个订阅者列表，然后通知它们。通知的意思也就是调用订阅者对象的一个方法。因此，在订阅过程中，订阅者需要提供一个方法给<code>paper</code>对象的<code>subscribe()</code>。</p>
<p><code>paper</code>对象也可以提供<code>unsubscribe()</code>方法，它可以将订阅者从数组中移除。<code>paper</code>对象的最后一个重要的方法是<code>publish()</code>，它负责调用订阅者的方法。总结一下，一个发布者对象需要有这些成员：</p>
<ul>
<li><p><code>subscribers</code></p>
<p>  一个数组</p>
</li>
<li><p><code>subscribe()</code></p>
<p>  将订阅者加入数组</p>
</li>
<li><p><code>unsubscribe()</code></p>
<p>  从数组中移除订阅者</p>
</li>
<li><p><code>publish()</code></p>
<p>  遍历订阅者并调用它们订阅时提供的方法</p>
</li>
</ul>
<p>所有三个方法都需要一个<code>type</code>参数，因为一个发布者可能触发好几种事件（比如同时发布杂志和报纸），而订阅者可以选择性地订阅其中的一种或几种。</p>
<p>因为这些成员对任何对象来说都是通用的，因此将它们作为一个单独的对象提取出来是有意义的。然后，我们可以（通过混元模式）将它们复制到任何一个对象中，将这些对象转换为订阅者。</p>
<p>下面是这些发布者通用功能的一个示例实现，它定义了上面列出来的所有成员，还有一个辅助的<code>visitSubscribers()</code>方法：</p>
<pre><code><span class="keyword">var</span> publisher = {
    subscribers: {
        any: [] <span class="comment">// 对应事件类型的订阅者</span>
    },
    subscribe: function (fn, <span class="class"><span class="keyword">type</span>) {</span>
        <span class="class"><span class="keyword">type</span> =</span> <span class="class"><span class="keyword">type</span> <span class="title">||</span> '<span class="title">any</span>';</span>
        <span class="keyword">if</span> (typeof <span class="keyword">this</span>.subscribers[<span class="class"><span class="keyword">type</span>] <span class="title">===</span> "<span class="title">undefined</span>") {</span>
            <span class="keyword">this</span>.subscribers[<span class="class"><span class="keyword">type</span>] =</span> [];
        }
        <span class="keyword">this</span>.subscribers[<span class="class"><span class="keyword">type</span>].<span class="title">push</span>(</span>fn);
    },
    unsubscribe: function (fn, <span class="class"><span class="keyword">type</span>) {</span>
        <span class="keyword">this</span>.visitSubscribers(<span class="symbol">'unsubscrib</span>e', fn, <span class="class"><span class="keyword">type</span>);</span>
    },
    publish: function (publication, <span class="class"><span class="keyword">type</span>) {</span>
        <span class="keyword">this</span>.visitSubscribers(<span class="symbol">'publis</span>h', publication, <span class="class"><span class="keyword">type</span>);</span>
    },
    visitSubscribers: function (action, arg, <span class="class"><span class="keyword">type</span>) {</span>
        <span class="keyword">var</span> pubtype = <span class="class"><span class="keyword">type</span> <span class="title">||</span> '<span class="title">any</span>',
</span>            subscribers = <span class="keyword">this</span>.subscribers[pubtype],
            i,
            max = subscribers.length;

        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; max; i += <span class="number">1</span>) {
            <span class="keyword">if</span> (action === <span class="symbol">'publis</span>h') {
                subscribers[i](arg);
            } <span class="keyword">else</span> {
                <span class="keyword">if</span> (subscribers[i] === arg) {
                    subscribers.splice(i, <span class="number">1</span>);
                }
            }
        }
    }
};
</code></pre><p>下面这个函数接受一个对象作为参数，并通过复制通用发布者的方法将这个对象转变成发布者：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">makePublisher</span><span class="params">(o)</span> </span>{
    <span class="keyword">var</span> i;
    <span class="keyword">for</span> (i <span class="keyword">in</span> publisher) {
        <span class="keyword">if</span> (publisher.hasOwnProperty(i) &amp;&amp; <span class="keyword">typeof</span> publisher[i] === <span class="string">"function"</span>) {
            o[i] = publisher[i];
        }
    }
    o.subscribers = {any: []};
}
</code></pre><p>现在我们来实现<code>paper</code>对象，它能做的事情就是发布日报和月刊：</p>
<pre><code><span class="keyword">var</span> paper = {
    daily: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        <span class="keyword">this</span>.publish(<span class="string">"big news today"</span>);
    },
    monthly: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        <span class="keyword">this</span>.publish(<span class="string">"interesting analysis"</span>, <span class="string">"monthly"</span>);
    }
};
</code></pre><p>将<code>paper</code>对象变成发布者：</p>
<pre><code>makePublisher<span class="list">(<span class="keyword">paper</span>)</span><span class="comment">;</span>
</code></pre><p>现在我们有了一个发布者，让我们再来看一下订阅者对象<code>joe</code>，它有两个方法：<br>    var joe = {<br>        drinkCoffee: function (paper) {<br>            console.log(‘Just read ‘ + paper);<br>        },<br>        sundayPreNap: function (monthly) {<br>            console.log(‘About to fall asleep reading this ‘ + monthly);<br>        }<br>    };</p>
<p>现在让<code>joe</code>来订阅<code>paper</code>：</p>
<pre><code>paper.subscribe(joe.drinkCoffee)<span class="comment">;</span>
paper.subscribe(joe.sundayPreNap, 'monthly')<span class="comment">;</span>
</code></pre><p>如你所见，<code>joe</code>提供了一个当默认的<code>any</code>事件发生时被调用的方法，还提供了另一个当<code>monthly</code>事件发生时被调用的方法。现在让我们来触发一些事件：</p>
<pre><code><span class="tag">paper</span><span class="class">.daily</span>();
<span class="tag">paper</span><span class="class">.daily</span>();
<span class="tag">paper</span><span class="class">.daily</span>();
<span class="tag">paper</span><span class="class">.monthly</span>();
</code></pre><p>这些发布行为都会调用joe的对应方法，控制台中输出的结果是：</p>
<pre><code>Just <span class="keyword">read</span> big <span class="keyword">news</span> today
Just <span class="keyword">read</span> big <span class="keyword">news</span> today
Just <span class="keyword">read</span> big <span class="keyword">news</span> today
<span class="keyword">About</span> to fall asleep reading this interesting analysis
</code></pre><p>这里值得称道的地方就是<code>paper</code>对象并没有硬编码写上<code>joe</code>，而<code>joe</code>也同样没有硬编码写上<code>paper</code>。这里也没有知道所有事情的中介者对象。所有涉及到的对象都是松耦合的，而且在不修改代码的前提下，我们可以给<code>paper</code>添加更多的订阅者，同时<code>joe</code>也可以在任何时候取消订阅。</p>
<p>让我们更进一步，将<code>joe</code>也变成一个发布者。（毕竟，在博客和微博上，任何人都可以是发布者。）这样，<code>joe</code>变成发布者之后就可以在Twitter上更新状态：</p>
<pre><code>makePublisher(joe);
joe.tweet = <span class="function"><span class="keyword">function</span> <span class="params">(msg)</span> </span>{
    <span class="keyword">this</span>.publish(msg);
};
</code></pre><p>现在假设<code>paper</code>的公关部门准备通过<code>Twitter</code>收集读者反馈，于是它订阅了<code>joe</code>，提供了一个方法<code>readTweets()</code>：</p>
<pre><code>paper.readTweets = <span class="function"><span class="keyword">function</span> <span class="params">(tweet)</span> </span>{
    alert(<span class="string">'Call big meeting! Someone '</span> + tweet);
};
joe.subscribe(paper.readTweets);
</code></pre><p>这样每当<code>joe</code>发出消息时，<code>paper</code>就会弹出警告窗口：</p>
<pre><code>joe.tweet<span class="comment">("hated the paper today")</span>;
</code></pre><p>结果是一个警告窗口：“Call big meeting! Someone hated the paper today”。</p>
<p>你可以在<a href="http://jspatterns.com/book/7/observer.html" target="_blank" rel="external">http://jspatterns.com/book/7/observer.html</a>看到完整的源代码，并且在控制台中运行这个实例。</p>
<h3 id="例2：按键游戏">例2：按键游戏</h3><p>我们来看另一个例子。我们将实现一个和中介者模式的示例一样的按钮游戏，但这次使用观察者模式。为了让它看起来更高档，我们允许接受无限个玩家，而不限于2个。我们仍然保留用来产生玩家的<code>Player()</code>构造函数，也保留<code>scoreboard</code>对象，只有<code>mediator</code>会变成<code>game</code>对象。</p>
<p>在中介者模式中，<code>mediator</code>对象知道所有涉及到的对象，并且调用它们的方法。而观察者模式中的<code>game</code>对象不是这样，它会让对象来订阅它们感兴趣的事件。比如，<code>scoreboard</code>会订阅<code>game</code>对象的<code>scorechange</code>事件。</p>
<p>首先我们重新看一下通用的<code>publisher</code>对象，并且将它的接口做一点小修改以更贴近浏览器的情况：</p>
<ul>
<li>将<code>publish()</code>，<code>subscribe()</code>，<code>unsubscribe()</code>分别改为<code>fire()</code>，<code>on()</code>，<code>remove()</code></li>
<li>事件的<code>type</code>每次都会被用到，所以把它变成三个方法的第一个参数</li>
<li>可以给订阅者的方法额外加一个<code>context</code>参数，以便回调方法可以用<code>this</code>指向它自己所属的对象</li>
</ul>
<p>新的<code>publisher</code>对象是这样：</p>
<pre><code><span class="keyword">var</span> publisher = {
    subscribers: {
        any: []
    },
    on: function (<span class="class"><span class="keyword">type</span>, <span class="title">fn</span>, <span class="title">context</span>) {</span>
        <span class="class"><span class="keyword">type</span> =</span> <span class="class"><span class="keyword">type</span> <span class="title">||</span> '<span class="title">any</span>';</span>
        fn = typeof fn === <span class="string">"function"</span> ? fn : context[fn];

        <span class="keyword">if</span> (typeof <span class="keyword">this</span>.subscribers[<span class="class"><span class="keyword">type</span>] <span class="title">===</span> "<span class="title">undefined</span>") {</span>
            <span class="keyword">this</span>.subscribers[<span class="class"><span class="keyword">type</span>] =</span> [];
        }
        <span class="keyword">this</span>.subscribers[<span class="class"><span class="keyword">type</span>].<span class="title">push</span>(</span>{fn: fn, context: context || <span class="keyword">this</span>});
    },
    remove: function (<span class="class"><span class="keyword">type</span>, <span class="title">fn</span>, <span class="title">context</span>) {</span>
        <span class="keyword">this</span>.visitSubscribers(<span class="symbol">'unsubscrib</span>e', <span class="class"><span class="keyword">type</span>, <span class="title">fn</span>, <span class="title">context</span>);</span>
    },
    fire: function (<span class="class"><span class="keyword">type</span>, <span class="title">publication</span>) {</span>
        <span class="keyword">this</span>.visitSubscribers(<span class="symbol">'publis</span>h', <span class="class"><span class="keyword">type</span>, <span class="title">publication</span>);</span>
    },
    visitSubscribers: function (action, <span class="class"><span class="keyword">type</span>, <span class="title">arg</span>, <span class="title">context</span>) {</span>
        <span class="keyword">var</span> pubtype = <span class="class"><span class="keyword">type</span> <span class="title">||</span> '<span class="title">any</span>',
</span>            subscribers = <span class="keyword">this</span>.subscribers[pubtype],
            i,
            max = subscribers ? subscribers.length : <span class="number">0</span>;

        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; max; i += <span class="number">1</span>) {
            <span class="keyword">if</span> (action === <span class="symbol">'publis</span>h') {
                subscribers[i].fn.call(subscribers[i].context, arg);
            } <span class="keyword">else</span> {
                <span class="keyword">if</span> (subscribers[i].fn === arg &amp;&amp; subscribers[i].context === context) {
                    subscribers.splice(i, <span class="number">1</span>);
                }
            }
        }
    }
};
</code></pre><p>新的<code>Player()</code>构造函数是这样：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Player</span><span class="params">(name, key)</span> </span>{
    <span class="keyword">this</span>.points = <span class="number">0</span>;
    <span class="keyword">this</span>.name = name;
    <span class="keyword">this</span>.key = key;
    <span class="keyword">this</span>.fire(<span class="string">'newplayer'</span>, <span class="keyword">this</span>);
}

Player.prototype.play = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="keyword">this</span>.points += <span class="number">1</span>;
    <span class="keyword">this</span>.fire(<span class="string">'play'</span>, <span class="keyword">this</span>);
};
</code></pre><p>变动的部分是这个构造函数接受<code>key</code>，代表这个玩家在键盘上用来按之后得分的按键。（这些键预先被硬编码过。）每次创建一个新玩家的时候，一个<code>newplayer</code>事件也会被触发。类似的，每次有一个玩家玩的时候，会触发<code>play</code>事件。</p>
<p><code>scoreboard</code>对象和原来一样，它只是简单地将当前分数显示出来。</p>
<p><code>game</code>对象会关注所有的玩家，这样它就可以给出分数并且触发<code>scorechange</code>事件。它也会订阅浏览器中所有的·keypress·事件，这样它就会知道按钮对应的玩家：</p>
<pre><code><span class="keyword">var</span> game = {

    keys: {},

    addPlayer: <span class="function"><span class="keyword">function</span> (<span class="params">player</span>) </span>{
        <span class="keyword">var</span> key = player.key.toString().charCodeAt(<span class="number">0</span>);
        <span class="keyword">this</span>.keys[key] = player;
    },

    handleKeypress: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>{
        e = e || <span class="built_in">window</span>.event; <span class="comment">// IE</span>
        <span class="keyword">if</span> (game.keys[e.which]) {
            game.keys[e.which].play();
        }
    },

    handlePlay: <span class="function"><span class="keyword">function</span> (<span class="params">player</span>) </span>{
        <span class="keyword">var</span> i,
            players = <span class="keyword">this</span>.keys,
            score = {};

        <span class="keyword">for</span> (i <span class="keyword">in</span> players) {
            <span class="keyword">if</span> (players.hasOwnProperty(i)) {
                score[players[i].name] = players[i].points;
            }
        }
        <span class="keyword">this</span>.fire(<span class="string">'scorechange'</span>, score);
    }
};
</code></pre><p>用于将任意对象转变为订阅者的<code>makePublisher()</code>还是和之前一样。<code>game</code>对象会变成发布者（这样它才可以触发<code>scorechange</code>事件），<code>Player.prototype</code>也会变成发布者，以使得每个玩家对象可以触发<code>play</code>和<code>newplayer</code>事件：</p>
<pre><code>makePublisher<span class="list">(<span class="keyword">Player</span>.prototype)</span><span class="comment">;</span>
makePublisher<span class="list">(<span class="keyword">game</span>)</span><span class="comment">;</span>
</code></pre><p><code>game</code>对象订阅<code>play</code>和<code>newplayer</code>事件（以及浏览器的<code>keypress</code>事件），<code>scoreboard</code>订阅<code>scorechange</code>事件：</p>
<pre><code>Player.prototype.<span class="keyword">on</span>(<span class="string">"newplayer"</span>, <span class="string">"addPlayer"</span>, game);
Player.prototype.<span class="keyword">on</span>(<span class="string">"play"</span>, <span class="string">"handlePlay"</span>, game);
game.<span class="keyword">on</span>(<span class="string">"scorechange"</span>, scoreboard.<span class="keyword">update</span>, scoreboard);
<span class="keyword">window</span>.onkeypress = game.handleKeypress;
</code></pre><p>如你所见，<code>on()</code>方法允许订阅者通过函数（<code>scoreboard.update</code>）或者是字符串（<code>&quot;addPlayer&quot;</code>）来指定回调函数。当有提供<code>context</code>（如<code>game</code>）时，才能通过字符串来指定回调函数。</p>
<p>初始化的最后一点工作就是动态地创建玩家对象（以及它们对象的按键），用户想要多少个就可以创建多少个：</p>
<pre><code>var playername, <span class="variable">key</span>;
<span class="keyword">while</span> (<span class="number">1</span>) {
    playername = prompt(<span class="string">"Add player (name)"</span>);
    <span class="keyword">if</span> (!playername) {
        <span class="keyword">break</span>;
    }
    <span class="keyword">while</span> (<span class="number">1</span>) {
        <span class="variable">key</span> = prompt(<span class="string">"Key for "</span> + playername + <span class="string">"?"</span>);
        <span class="keyword">if</span> (<span class="variable">key</span>) {
            <span class="keyword">break</span>;
        }
    }
    <span class="keyword">new</span> Player(playername, <span class="variable">key</span>);
}
</code></pre><p>这就是游戏的全部。你可以在<a href="http://www.jspatterns.com/book/7/observer-game.html" target="_blank" rel="external">http://www.jspatterns.com/book/7/observer-game.html</a>看到完整的源代码并且试玩一下。</p>
<p>值得注意的是，在中介者模式中，<code>mediator</code>对象必须知道所有的对象，然后在适当的时机去调用对应的方法。而这个例子中，<code>game</code>对象会显得笨一些（译注：指知道的信息少一些），游戏依赖于对象去观察特定的事件然后触发相应的动作：如<code>scoreboard</code>观察<code>scorechange</code>事件。这使得对象之间的耦合更松了（对象间知道彼此的信息越少越好），而代价则是弄清事件和订阅者之间的对应关系会更困难一些。在这个例子中，所有的订阅行为都发生在代码中的同一个地方，而随着应用规模的境长，<code>on()</code>可能会被在各个地方调用（如在每个对象的初始化代码中）。这使得调试更困难一些，因为没有一个集中的地方来看这些代码并理解正在发生什么事情。在观察者模式中，你将不再能看到那种从开头一直跟到结尾的顺序执行方式。</p>
<h2 id="小结">小结</h2><p>在这章中你学习到了若干种流行的设计模式，并且也知道了如何在JavaScript中实现它们。我们讨论过的设计模式有：</p>
<ul>
<li><p>单例模式</p>
<p>  只创建类的唯一一个实例。我们看了好几种可以不通过构造函数和类Java语法达成单例的方法。从另一方面来说，JavaScript中所有的对象都是单例。有时候开发者说的单例是指通过模块化模式创建的对象。</p>
</li>
<li><p>工厂模式</p>
<p>  一种在运行时通过指定字符串来创建指定类型对象的方法。</p>
</li>
<li><p>遍历模式</p>
<p>  通过提供API来实现复杂的自定义数据结构中的遍历和导航。</p>
</li>
<li><p>装饰模式</p>
<p>  在运行时通过从预先定义好的装饰器对象来给被装饰对象动态添加功能。</p>
</li>
<li><p>策略模式</p>
<p>  保持接口一致的情况下选择最好的策略来完成特定类型的任务。</p>
</li>
<li><p>外观模式</p>
<p>  通过包装通用的（或者设计得很差的）方法来提供一个更方便的API。</p>
</li>
<li><p>代理模式</p>
<p>  包装一个对象以控制对它的访问，通过合并操作或者是只在真正需要时执行来尽量避免开销太大的操作。</p>
</li>
<li><p>中介者模式</p>
<p>  通过让对象不彼此沟通，只通过一个中介者对象沟通的方法来促进解耦。</p>
</li>
<li><p>观察者模式</p>
<p>  通过创建“可被观察的对象”使它在某个事件发生时通知订阅者的方式来解耦。（也叫“订阅者/发布者”或者“自定义事件”。）</p>
</li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/06/javascript/javascript-patterns/chapter8/" itemprop="url">
                第八章 DOM和浏览器中的模式
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-06T22:08:29+08:00" content="2015-12-06">
            2015-12-06
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/12/06/javascript/javascript-patterns/chapter8/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/12/06/javascript/javascript-patterns/chapter8/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>在本书的前面几章中，我们主要关注了JavaScript核心（ECMAScript），并没有涉及太多关于在浏览器中使用JavaScript的内容。在本章，我们将探索一些在浏览器环境中的模式，因为这是最常见的JavaScript程序环境。浏览器脚本编程也是大部分不喜欢JavaScript的人对这门语言的认知。这当然是可以理解，因为在浏览器中有非常多不一致的宿主对象和DOM实现。很明显，任何能够减轻客户端脚本编程的痛楚的最佳实践都是大有益处的。</p>
<p>在本章中，你会看到一些零散的模式，包括DOM编程、事件处理、远程脚本、页面脚本的加载策略以及将JavaScript部署到生产环境的步骤。</p>
<p>但首先，让我们来简要讨论一下如何做客户端脚本编程。</p>
<h2 id="分离">分离</h2><p>在web应用开发中主要关注的有三种东西：</p>
<ul>
<li><p>内容</p>
<p>  即HTML文档</p>
</li>
<li><p>表现</p>
<p>  指定文档样式的CSS</p>
</li>
<li><p>行为</p>
<p>  JavaScript，用来处理用户交互和页面的动态变化</p>
</li>
</ul>
<p>尽可能地将这三者分离可以加强应用在各种用户代理（译注：user agent，即为用户读取页面并呈现的软件，一般指浏览器）的可到达性（译注：delivery，指可被用户代理接受并理解的程度），比如图形浏览器、纯文本浏览器、用于残障人士的辅助技术、移动设备等等。分离常常是和渐进增强的思想一起实现的，我们从一个最基础的体验（纯HTML）开始，它将被用于最简单的用户代理，当用户代理的兼容性提升时再添加更多的可以为体验加分的东西。如果浏览器支持CSS，那么用户会看到文档更好的呈现。如果浏览器支持JavaScript，那文档会更像一个应用，有更多用来增强用户体验的特性。</p>
<p>在实践中，分离意味者：</p>
<ul>
<li>在关掉CSS的情况下测试页面，看页面是否仍然可用，内容是否可以呈现和阅读</li>
<li>在关掉JavaScript的情况下测试页面，确保页面仍然可以完成它的主要功能，所有的链接都可以正常工作（没有href=”#”的链接），表单仍然可以正常填写和提交</li>
<li>不要使用内联的事件处理（如onclick）或者是内联的style属性，因为它们不属于内容层</li>
<li>使用语义化的HTML元素，比如头部和列表等</li>
</ul>
<p>JavaScript（行为）层的地位不应该很显赫，也就是说它不应该成为页面正常工作必须依赖的东西，不应该使得用户在使用不支持的浏览器操作时存在障碍。它只应该被用来增强页面。</p>
<p>通常比较优雅的用来处理浏览器差异的方法是特性检测，它的思想是你不应该使用浏览器类型检测来决定代码的逻辑，而是应该检测在当前环境中你需要使用的某个方法或者是属性是否存在。浏览器检测一般认为是一种“反模式”，虽然有的情况下不可避免要使用，但它应该是最后才考虑的选择，并且应该只在特性检测没有办法给出明确答案（或者造成明显性能问题）的时候使用：</p>
<pre><code><span class="comment">// 反模式</span>
<span class="keyword">if</span> (navigator.userAgent.indexOf(<span class="string">'MSIE'</span>) !== -<span class="number">1</span>) {
    <span class="built_in">document</span>.attachEvent(<span class="string">'onclick'</span>, <span class="built_in">console</span>.log);
}

<span class="comment">// 更好的方式</span>
<span class="keyword">if</span> (<span class="built_in">document</span>.attachEvent) {
    <span class="built_in">document</span>.attachEvent(<span class="string">'onclick'</span>, <span class="built_in">console</span>.log);
}

<span class="comment">// 或者还可以再具体一点</span>
<span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">document</span>.attachEvent !== <span class="string">"undefined"</span>) {
    <span class="built_in">document</span>.attachEvent(<span class="string">'onclick'</span>, <span class="built_in">console</span>.log);
}
</code></pre><p>分离也有助于开发、维护，减少升级一个现有应用的难度，因为当出现问题的时候，你知道去看哪一块。当出现一个JavaScript错误的时候，你不需要去看HTML或者是CSS就能修复它。</p>
<h2 id="DOM编程">DOM编程</h2><p>操作页面的DOM树是在客户端JavaScript编程中最普遍的行为。这也是导致开发者头疼的最主要原因（这也导致了JavaScript名声不好），因为DOM方法在不同的浏览器中实现得有很多差异。这也是为什么使用一个抽象了浏览器差异的JavaScript库能显著提高开发速度的原因。</p>
<p>我们来看一些在访问和修改DOM树时推荐的模式，主要考虑性能方面。</p>
<h3 id="DOM访问">DOM访问</h3><p>DOM操作性能不好，这是影响JavaScript性能的最主要原因。性能不好是因为浏览器的DOM实现通常是和JavaScript引擎分离的。从浏览器的角度来讲，这样做是很有意义的，因为有可能一个JavaScript应用根本不需要DOM，而除了JavaScript之外的其它语言（如IE的VBScript）也可以用来操作页面中的DOM。</p>
<p>一个原则就是DOM访问的次数应该被减少到最低，这意味者：</p>
<ul>
<li>避免在循环中访问DOM</li>
<li>将DOM引用赋给本地变量，然后操作本地变量</li>
<li>当可能的时候使用selectors API</li>
<li>遍历HTML collections时缓存<code>length</code>（见第二章）</li>
</ul>
<p>看下面例子中的第二个循环，尽管它看起来更长一些，但却要快上几十上百倍（取决于具体浏览器）：</p>
<pre><code><span class="comment">// 反模式</span>
<span class="keyword">for</span> (var i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i += <span class="number">1</span>) {
    document.getElementById(<span class="string">"result"</span>).innerHTML += i + <span class="string">", "</span>;
}

<span class="comment">// 更好的方式 - 更新本地变量</span>
var i, content = <span class="string">""</span>;
<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i += <span class="number">1</span>) {
    content += i + <span class="string">","</span>;
}
document.getElementById(<span class="string">"result"</span>).innerHTML += content;
</code></pre><p>在下一个代码片段中，第二个例子（使用了本地变量<code>style</code>）更好，尽管它需要多写一行代码，还需要多定义一个变量：</p>
<pre><code><span class="comment">// 反模式</span>
<span class="keyword">var</span> padding = <span class="built_in">document</span>.getElementById(<span class="string">"result"</span>).style.padding,
    margin = <span class="built_in">document</span>.getElementById(<span class="string">"result"</span>).style.margin;

<span class="comment">// 更好的方式</span>
<span class="keyword">var</span> style = <span class="built_in">document</span>.getElementById(<span class="string">"result"</span>).style,
    padding = style.padding,
    margin = style.margin;
</code></pre><p>使用selectors API是指使用这个方法：</p>
<pre><code><span class="built_in">document</span>.<span class="built_in">querySelector</span>(<span class="string">"ul .selected"</span>);
<span class="built_in">document</span>.<span class="built_in">querySelectorAll</span>(<span class="string">"#widget .class"</span>);
</code></pre><p>这两个方法接受一个CSS选择器字符串，返回匹配这个选择器的DOM列表（译注：<code>querySelector</code>只返回第一个匹配的DOM）。selectors API在现代浏览器（以及IE8+）中可用，它总是会比你使用其它DOM方法来做同样的选择要快。主流的JavaScript库的最新版本都已经使用了这个API，所以你应该去检查你的项目，确保使用的是最新版本。</p>
<p>给你经常访问的元素加上一个<code>id</code>属性也是有好处的，因为<code>document.getElementById(myid)</code>是找到一个DOM元素最容易也是最快的方法。</p>
<h3 id="DOM操作">DOM操作</h3><p>除了访问DOM元素之外，你可能经常需要改变它们、删除其中的一些或者是添加新的元素。更新DOM会导致浏览器重绘（repaint）屏幕，也经常导致重排（reflow，重新计算元素的位置），这些操作代价是很高的。</p>
<p>还是那句话，原则是尽量少地更新DOM，这意味着我们可以将变化集中到一起，然后在“活动的”（live）文档树之外去执行这些变化。</p>
<p>当你需要添加一棵相对较大的子树的时候，你应该在完成这棵树的构建之后再放到文档树中。为了达到这个目的，你可以使用文档碎片（document fragment）来包含你的节点。</p>
<p>不要这样添加节点：</p>
<pre><code><span class="comment">// 反模式</span>
<span class="comment">// 在节点创建后就插入文档</span>

<span class="keyword">var</span> p, t;

p = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);
t = <span class="built_in">document</span>.createTextNode(<span class="string">'first paragraph'</span>);
p.appendChild(t);
<span class="built_in">document</span>.body.appendChild(p);

p = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);
t = <span class="built_in">document</span>.createTextNode(<span class="string">'second paragraph'</span>);
p.appendChild(t);
<span class="built_in">document</span>.body.appendChild(p);
</code></pre><p>一个更好的版本是创建一个文档碎片，然后“离线地”（译注：即不在文档树中）更新它，当它准备好之后再将它加入文档树中。当你将文档碎片添加到DOM树中时，碎片的内容将会被添加进去，而不是碎片本身。这个特性非常好用。所以当有好几个没有被包裹在同一个父元素的节点时，文档碎片是一个很好的包裹方式。</p>
<p>下面是使用文档碎片的例子：</p>
<pre><code><span class="keyword">var</span> p, t, frag;

frag = <span class="built_in">document</span>.createDocumentFragment();

p = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);
t = <span class="built_in">document</span>.createTextNode(<span class="string">'first paragraph'</span>);
p.appendChild(t);
frag.appendChild(p);

p = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);
t = <span class="built_in">document</span>.createTextNode(<span class="string">'second paragraph'</span>);
p.appendChild(t);
frag.appendChild(p);

<span class="built_in">document</span>.body.appendChild(frag);
</code></pre><p>这个例子和前面例子中每段更新一次相比，文档树只被更新了一次，只导致一次重排/重绘。</p>
<p>当你添加新的节点到文档中时，文档碎片很有用。当你需要更新已有的节点时，你也可以将这些变化集中。你可以将你要修改的子树的父节点克隆一份，然后对克隆的这份做修改，完成之后再去替换原来的元素。</p>
<pre><code><span class="keyword">var</span> oldnode = document.getElementById('<span class="literal">result</span>'),
    clone = oldnode.cloneNode(<span class="literal">true</span>);

// 修改克隆后的节点……

// 结束修改之后：
oldnode.parentNode.replaceChild(clone, oldnode);
</code></pre><h2 id="事件">事件</h2><p>在浏览器脚本编程中，另一块充满兼容性问题并且带来很多不愉快的区域就是浏览器事件，比如<code>click</code>，<code>mouseover</code>等等。同样的，一个JavaScript库可以解决支持IE（9以下）和W3C标准实现带来的双倍工作量。</p>
<p>我们来看一下一些主要的点，因为你在做一些简单的页面或者快速开发的时候可能不会使用已有的库，当然，也有可能你正在写你自己的库。</p>
<h3 id="事件处理">事件处理</h3><p>麻烦是从给元素绑定事件开始的。假设你有一个按钮，点击它的时候增加计数器的值。你可以添加一个内联的<code>onclick</code>属性，这在所有的浏览器中都能正常工作，但是会违反分离和渐进增强的思想。所以你应该尽量在JavaScript中来做绑定，而不是在标签中。</p>
<p>假设你有下面的标签：</p>
<pre><code>&lt;button <span class="property">id</span>=<span class="string">"clickme"</span>&gt;Click <span class="keyword">me</span>: <span class="number">0</span>&lt;/button&gt;
</code></pre><p>你可以将一个函数赋给节点的onclick属性，但你只能这样做一次：</p>
<pre><code><span class="comment">// 不好的解决方案</span>
<span class="keyword">var</span> b = <span class="built_in">document</span>.getElementById(<span class="string">'clickme'</span>),
    count = <span class="number">0</span>;

b.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    count += <span class="number">1</span>;
    b.innerHTML = <span class="string">"Click me: "</span> + count;
};
</code></pre><p>如果你希望在按钮点击的时候执行好几个函数，那么在保持松耦合的情况下就不能用这种方法来做绑定。从技术上讲，你可以检测<code>onclick</code>是否已经包含一个函数，如果已经包含，就将它加到你自己的函数中，然后替换<code>onclick</code>的值为你的新函数。但是一个更干净的解决方案是使用<code>addEventListener()</code>方法。这个方法在IE8及以下版本中不存在，在这些浏览器中需要使用<code>attachEvent()</code>。</p>
<p>当我们回头看条件初始化模式（第四章）时，会发现其中的一个示例实现就是一个很好的解决跨浏览器事件监听的套件。现在我们不讨论细节，只看一下如何给我们的按钮绑定事件：</p>
<pre><code><span class="keyword">var</span> b = <span class="built_in">document</span>.getElementById(<span class="string">'clickme'</span>);
<span class="keyword">if</span> (<span class="built_in">document</span>.addEventListener) { <span class="comment">// W3C</span>
    b.addEventListener(<span class="string">'click'</span>, myHandler, <span class="keyword">false</span>);
} <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.attachEvent) { <span class="comment">// IE</span>
    b.attachEvent(<span class="string">'onclick'</span>, myHandler);
} <span class="keyword">else</span> { <span class="comment">// 为保险起见……</span>
    b.onclick = myHandler;
}
</code></pre><p>现在当按钮被点击时，<code>myHandler()</code>会被执行。我们来让这个函数实现增加按钮文字“Click me: 0”中的数字的功能。为了更有趣一点，我们假设有好几个按钮，一个<code>myHandler()</code>函数来处理所有的按钮点击。如果我们可以从每次点击的事件对象中获取节点和节点对应的计数器值，那为每个按钮保持一个引用和计数器就显得不高效了。</p>
<p>我们先看一下解决方案，稍后再来做些评论：</p>
<pre><code>function myHandler(<span class="keyword">e</span>) {

    <span class="keyword">var</span> src, parts;

    <span class="comment">// 获取事件对象和事件来源</span>
    <span class="keyword">e</span> = <span class="keyword">e</span> || <span class="keyword">window</span>.event;
    src = <span class="keyword">e</span>.target || <span class="keyword">e</span>.srcElement;

    <span class="comment">// 真正工作的部分：更新文字</span>
    parts = src.innerHTML.<span class="keyword">split</span>(<span class="string">": "</span>);
    parts[1] = parseInt(parts[1], 10) + 1;
    src.innerHTML = parts[0] + <span class="string">": "</span> + parts[1];

    <span class="comment">// 阻止冒泡</span>
    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">e</span>.stopPropagation === <span class="string">"function"</span>) {
        <span class="keyword">e</span>.stopPropagation();
    }
    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">e</span>.cancelBubble !== <span class="string">"undefined"</span>) {
        <span class="keyword">e</span>.cancelBubble = true;
    }

    <span class="comment">// 阻止默认行为</span>
    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">e</span>.preventDefault === <span class="string">"function"</span>) {
        <span class="keyword">e</span>.preventDefault();
    }
    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">e</span>.returnValue !== <span class="string">"undefined"</span>) {
        <span class="keyword">e</span>.returnValue = false;
    }

}
</code></pre><p>在线的例子可以在<a href="http://jspatterns.com/book/8/click.html" target="_blank" rel="external">http://jspatterns.com/book/8/click.html</a>找到。</p>
<p>在这个事件处理函数中，有四个部分：</p>
<ul>
<li>首先，我们需要访问事件对象，它包含事件的一些信息以及触发这个事件的页面元素。事件对象会被传到事件处理回调函数中，但是使用<code>onclick</code>属性时需要使用全局属性<code>window.event</code>来获取</li>
<li>第二部分是真正用于更新文字的部分</li>
<li>接下来是阻止事件冒泡。在这个例子中它不是必须的，但通常情况下，如果你不阻止的话，事件会一直冒泡到文档根元素甚至<code>window</code>对象。同样的，我们也需要用两种方法来阻止冒泡：W3C标准方式（<code>stopPropagation()</code>）和IE的方式（使用<code>cancelBubble</code>）</li>
<li>最后，如果需要的话，阻止默认行为。有一些事件（点击链接、提交表单）有默认的行为，但你可以使用<code>preventDefault()</code>（IE是通过设置<code>returnValue</code>的值为<code>false</code>的方式）来阻止这些默认行为</li>
</ul>
<p>如你所见，这里涉及到了很多重复性的工作，所以使用第七章讨论过的外观模式创建自己的事件处理套件是很有意义的。</p>
<h3 id="事件委托">事件委托</h3><p>事件委托是通过事件冒泡来实现的，它可以减少分散到各个节点上的事件处理函数的数量。如果有10个按钮在一个<code>div</code>元素中，你可以给<code>div</code>绑定一个事件处理函数，而不是给每个按钮都绑定一个。</p>
<p>我们来看一个实例，三个按钮放在一个<code>div</code>元素中（图8-1）。你可以在<a href="http://jspatterns.com/book/8/click-delegate.html" target="_blank" rel="external">http://jspatterns.com/book/8/click-delegate.html</a>看到这个事件委托的实例。</p>
<blockquote>
<p>译注: 上面的URL中的例子在IE下单击会没有反应,问题在于使用<code>document.attachEvernt()</code>时传递的第一个参数应该是<code>&#39;onclick&#39;</code>，而不是<code>&#39;click&#39;</code>。</p>
</blockquote>
<p><img src="./Figure/chapter8/8-1.jpg" alt="图8-1 事件委托示例：三个在点击时增加计数器值的按钮"></p>
<p>图8-1 事件委托示例：三个在点击时增加计数器值的按钮</p>
<p>结构是这样的：</p>
<pre><code><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"click-wrap"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">button</span>&gt;</span>Click me: 0<span class="tag">&lt;/<span class="title">button</span>&gt;</span>
    <span class="tag">&lt;<span class="title">button</span>&gt;</span>Click me too: 0<span class="tag">&lt;/<span class="title">button</span>&gt;</span>
    <span class="tag">&lt;<span class="title">button</span>&gt;</span>Click me three: 0<span class="tag">&lt;/<span class="title">button</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</code></pre><p>你可以给包裹按钮的<code>div</code>绑定一个事件处理函数，而不是给每个按钮绑定一个。然后你可以使用和前面的示例中一样的<code>myHandler()</code>函数，但需要修改一个小地方：你需要将你不感兴趣的点击排除掉。在这个例子中，你只关注按钮上的点击，而在同一个<code>div</code>中产生的其它的点击应该被忽略掉。</p>
<p><code>myHandler()</code>的改变就是检查事件来源的<code>nodeName</code>是不是<code>&quot;button&quot;</code>:</p>
<pre><code><span class="comment">// ……</span>
<span class="comment">// 获取事件对象和事件来源</span>
<span class="keyword">e</span> = <span class="keyword">e</span> || <span class="keyword">window</span>.event;
src = <span class="keyword">e</span>.target || <span class="keyword">e</span>.srcElement;

<span class="keyword">if</span> (src.nodeName.toLowerCase() !== <span class="string">"button"</span>) {
    <span class="keyword">return</span>;
}
<span class="comment">// ...</span>
</code></pre><p>事件委托的坏处是筛选容器中感兴趣的事件使得代码看起来更多了，但好处是性能的提升和更干净的代码，这个好处明显大于坏处，因此这是一种强烈推荐的模式。</p>
<p>主流的JavaScript库通过提供方便的API的方式使得使用事件委托变得很容易。比如YUI3中有<code>Y.delegate()</code>方法，它允许你指定两个CSS选择器，一个用来匹配包裹容器，一个用来匹配你感兴趣的节点。这很方便，因为如果事件发生在你不关心的元素上时，你的事件处理回调函数不会被调用。在这种情况下，绑定一个事件处理函数很简单：</p>
<pre><code>Y.<span class="keyword">delegate</span>(<span class="string">'click'</span>, myHandler, <span class="string">"#click-wrap"</span>, <span class="string">"button"</span>);
</code></pre><p>感谢YUI抽象了浏览器的差异，已经处理好了事件的来源，使得回调函数更简单了：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">myHandler</span><span class="params">(e)</span> </span>{

    <span class="keyword">var</span> src = e.currentTarget,
        parts;

    parts = src.<span class="keyword">get</span>(<span class="string">'innerHTML'</span>).split(<span class="string">": "</span>);
    parts[<span class="number">1</span>] = parseInt(parts[<span class="number">1</span>], <span class="number">10</span>) + <span class="number">1</span>;
    src.<span class="keyword">set</span>(<span class="string">'innerHTML'</span>, parts[<span class="number">0</span>] + <span class="string">": "</span> + parts[<span class="number">1</span>]);

    e.halt();
}
</code></pre><p>你可以在<a href="http://jspatterns.com/book/8/click-y-delegate.html" target="_blank" rel="external">http://jspatterns.com/book/8/click-y-delegate.html</a>看到实例。</p>
<h2 id="长时间运行的脚本">长时间运行的脚本</h2><p>你可能注意到过，有时候浏览器会提示脚本运行时间过长，询问用户是否要停止执行。不管应用有多复杂，你都不希望这种情况发生在自己的应用中。</p>
<p>同时，如果脚本运行时间太长的话，浏览器的UI将变得没有响应，用户不能点击任何东西。这是一种很差的用户体验，应该尽量避免。</p>
<p>在JavaScript中没有线程，但你可以在浏览器中使用<code>setTimeout()</code>来模拟，或者在现代浏览器中使用web workers。</p>
<h3 id="setTimeout()">setTimeout()</h3><p>它的思想是将一大堆工作分解成为一小段一小段，然后每隔1毫秒运行一段。使用1毫秒的延迟会导致整个任务完成得更慢，但是用户界面会保持可响应状态，用户会觉得浏览器没有失控，觉得更舒服。</p>
<blockquote>
<p>1毫秒（甚至0毫秒）的延迟执行命令在实际运行的时候会延迟更多，这取决于浏览器和操作系统。设定0毫秒的延迟并不意味着马上执行，而是指“尽快执行”。比如，在IE中，最短的延迟是15毫秒。</p>
</blockquote>
<h3 id="Web_Workers">Web Workers</h3><p>现代浏览器为长时间运行的脚本提供了另一种解决方案：web workers。web workers在浏览器内部提供了后台线程支持，你可以将计算量很大的部分放到一个单独的文件中，比如<code>my_web_worker.js</code>，然后从主程序（页面）中这样调用它：</p>
<pre><code><span class="keyword">var</span> ww = <span class="keyword">new</span> Worker(<span class="string">'my_web_worker.js'</span>);
ww.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>{
    <span class="built_in">document</span>.body.innerHTML +=
        <span class="string">"&lt;p&gt;message from the background thread: "</span> + event.data + <span class="string">"&lt;/p&gt;"</span>;
};
</code></pre><p>下面展示了一个做1亿次简单的数学运算的web worker：</p>
<pre><code><span class="keyword">var</span> <span class="keyword">end</span> = <span class="number">1</span>e8, tmp = <span class="number">1</span>;

postMessage(<span class="string">'hello there'</span>);

<span class="keyword">while</span> (<span class="keyword">end</span>) {
    <span class="keyword">end</span> -= <span class="number">1</span>;
    tmp += <span class="keyword">end</span>;
    <span class="keyword">if</span> (<span class="keyword">end</span> === <span class="number">5</span>e7) { // <span class="number">5</span>e7是<span class="number">1</span>e8的一半
        postMessage(<span class="string">'halfway there, `tmp` is now '</span> + tmp);
    }
}

postMessage(<span class="string">'all done'</span>);
</code></pre><p>web worker使用<code>postMessage()</code>来和调用它的程序通讯，调用者通过<code>onmessage</code>事件来接受更新。<code>onmessage</code>事件处理函数接受一个事件对象作为参数，这个对象含有一个由web worker传过来<code>data</code>属性。类似的，调用者（在这个例子中）也可以使用<code>ww.postMessage()</code>来给web worker传递数据，web worker可以通过一个<code>onmessage</code>事件处理函数来接受这些数据。</p>
<p>上面的例子会在浏览器中打印出：</p>
<pre><code>message <span class="built_in">from</span> <span class="operator">the</span> background thread: hello there
message <span class="built_in">from</span> <span class="operator">the</span> background thread: halfway there, `tmp` is now <span class="number">3749999975000001</span> message <span class="built_in">from</span> <span class="operator">the</span> background thread: all done
</code></pre><h2 id="远程脚本编程">远程脚本编程</h2><p>现代web应用经常会使用远程脚本编程和服务器通讯，而不刷新当前页面。这使得web应用更灵活，更像桌面程序。我们来看一下几种用JavaScript和服务器通讯的方法。</p>
<h3 id="XMLHttpRequest">XMLHttpRequest</h3><p>现在，<code>XMLHttpRequest</code>是一个特别的对象（构造函数），绝大多数浏览器都可以用，它使得我们可以从JavaScript来发送HTTP请求。发送一个请求有以下三步：</p>
<ol>
<li>初始化一个<code>XMLHttpRequest</code>对象（简称XHR）</li>
<li>提供一个回调函数，供请求对象状态改变时调用</li>
<li>发送请求</li>
</ol>
<p>第一步很简单：</p>
<pre><code><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();
</code></pre><p>但是在IE7之前的版本中，XHR的功能是使用ActiveX对象实现的，所以需要做一下兼容处理。</p>
<p>第二步是给<code>readystatechange</code>事件提供一个回调函数：</p>
<pre><code>xhr.onreadystatechange = handleResponse<span class="comment">;</span>
</code></pre><p>最后一步是使用<code>open()</code>和<code>send()</code>两个方法触发请求。<code>open()</code>方法用于初始化HTTP请求的方法（如GET，POST）和URL。<code>send()</code>方法用于传递POST的数据，如果是GET方法，则是一个空字符串。<code>open()</code>方法的最后一个参数用于指定这个请求是不是异步的。异步是指浏览器在等待响应的时候不会阻塞，这明显是更好的用户体验，因此除非必须要同步，否则异步参数应该使用true：</p>
<pre><code>xhr.open(<span class="string">"<span class="keyword">GET</span>"</span>, <span class="string">"page.html"</span>, true);
xhr.send();
</code></pre><p>下面是一个完整的示例，它获取新页面的内容，然后将当前页面的内容替换掉（可以在<a href="http://jspatterns.com/book/8/xhr.html" target="_blank" rel="external">http://jspatterns.com/book/8/xhr.html</a>看到示例）：</p>
<pre><code><span class="keyword">var</span> i, xhr, activeXids = [
    <span class="string">'MSXML2.XMLHTTP.3.0'</span>,
    <span class="string">'MSXML2.XMLHTTP'</span>,
    <span class="string">'Microsoft.XMLHTTP'</span>
];

<span class="keyword">if</span> (<span class="keyword">typeof</span> XMLHttpRequest === <span class="string">"function"</span>) { <span class="comment">// native XHR</span>
    xhr = <span class="keyword">new</span> XMLHttpRequest();
} <span class="keyword">else</span> { <span class="comment">// IE7以下</span>
    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; activeXids.length; i += <span class="number">1</span>) {
        <span class="keyword">try</span> {
            xhr = <span class="keyword">new</span> ActiveXObject(activeXids[i]);
            <span class="keyword">break</span>;
        } <span class="keyword">catch</span> (e) {}
    }
}

xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    <span class="keyword">if</span> (xhr.readyState !== <span class="number">4</span>) {
        <span class="keyword">return</span> <span class="literal">false</span>;
    }
    <span class="keyword">if</span> (xhr.status !== <span class="number">200</span>) {
        alert(<span class="string">"Error, status code: "</span> + xhr.status);
        <span class="keyword">return</span> <span class="literal">false</span>;
    }
    <span class="built_in">document</span>.body.innerHTML += <span class="string">"&lt;pre&gt;"</span> + xhr.responseText + <span class="string">"&lt;\/pre&gt;"</span>; };

xhr.open(<span class="string">"GET"</span>, <span class="string">"page.html"</span>, <span class="literal">true</span>);
xhr.send(<span class="string">""</span>);
</code></pre><p>代码中的一些说明：</p>
<ul>
<li>因为IE6及以下版本中，创建XHR对象有一点复杂，所以我们通过一个数组列出ActiveX的名字，然后遍历这个数组，使用<code>try-catch</code>块来尝试创建对象。</li>
<li>回调函数会检查<code>xhr</code>对象的<code>readyState</code>属性。这个属性有0到4一共5个值，4代表“complete”（完成）。如果状态还没有完成，我们就继续等待下一次<code>readystatechange</code>事件。</li>
<li>回调函数也会检查xhr对象的<code>status</code>属性。这个属性和HTTP状态码对应，比如200（OK）或者是404（Not found）。我们只对状态码200感兴趣，而将其它所有的都报为错误（为了简化示例，否则需要检查其它不代表出错的状态码）。</li>
<li>上面的代码会在每次创建XHR对象时检查一遍支持情况。你可以使用前面提到过的模式（如条件初始化）来重写上面的代码，使得只需要做一次检查。</li>
</ul>
<h3 id="JSONP">JSONP</h3><p>JSONP（JSON with padding）是另一种发起远程请求的方式。与XHR不同，它不受浏览器同源策略的限制，所以考虑到加载第三方站点内容的安全问题，使用它时应该很谨慎。</p>
<p>一个XHR请求的返回可以是任何类型的文档：</p>
<ul>
<li>XML文档（过去很常用）</li>
<li>HTML片段（很常用）</li>
<li>JSON数据（轻量、方便）</li>
<li>简单的文本文件及其它</li>
</ul>
<p>而使用JSONP的话，返回的数据格式经常是被一个函数包裹的JSON，具体的函数名称在请求的时候提供。</p>
<p>JSONP的请求URL通常是像这样：</p>
<pre><code><span class="label">http:</span>//example<span class="preprocessor">.org</span>/getdata.php?callback=myHandler
</code></pre><p><code>getdata.php</code>可以是任何类型的页面或者脚本。<code>callback</code>参数指定用来处理响应的JavaScript函数（译注：也就是前面提到的包裹JSON的函数）。</p>
<p>这个URL会被放到一个动态生成的<code>&lt;script&gt;</code>元素中，像这样：</p>
<pre><code>var <span class="keyword">script</span> = document.createElement(<span class="string">"script"</span>);
<span class="keyword">script</span>.src = url;
document.body.appendChild(<span class="keyword">script</span>);
</code></pre><p>服务器返回的JSON数据作为参数被传递给回调函数（函数名在请求时指定，也出现在返回的结果中）。最终的结果实际上是页面中多了一个新的脚本，这个脚本的内容就是一个函数调用，如：</p>
<pre><code>myHandler<span class="list">({<span class="string">"hello"</span>: <span class="string">"world"</span>})</span><span class="comment">;</span>
</code></pre><h4 id="JSONP示例：井字棋">JSONP示例：井字棋</h4><p>我们来看一个使用JSONP的井字棋游戏示例，玩家就是客户端（浏览器）和服务器。它们两者都会产生1到9之间的随机数，我们使用JSONP去取服务器产生的数字（图8-2）。</p>
<p>你可以在<a href="http://jspatterns.com/book/8/ttt.html" target="_blank" rel="external">http://jspatterns.com/book/8/ttt.html</a>玩这个游戏。</p>
<p><img src="./Figure/chapter8/8-2.jpg" alt="图8-2 使用JSONP的井字棋游戏"></p>
<p>图8-2 使用JSONP的井字棋游戏</p>
<p>界面上有两个按钮：一个用于开始新游戏，一个用于取服务器下的棋（客户端下的棋会在一定数量的延时之后自动进行）：</p>
<pre><code><span class="tag">&lt;<span class="title">button</span> <span class="attribute">id</span>=<span class="value">"new"</span>&gt;</span>New game<span class="tag">&lt;/<span class="title">button</span>&gt;</span>
<span class="tag">&lt;<span class="title">button</span> <span class="attribute">id</span>=<span class="value">"server"</span>&gt;</span>Server play<span class="tag">&lt;/<span class="title">button</span>&gt;</span>
</code></pre><p>界面上包含9个单元格，每个都有对应的id，比如：</p>
<pre><code><span class="tag">&lt;<span class="title">td</span> <span class="attribute">id</span>=<span class="value">"cell-1"</span>&gt;</span>&amp;nbsp;<span class="tag">&lt;/<span class="title">td</span>&gt;</span>
<span class="tag">&lt;<span class="title">td</span> <span class="attribute">id</span>=<span class="value">"cell-2"</span>&gt;</span>&amp;nbsp;<span class="tag">&lt;/<span class="title">td</span>&gt;</span>
<span class="tag">&lt;<span class="title">td</span> <span class="attribute">id</span>=<span class="value">"cell-3"</span>&gt;</span>&amp;nbsp;<span class="tag">&lt;/<span class="title">td</span>&gt;</span>
……
</code></pre><p>整个游戏是在一个全局对象<code>ttt</code>中实现：</p>
<pre><code><span class="keyword">var</span> ttt = {
<span class="comment">// 已经下过的棋盘</span>
played: [],

    <span class="comment">// 快捷函数</span>
    get: <span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>{
    <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(id);
},

<span class="comment">// 处理点击</span>
setup: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    <span class="keyword">this</span>.get(<span class="string">'new'</span>).onclick = <span class="keyword">this</span>.newGame;
    <span class="keyword">this</span>.get(<span class="string">'server'</span>).onclick = <span class="keyword">this</span>.remoteRequest;
},

<span class="comment">// 清除棋盘</span>
newGame: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    <span class="keyword">var</span> tds = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"td"</span>),
        max = tds.length,
    i;
    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; max; i += <span class="number">1</span>) {
        tds[i].innerHTML = <span class="string">"&amp;nbsp;"</span>;
    }
    ttt.played = [];
},

<span class="comment">// 发送请求</span>
remoteRequest: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);
    script.src = <span class="string">"server.php?callback=ttt.serverPlay&amp;played="</span> + ttt.played.join(<span class="string">','</span>);
    <span class="built_in">document</span>.body.appendChild(script);
},

<span class="comment">// 回调，服务器下棋</span>
serverPlay: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>{
    <span class="keyword">if</span> (data.error) {
        alert(data.error);
        <span class="keyword">return</span>;
    }

    data = <span class="built_in">parseInt</span>(data, <span class="number">10</span>);
    <span class="keyword">this</span>.played.push(data);

    <span class="keyword">this</span>.get(<span class="string">'cell-'</span> + data).innerHTML = <span class="string">'&lt;span class="server"&gt;X&lt;\/span&gt;'</span>;

    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
        ttt.clientPlay();
    }, <span class="number">300</span>); <span class="comment">// 假装想破脑袋</span>
},

<span class="comment">// 客户端下棋</span>
clientPlay: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    <span class="keyword">var</span> data = <span class="number">5</span>;

    <span class="keyword">if</span> (<span class="keyword">this</span>.played.length === <span class="number">9</span>) {
        alert(<span class="string">"Game over"</span>);
        <span class="keyword">return</span>;
    }

    <span class="comment">// 随机产生数字1 - 9，直到找到空格格</span>
    <span class="keyword">while</span> (<span class="keyword">this</span>.get(<span class="string">'cell-'</span> + data).innerHTML !== <span class="string">"&amp;nbsp;"</span>) {
        data = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">9</span>);
    }
    <span class="keyword">this</span>.get(<span class="string">'cell-'</span> + data).innerHTML = <span class="string">'O'</span>;
    <span class="keyword">this</span>.played.push(data);
}
};
</code></pre><p><code>ttt</code>对象维护着一个已经填过的单元格的列表<code>ttt.played</code>，并且将它发送给服务器，这样服务器就可以返回一个没有玩过的数字。如果有错误发生，服务器会像这样响应：</p>
<pre><code>ttt.serverPlay({<span class="string">"error"</span>: <span class="string">"Error description here"</span>});
</code></pre><p>如你所见，JSONP中的回调函数必须是公开的并且全局可访问的函数，它并不一定要是全局函数，也可以是一个全局对象的方法。如果没有错误发生，服务器将会返回一个函数调用，像这样：</p>
<pre><code>ttt.serverPlay(<span class="number">3</span>);
</code></pre><p>这里的<code>3</code>是指3号单元格是服务器要下棋的位置。在这种情况下，数据非常简单，甚至都不需要使用JSON格式，只需要一个简单的值就可以了。</p>
<h3 id="框架（frame）和图片信标(image_beacon)">框架（frame）和图片信标(image beacon)</h3><p>另外一种做远程脚本编程的方式是使用框架。你可以使用JavaScript来创建框架并改变它的<code>src</code>属性（URL），新URL的页面中可以包含数据和函数调用来更新调用者，也就是框架之外的父页面。</p>
<p>远程脚本编程中最最简单的情况是你只需要传递一点数据给服务器，而并不需要服务器的响应内容。在这种情况下，你可以创建一个新的图片，然后将它的<code>src</code>指向服务器的脚本：</p>
<pre><code><span class="keyword">new</span> Image().src = <span class="string">"http://example.org/some/page.php"</span>;
</code></pre><p>这种模式叫作图片信标，当你想发送一些数据给服务器记录时很有用，比如做访问统计。因为信标的响应对你来说完全是没有用的，所以通常的做法（不推荐）是让服务器返回一个1x1的GIF图片。更好的做法是让服务器返回一个<code>&quot;204 No Content&quot;</code>HTTP响应。这意味着返回给客户端的响应只有响应头（header）而没有响应体（body）。</p>
<h2 id="部署JavaScript">部署JavaScript</h2><p>在生产环境中使用JavaScript时，有不少性能方面的考虑，我们来讨论一下最重要的一些。如果需要了解所有的细节，可以参见O’Reilly出社的《高性能网站建设指南》和《高性能网站建设进阶指南》。</p>
<h3 id="合并脚本">合并脚本</h3><p>创建高性能网站的第一个原则就是尽量减少外部引用的组件（译注：这里指文件），因为HTTP请求的代价是比较大的。具体就JavaScript而言，可以通过合并外部脚本来显著提高页面加载速度。</p>
<p>我们假设你的页面正在使用jQuery库，这是一个<code>.js</code>文件。然后你使用了一些jQuery插件，这些插件也是单独的文件。这样的话在你还一行代码都没有写的时候就已经有了四五个文件了。把这些文件合并起来是很有意义的，尤其是其中的一些体积很小（2-3kb）时，这种情况下，HTTP协议的开销会比下载本身还大。合并脚本的意思就是创建一个新的js文件，然后把每个文件的内容粘贴进去。</p>
<p>当然，合并的操作应该放在代码部署到生产环境之前，而不是在开发环境中，否则会使调试变得困难。</p>
<p>合并脚本的不便之处是：</p>
<ul>
<li><p>在部署前多了一步操作，但这很容易使用命令行自动化工具来做，比如使用Linux/Unix的<code>cat</code>：</p>
<p>  $ cat jquery.js jquery.quickselect.js jquery.limit.js &gt; all.js</p>
</li>
<li>失去一些缓存上的便利——当你对某个文件做了一点小修改之后，会使得整个合并后的代码缓存失效。所以比较好的方法是为大的项目设定一个发布计划，或者是将代码合并为两个文件：一个包含可能会经常变更的代码，另一个包含那些不会轻易变更的“核心”。</li>
<li>你需要处理合并后文件的命名或者是版本问题，比如使用一个时间戳<code>all_20100426.js</code>或者是使用文件内容的hash值。</li>
</ul>
<p>这就是主要的不便之处，但它带来的好处却是远远大于这些麻烦的。</p>
<h3 id="压缩代码">压缩代码</h3><p>第二章中，我们讨论过代码压缩。部署之前进行代码压缩也是一个很重要的步骤。</p>
<p>从用户的角度来想，完全没有必要下载代码中的注释，因为这些注释根本不影响代码运行。</p>
<p>压缩代码能带来多少好处取决于代码中注释和空白的数量，也取决于你使用的压缩工具。平均来说，压缩可以减少50%左右的体积。</p>
<p>服务端脚本压缩也是应该要做的事情。配置启用gzip压缩是一个一次性的工作，能带来立杆见影的速度提升。即使你正在使用共享的空间，供应商并没有提供那么多服务器配置的空间，大部分的供应商也会允许使用<code>.htaccess</code>配置文件。所以可以将这些加入到站点根目录的<code>.htaccess</code>文件中：</p>
<pre><code>AddOutputFilterByType DEFLATE <span class="type">text</span>/html <span class="type">text</span>/css <span class="type">text</span>/plain <span class="type">text</span>/xml <span class="type">application</span>/javascript <span class="type">application</span>/json
</code></pre><p>平均下来压缩会节省70%的文件体积。将代码压缩和服务端压缩合计起来，你的用户只需要下载你写出来的未压缩文件体积的15%左右。</p>
<h3 id="缓存头">缓存头</h3><p>与比较流行的观点相反，其实文件在浏览器缓存中的时间并没有那么久。你可以通过使用<code>Expires</code>头来增加非首次访问时命中缓存的概率：</p>
<p>这也是一个在<code>.htaccess</code>中做的一次性配置工作：</p>
<pre><code><span class="keyword">ExpiresActive</span> <span class="literal">On</span>
<span class="keyword">ExpiresByType</span> application/x-javascript <span class="string">"access plus 10 years"</span>
</code></pre><p>它的弊端是当你想更改这个文件时，你需要给它重命名，如果你已经处理好了合并的文件命名规则，那你就已经处理好这里的命名问题了。</p>
<h3 id="使用CDN">使用CDN</h3><p>CDN是指“文件分发网络”（Content Delivery Network）。这是一项收费（有时候还相当昂贵）的托管服务，它将你的文件分发到世界上各个不同的数据中心，但代码中的URL却都是一样的，这样可以使用户更快地访问。</p>
<p>即使你没有CDN的预算，你仍然有一些可以免费使用的东西：</p>
<ul>
<li>Google托管了很多流行的开源库，你可以免费使用，并从它的CDN中得到速度提升（译注：鉴于Google在国内的尴尬处境，不建议使用）</li>
<li>微软托管了jQuery和自家的Ajax库</li>
<li>雅虎在自己的CDN上托管了YUI库</li>
</ul>
<h2 id="加载策略">加载策略</h2><p>怎样在页面上引入脚本，这是一个看起来很简单的问题——使用<code>&lt;script&gt;</code>元素，然后要么写内联的JavaScript代码要么在<code>src</code>属性中指定一个独立的文件：</p>
<pre><code>// 第一种选择
<span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
<span class="built_in">console</span>.log(<span class="string">"hello world"</span>);
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
// 第二种选择
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"external.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre><p>但是，当你的目标是要构建一个高性能的web应用的时候，有些模式和考虑点还是应该知道的。</p>
<p>作为题外话，来看一些比较常见的开发者会用在<code>&lt;script&gt;</code>元素上的属性：</p>
<ul>
<li><p><code>language=&quot;JavaScript&quot;</code></p>
<p>  还有一些不同大小写形式的<code>&quot;JavaScript&quot;</code>，有的时候还会带上一个版本号。<code>language</code>属性不应该被使用，因为默认的语言就是JavaScript。版本号也不像想象中工作得那么好，这应该是一个设计上的错误。</p>
</li>
<li><p><code>type=&quot;text/javascript&quot;</code></p>
<p>  这个属性是HTML4和XHTML1标准所要求的，但它不应该存在，因为浏览器会假设它就是JavaScript。HTML5不再要求这个属性。除非是要强制通过验证，否则没有任何使用<code>type</code>的理由。</p>
</li>
<li><p><code>defer</code></p>
<p>  （或者是HTML5中更好的<code>async</code>）是一种指定浏览器在下载外部脚本时不阻塞页面其它部分的方法，但还没有被广泛支持。关于阻塞的更多内容会在后面提及。</p>
</li>
</ul>
<h3 id="script元素的位置">script元素的位置</h3><p><code>script</code>元素会阻塞页面的下载。浏览器会同时下载好几个组件（文件），但遇到一个外部脚本的时候，会停止其它的下载，直到脚本文件被下载、解析、执行完毕。这会严重影响页面的加载时间，尤其是当页面加载时发生多次阻塞的时候。</p>
<p>为了尽量减小阻塞带来的影响，你可以将script元素放到页面的尾部，在<code>&lt;/body&gt;</code>之前，这样就没有可以被脚本阻塞的元素了。此时，页面中的其它组件（文件）已经被下载完毕并呈现给用户了。</p>
<p>最坏的“反模式”是在文档的头部使用独立的文件：</p>
<pre><code><span class="doctype">&lt;!doctype html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
<span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>My App<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="comment">&lt;!-- 反模式 --&gt;</span>
    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"jquery.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"jquery.quickselect.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"jquery.lightbox.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"myapp.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;/<span class="title">head</span>&gt;</span>
<span class="tag">&lt;<span class="title">body</span>&gt;</span>
    ……
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</code></pre><p>一个更好的选择是将所有的文件合并起来：</p>
<pre><code><span class="doctype">&lt;!doctype html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
<span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>My App<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"all_20100426.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;/<span class="title">head</span>&gt;</span>
<span class="tag">&lt;<span class="title">body</span>&gt;</span>
    ……
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</code></pre><p>最好的选择是将合并后的脚本放到页面的尾部：</p>
<pre><code><span class="doctype">&lt;!doctype html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
<span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>My App<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
<span class="tag">&lt;/<span class="title">head</span>&gt;</span>
<span class="tag">&lt;<span class="title">body</span>&gt;</span>
    ……
    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"all_20100426.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</code></pre><h3 id="HTTP分块">HTTP分块</h3><p>HTTP协议支持“分块编码”，它允许将页面分成一块一块发送。所以如果你有一个很复杂的页面，你不需要将那些（静态）头部信息也等到所有的服务端工作都完成后再开始发送。</p>
<p>一个简单的策略是在组装页面其余部分的时候将页面<code>&lt;head&gt;</code>的内容作为第一块发送。也就是像这样子：</p>
<pre><code><span class="doctype">&lt;!doctype html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
<span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>My App<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
<span class="tag">&lt;/<span class="title">head</span>&gt;</span>
<span class="comment">&lt;!-- 第一块结束 --&gt;</span>
<span class="tag">&lt;<span class="title">body</span>&gt;</span>
    ……
    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"all_20100426.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span> <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
<span class="comment">&lt;!-- 第二块结束 --&gt;</span>
</code></pre><p>这种情况下可以做一个简单的改动，将JavaScript移回<code>&lt;head&gt;</code>，随着第一块一起发送。</p>
<p>这样的话可以让浏览器在拿到<code>head</code>区内容后就开始下载脚本文件，而此时页面的其它部分在服务端还尚未就绪：</p>
<pre><code><span class="doctype">&lt;!doctype html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
<span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>My App<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"all_20100426.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span> <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">head</span>&gt;</span>
<span class="comment">&lt;!-- 第一块结束 --&gt;</span>
<span class="tag">&lt;<span class="title">body</span>&gt;</span>
    ……
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
<span class="comment">&lt;!-- 第二块结束 --&gt;</span>
</code></pre><p>一个更好的办法是使用第三块内容，让它在页面尾部，只包含脚本。如果有一些每个页面都用到的静态的头部，也可以将这部分随第一块一起发送：</p>
<pre><code><span class="doctype">&lt;!doctype html&gt;</span> <span class="tag">&lt;<span class="title">html</span>&gt;</span>
<span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>My App<span class="tag">&lt;/<span class="title">title</span>&gt;</span> <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
<span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"header"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"logo.png"</span> /&gt;</span>
        ...
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="comment">&lt;!-- 第一块结束 --&gt;</span>

    ... The full body of the page ...

    <span class="comment">&lt;!-- 第二块结束 --&gt;</span>
    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"all_20100426.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
<span class="comment">&lt;!-- 第三块结束 --&gt;</span>
</code></pre><p>这种方法很适合使用渐进增强思想的网站（关键业务不依赖JavaScript）。当HTML的第二块发送完毕的时候，浏览器已经有了一个加载、显示完毕并且可用的页面，就像禁用JavaScript时的情况。当JavaScript随着第三块到达时，它会进一步增强页面，为页面锦上添花。</p>
<h3 id="动态script元素实现非阻塞下载">动态script元素实现非阻塞下载</h3><p>前面已经说到过，JavaScript会阻塞后面文件的下载，但有一些模式可以防止阻塞：</p>
<ul>
<li>使用XHR加载脚本，然后作为一个字符串使用<code>eval()</code>来执行。这种方法受同源策略的限制，而且引入了<code>eval()</code>这种“反模式”`</li>
<li>使用<code>defer</code>和<code>async</code>属性，但有浏览器兼容性问题</li>
<li>使用动态<code>&lt;script&gt;</code>元素</li>
</ul>
<p>最后一种是一个很好并且实际可行的模式。和介绍JSONP时所做的一样，创建一个新的<code>script</code>元素，设置它的<code>src</code>属性，然后将它放到页面上。</p>
<p>这是一个异步加载JavaScript、不阻塞其它文件下载的示例：</p>
<pre><code>var <span class="keyword">script</span> = document.createElement(<span class="string">"script"</span>);
<span class="keyword">script</span>.src = <span class="string">"all_20100426.js"</span>;
document.documentElement.firstChild.appendChild(<span class="keyword">script</span>);
</code></pre><p>这种模式的缺点是，在这之后加载的脚本不能依赖当前加载的这个脚本，因为这个脚本是异步加载的，所以无法保证它什么时候会被加载进来，如果要依赖的话，很可能会访问到（因还未加载完毕导致的）未定义的对象。</p>
<p>如果要解决这个问题，可以让内联的脚本不立即执行，而是作为一个函数放到一个数组中。当依赖的脚本加载完毕后，再执行数组中的所有函数。所以一共有三个步骤。</p>
<p>首先，创建一个数组用来存储所有的内联代码，定义的位置尽量靠前：</p>
<pre><code><span class="variable"><span class="keyword">var</span> mynamespace</span> = {
    inline_scripts: []
};
</code></pre><p>然后你需要将这些单独的内联脚本包裹进一个函数中，然后将每个函数放到<code>inline_scripts</code>数组中，也就是这样：</p>
<pre><code>// 原来的：
// <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"><span class="built_in">console</span>.log(<span class="string">"I am inline"</span>);</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>

// 修改后的：
<span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
    mynamespace.inline_scripts.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
        <span class="built_in">console</span>.log(<span class="string">"I am inline"</span>);
    });
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre><p>最后一步是使用异步加载的脚本遍历这个数组，然后执行函数：</p>
<pre><code>var i, scripts = mynamespace.inline_scripts, <span class="built_in">max</span> = scripts.<span class="built_in">length</span>;
<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">max</span>; <span class="built_in">max</span> += <span class="number">1</span>) {
    scripts[i]();
}
</code></pre><h4 id="插入&lt;script&gt;元素">插入<code>&lt;script&gt;</code>元素</h4><p>通常脚本是插入到文档的<code>&lt;head&gt;</code>中的，但其实你可以插入任何元素中，包括<code>&lt;body&gt;</code>（像JSONP示例中那样）。</p>
<p>在前面的例子中，我们使用<code>documentElement</code>来插到<code>&lt;head&gt;</code>中，因为<code>documentElement</code>就是<code>&lt;html&gt;</code>，它的第一个子元素是<code>&lt;head&gt;</code>：</p>
<pre><code><span class="tag">document</span><span class="class">.documentElement</span><span class="class">.firstChild</span><span class="class">.appendChild</span>(<span class="tag">script</span>);
</code></pre><p>通常也会这样写：</p>
<pre><code><span class="tag">document</span><span class="class">.getElementsByTagName</span>("<span class="tag">head</span>")<span class="attr_selector">[0]</span><span class="class">.appendChild</span>(<span class="tag">script</span>);
</code></pre><p>当你能控制结构的时候，这样做没有问题，但是如果你在写挂件（widget）或者是广告时，你并不知道使用它的是一个什么样的页面。甚至可能页面上连<code>&lt;head&gt;</code>和<code>&lt;body&gt;</code>都没有，尽管<code>document.body</code>在绝大多数没有<code>&lt;body&gt;</code>标签的时候也可以工作：</p>
<pre><code><span class="tag">document</span><span class="class">.body</span><span class="class">.appendChild</span>(<span class="tag">script</span>);
</code></pre><p>可以肯定页面上一定存在的一个标签是你正在运行的脚本所处的位置——<code>script</code>标签。（对内联或者外部文件来说）如果没有<code>script</code>标签，那么代码就不会运行。可以利用这一事实，在页面的第一个<code>script</code>标签上使用<code>insertBefore()</code>：</p>
<pre><code><span class="keyword">var</span> first_script = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'script'</span>)[<span class="number">0</span>];
first_script.parentNode.insertBefore(script, first_script);
</code></pre><p><code>frist_script</code>是页面中一定存在的一个<code>script</code>标签，<code>script</code>是你创建的新的<code>script</code>元素。</p>
<h3 id="延迟加载">延迟加载</h3><p>所谓的延迟加载是指在页面的<code>load</code>事件之后再加载外部文件。通常，将一个大的合并后的文件分成两部分是有好处的：</p>
<ul>
<li>一部分是页面初始化和绑定UI元素的事件处理函数必须的</li>
<li>第二部分是只在用户交互或者其它条件下才会用到的</li>
</ul>
<p>分成两部分的目标就是逐步加载页面，让用户尽快可以进行一些操作。剩余的部分在用户可以看到页面的时候再在后台加载。</p>
<p>加载第二部分JavaScript的方法也是使用动态<code>script</code>元素，将它加在<code>head</code>或者<code>body</code>中：</p>
<pre><code>    ……页面主体部分……

    <span class="comment">&lt;!-- 第二块结束 --&gt;</span>
    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"all_20100426.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
        <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);
        script.src = <span class="string">"all_lazy_20100426.js"</span>;
        <span class="built_in">document</span>.documentElement.firstChild.appendChild(script);
    };
    </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
<span class="comment">&lt;!-- 第三块结束 --&gt;</span>
</code></pre><p>对很多应用来说，延迟加载的部分大部分情况下会比核心部分要大，因为我们关注的“行为”（比如拖放、XHR、动画）只在用户初始化之后才会发生。</p>
<h3 id="按需加载">按需加载</h3><p>前面的模式会在页面加载后无条件加载其它的JavaScript，并假设这些代码很可能会被用到。但我们是否可以做得更好，分部分加载，在真正需要使用的时候才加载那一部分？</p>
<p>假设你页面的侧边栏上有一些tabs。点击tab会发出一个XHR请求获取内容，然后更新tab的内容，然后有一个更新的动画。如果这是页面上唯一需要XHR和动画库的地方，而用户又不点击tab的话会怎样？</p>
<p>下面介绍按需加载模式。你可以创建一个<code>require()</code>函数或者方法，它接受一个需要被加载的脚本文件的文件名，还有一个在脚本被加载完毕后执行的回调函数。</p>
<p><code>require()</code>函数可以被这样使用：</p>
<pre><code><span class="built_in">require</span>(<span class="string">"extra.js"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    functionDefinedInExtraJS();
});
</code></pre><p>我们来看一下如何实现这样一个函数。加载脚本很简单——你只需要按照动态<code>&lt;script&gt;</code>元素模式做就可以了。获知脚本已经加载需要一点点技巧，因为浏览器之间有差异：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">require</span><span class="params">(file, callback)</span> </span>{

    <span class="keyword">var</span> script = document.getElementsByTagName(<span class="string">'script'</span>)[<span class="number">0</span>], newjs = document.createElement(<span class="string">'script'</span>);

    <span class="comment">// IE</span>
    newjs.onreadystatechange = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        <span class="keyword">if</span> (newjs.readyState === <span class="string">'loaded'</span> || newjs.readyState === <span class="string">'complete'</span>) {
            newjs.onreadystatechange = <span class="literal">null</span>;
            <span class="keyword">callback</span>();
        }
    };

    <span class="comment">// 其它浏览器</span>
    newjs.onload = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        <span class="keyword">callback</span>();
    };

    newjs.src = file;
    script.parentNode.insertBefore(newjs, script);
}
</code></pre><p>这个实现的几点说明：</p>
<ul>
<li>在IE中需要监听<code>readystatechange</code>事件，然后判断状态是否为<code>&quot;loaded&quot;</code>或者<code>&quot;complete&quot;</code>。其它的浏览器会忽略这里。</li>
<li>在Firefox，Safari和Opera中，通过<code>onload</code>属性监听load事件。</li>
<li>这个方法在Safari 2中无效。如果必须要处理这个浏览器，需要设一个定时器，周期性地去检查某个指定的变量（在脚本中定义的）是否有定义。当它变成已定义时，就意味着新的脚本已经被加载并执行。</li>
</ul>
<p>你可以通过建立一个人为延迟的脚本来测试这个实现（模拟网络延迟），比如<code>ondemand.js.php</code>，如：</p>
<pre><code>&lt;?php
header(<span class="string">'Content-Type: application/javascript'</span>);
sleep(<span class="number">1</span>);
?&gt;
<span class="function"><span class="keyword">function</span> <span class="title">extraFunction</span>(<span class="params">logthis</span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">'loaded and executed'</span>);
    <span class="built_in">console</span>.log(logthis);
}
</code></pre><p>现在测试<code>require()</code>函数：</p>
<pre><code><span class="built_in">require</span>(<span class="string">'ondemand.js.php'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    extraFunction(<span class="string">'loaded from the parent page'</span>);
    <span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'done!'</span>));
});
</code></pre><p>这段代码会在<code>console</code>中打印两条，然后页面中会显示<code>&quot;done!&quot;</code>，你可以在<a href="http://jspatterns.com/book/7/ondemand.html" target="_blank" rel="external">http://jspatterns.com/book/7/ondemand.html</a>看到示例。</p>
<h3 id="预加载JavaScript">预加载JavaScript</h3><p>在延迟加载模式和按需加载模式中，我们加载了当前页面需要用到的脚本，除此之外，我们也可以加载当前页面不需要但可能在接下来的页面中需要的脚本。这样的话，当用户进入第二个页面时，脚本已经被预加载过，整体体验会变得更快。</p>
<p>预加载可以简单地通过动态脚本模式实现，但这也意味着脚本会被解析和执行。解析仅仅会在页面加载时间中增加预加载消耗的时间，但执行却可能导致JavaScript错误，因为预加载的脚本会假设自己运行在第二个页面上，比如找一个特定的DOM节点就可能出错。</p>
<p>仅加载脚本而不解析和执行是可能的，这也同样适用于CSS和图像。</p>
<p>在IE中，你可以使用熟悉的图片信标模式来发起请求：</p>
<pre><code><span class="keyword">new</span> Image().src = <span class="string">"preloadme.js"</span>;
</code></pre><p>在其它的浏览器中，你可以使用<code>&lt;object&gt;</code>替代<code>script</code>元素，然后将它的<code>data</code>属性指向脚本的URL：</p>
<pre><code><span class="keyword">var</span> obj = <span class="built_in">document</span>.createElement(<span class="string">'object'</span>);
obj.data = <span class="string">"preloadme.js"</span>;
<span class="built_in">document</span>.body.appendChild(obj);
</code></pre><p>为了阻止<code>object</code>可见，你应该设置它的<code>width</code>和<code>height</code>属性为<code>0</code>。</p>
<p>你可以创建一个通用的<code>preload()</code>函数或者方法，使用条件初始化模式（第四章）来处理浏览器差异：</p>
<pre><code><span class="keyword">var</span> preload;
<span class="keyword">if</span> (<span class="comment">/*@cc_on!@*/</span><span class="literal">false</span>) { <span class="comment">// IE支持条件注释</span>
    preload = <span class="function"><span class="keyword">function</span> (<span class="params">file</span>) </span>{
        <span class="keyword">new</span> Image().src = file;
    };
} <span class="keyword">else</span> {
    preload = <span class="function"><span class="keyword">function</span> (<span class="params">file</span>) </span>{
        <span class="keyword">var</span> obj = <span class="built_in">document</span>.createElement(<span class="string">'object'</span>),
            body = <span class="built_in">document</span>.body;

        obj.width = <span class="number">0</span>;
        obj.height = <span class="number">0</span>;
        obj.data = file;
        body.appendChild(obj);
    };
}
</code></pre><p>使用这个新函数：</p>
<pre><code>preload<span class="list">(<span class="quoted">'my_web_worker</span>.js')</span><span class="comment">;</span>
</code></pre><p>这种模式的坏处在于存在用户代理（浏览器）嗅探，但这里无法避免，因为特性检测没有办法告知足够的浏览器行为信息。比如在这个模式中，理论上你可以测试<code>typeof Image</code>是否是<code>&quot;function&quot;</code>来代替嗅探，但这种方法其实没有作用，因为所有的浏览器都支持<code>new Image()</code>；只是有一些浏览器会为图片单独做缓存，意味着作为图片缓存下来的组件（文件）在第二个页面中不会被作为脚本取出来，而是会重新下载。</p>
<blockquote>
<p>浏览器嗅探中使用条件注释很有意思，这明显比在<code>navigator.userAgent</code>中找字符串要安全得多，因为用户可以很容易地修改这些字符串。<br>比如：<br>    var isIE = /<em>@cc_on!@</em>/false;<br>会在其它的浏览器中将<code>isIE</code>设为<code>false</code>（因为忽略了注释），但在IE中会是<code>true</code>，因为在条件注释中有取反运算符<code>!</code>。在IE中就像是这样：<br>    var isIE = !false; // true</p>
</blockquote>
<p>预加载模式可以被用于各种组件（文件），而不仅仅是脚本。比如在登录页就很有用，当用户开始输入用户名时，你可以使用打字的时间开始预加载（非敏感的东西），因为用户很可能会到第二个也就是登录后的页面。</p>
<h2 id="小结">小结</h2><p>在前一章中我们讨论了JavaScript核心的模式，它们与环境无关，这一章主要关注了只在客户端浏览器环境中应用的模式。</p>
<p>我们看了：</p>
<ul>
<li>分离的思想（HTML：内容，CSS：表现，JavaScript：行为），只用于增强体验的JavaScript以及基于特性检测的浏览器探测。（尽管在本章的最后你看到了如何打破这个模式。）</li>
<li>DOM编程——加速DOM访问和操作的模式，主要通过将DOM操作集中在一起来实现，因为频繁和DOM打交道代码是很高的。</li>
<li>事件，跨浏览器的事件处理，以及使用事件代码来减少事件处理函数的绑定数量以提高性能。</li>
<li>两种处理长时间大计算量脚本的模式——使用<code>setTimeout()</code>将长时间操作拆分为小块执行和在现代浏览器中使用web workers。</li>
<li>多种用于远程编程，进行服务器和客户端通讯的模式——XHR，JSONP，框架和图片信标。</li>
<li>在生产环境中部署JavaScript的步骤——将脚本合并为更少的文件，压缩和gzip（总共节省85%），可能的话托管到CDN并发送<code>Expires</code>头来提升缓存效果。</li>
<li>基于性能考虑引入页面脚本的模式，包括：放置<code>&lt;script&gt;</code>元素的位置，同时也可以从HTTP分块获益。为了减少页面初始化时加载大的脚本文件引起的初始化工作量，我们讨论了几种不同的模式，比如延迟加载、预加载和按需加载。</li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/06/javascript/javascript-patterns/README/" itemprop="url">
                JavaScript Patterns Catalog
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-06T22:08:29+08:00" content="2015-12-06">
            2015-12-06
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/12/06/javascript/javascript-patterns/README/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/12/06/javascript/javascript-patterns/README/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><img src="./Figure/cover/front-cover.jpg" alt="JavaScript.patterns"></p>
<p><strong>“JavaScript patterns”中译本</strong> - 《JavaScript 模式》</p>
<ul>
<li>作者：<a href="http://www.phpied.com/" target="_blank" rel="external">Stoyan Stefanov</a></li>
<li>翻译：<a href="http://jayli.github.com/" target="_blank" rel="external">拔赤</a>、<a href="http://goddyzhao.me" target="_blank" rel="external">goddyzhao</a>、<a href="http://www.toobug.net" target="_blank" rel="external">TooBug</a></li>
</ul>
<p>本书从 JavaScript 的实际使用场景出发，提炼了不少有价值的前端实用模式。模式的探索、创新，将永远是程序员自我提升的一条修炼之道，值得一读。</p>
<h1 id="目录">目录</h1><h2 id="第一章_绪言"><a href="./chapter1.markdown">第一章 绪言</a></h2><ul>
<li>模式</li>
<li>JavaScript：概念<ul>
<li>面向对象</li>
<li>没有类</li>
<li>原型</li>
<li>运行环境</li>
</ul>
</li>
<li>ECMAScript 5</li>
<li>JSLint</li>
<li>控制台工具</li>
</ul>
<h2 id="第二章_概要"><a href="./chapter2.markdown">第二章 概要</a></h2><ul>
<li>编写可维护的代码</li>
<li>减少全局对象<ul>
<li>全局变量的问题</li>
<li>忘记var时的副作用</li>
<li>访问全局对象</li>
<li>单var模式</li>
<li>声明提前：分散的var带来的问题</li>
</ul>
</li>
<li>for循环</li>
<li>for-in循环</li>
<li>（不）扩充内置原型</li>
<li>switch模式</li>
<li>避免隐式类型转换<ul>
<li>避免使用eval()</li>
</ul>
</li>
<li>使用parseInt()进行数字转换</li>
<li>代码规范<ul>
<li>缩进</li>
<li>花括号</li>
<li>左花括号的放置</li>
<li>空格</li>
</ul>
</li>
<li>命名规范<ul>
<li>构造函数命名中的大小写</li>
<li>单词分隔</li>
<li>其他命名风格</li>
</ul>
</li>
<li>写注释</li>
<li>写API文档<ul>
<li>示例：YUIDoc</li>
</ul>
</li>
<li>编写易读的代码</li>
<li>同事评审（Peer Reviews）</li>
<li>发布时的代码压缩（Minify）</li>
<li>运行JSLint</li>
<li>小结</li>
</ul>
<h2 id="第三章_字面量和构造函数"><a href="./chapter3.markdown">第三章 字面量和构造函数</a></h2><ul>
<li>对象字面量<ul>
<li>对象字面量语法</li>
<li>通过构造函数创建对象</li>
<li>Object()构造函数的参数</li>
</ul>
</li>
<li>自定义构造函数<ul>
<li>构造函数的返回值</li>
</ul>
</li>
<li>强制使用new的模式<ul>
<li>命名规范</li>
<li>使用that</li>
<li>调用自身的构造函数</li>
</ul>
</li>
<li>数组字面量<ul>
<li>数组字面量语法</li>
<li>Array()构造函数的“陷阱”</li>
<li>检查是否数组</li>
</ul>
</li>
<li>JSON<ul>
<li>使用JSON</li>
</ul>
</li>
<li>正则表达式字面量<ul>
<li>正则表达式字面量语法</li>
</ul>
</li>
<li>原始值的包装对象</li>
<li>错误处理对象</li>
<li>小结</li>
</ul>
<h2 id="第四章_函数"><a href="./chapter4.markdown">第四章 函数</a></h2><ul>
<li>背景知识<ul>
<li>术语</li>
<li>声明 vs 表达式：命名与提前</li>
<li>函数的name属性</li>
<li>声明提前</li>
</ul>
</li>
<li>回调模式<ul>
<li>回调的例子</li>
<li>回调和作用域</li>
<li>异步事件监听</li>
<li>延时</li>
<li>类库中的回调</li>
</ul>
</li>
<li>返回函数</li>
<li>重定义函数</li>
<li>即时函数<ul>
<li>即时函数的参数</li>
<li>即时函数的返回值</li>
<li>好处和用法</li>
</ul>
</li>
<li>对象即时初始化</li>
<li>条件初始化</li>
<li>函数属性——记忆模式（Memoization）</li>
<li>配置对象</li>
<li>柯里化 （Curry）<ul>
<li>函数应用</li>
<li>部分应用</li>
<li>柯里化（Currying）</li>
<li>什么时候使用柯里化</li>
</ul>
</li>
<li>小结</li>
</ul>
<h2 id="第五章_对象创建模式"><a href="./chapter5.markdown">第五章 对象创建模式</a></h2><ul>
<li>命名空间模式<ul>
<li>通用命名空间函数</li>
</ul>
</li>
<li>依赖声明</li>
<li>私有属性和方法<ul>
<li>私有成员</li>
<li>特权方法</li>
<li>私有化成员失效</li>
<li>对象字面量和私有成员</li>
<li>原型和私有成员</li>
<li>将私有函数暴露为共有方法</li>
</ul>
</li>
<li>模块模式<ul>
<li>暴露模块模式</li>
<li>创建构造函数的模块</li>
<li>在模块中引入全局上下文</li>
</ul>
</li>
<li>沙箱模式<ul>
<li>全局构造函数</li>
<li>添加模块</li>
<li>实现构造函数</li>
</ul>
</li>
<li>静态成员<ul>
<li>公有静态成员</li>
<li>私有静态成员</li>
</ul>
</li>
<li>对象常量</li>
<li>链式调用模式<ul>
<li>链式调用模式的利弊</li>
</ul>
</li>
<li>method()方法</li>
<li>小结</li>
</ul>
<h2 id="第六章_代码复用模式"><a href="./chapter6.markdown">第六章 代码复用模式</a></h2><ul>
<li>类式继承 vs 现代继承模式</li>
<li>类式继承的期望结果</li>
<li>类式继承1——默认模式<ul>
<li>跟踪原型链</li>
<li>这种模式的缺点</li>
</ul>
</li>
<li>类式继承2——借用构造函数<ul>
<li>原型链</li>
<li>利用借用构造函数模式实现多继承</li>
<li>借用构造函数的利与弊</li>
</ul>
</li>
<li>类式继承3——借用并设置原型</li>
<li>类式继承4——共享原型</li>
<li>类式继承5——临时构造函数<ul>
<li>存储父类（Superclass）</li>
<li>重置构造函数引用</li>
</ul>
</li>
<li>Klass</li>
<li>原型继承<ul>
<li>讨论</li>
<li>ECMAScript5中的原型继承</li>
</ul>
</li>
<li>通过复制属性继承</li>
<li>混元（Mix-ins）</li>
<li>借用方法<ul>
<li>例：从数组借用</li>
<li>借用并绑定</li>
<li>Function.prototype.bind()</li>
</ul>
</li>
<li>小结</li>
</ul>
<h2 id="第七章_设计模式"><a href="./chapter7.markdown">第七章 设计模式</a></h2><ul>
<li>单例<ul>
<li>使用new</li>
<li>将实例放到静态属性中</li>
<li>将实例放到闭包中</li>
</ul>
</li>
<li>工厂模式<ul>
<li>内置对象工厂</li>
</ul>
</li>
<li>遍历模式</li>
<li>装饰模式<ul>
<li>用法</li>
<li>实现</li>
<li>使用列表实现</li>
</ul>
</li>
<li>策略模式<ul>
<li>数据验证示例</li>
</ul>
</li>
<li>外观模式</li>
<li>代理模式<ul>
<li>一个例子</li>
<li>使用代理对象做缓存</li>
</ul>
</li>
<li>中介者模式<ul>
<li>中介者示例</li>
</ul>
</li>
<li>观察者模式<ul>
<li>例1：杂志订阅</li>
<li>例2：按键游戏</li>
</ul>
</li>
<li>小结</li>
</ul>
<h2 id="第八章_DOM和浏览器模式"><a href="./chapter8.markdown">第八章 DOM和浏览器模式</a></h2><ul>
<li>分离</li>
<li>DOM编程<ul>
<li>DOM访问</li>
<li>DOM操作</li>
</ul>
</li>
<li>事件<ul>
<li>事件处理</li>
<li>事件委托</li>
</ul>
</li>
<li>长时间运行的脚本<ul>
<li>setTimeout()</li>
<li>Web Workers</li>
</ul>
</li>
<li>远程脚本编程<ul>
<li>XMLHttpRequest</li>
<li>JSONP</li>
<li>框架（frame）和图片信标(image beacon)</li>
</ul>
</li>
<li>部署JavaScript<ul>
<li>合并脚本</li>
<li>代码压缩</li>
<li>缓存头</li>
<li>使用CDN</li>
</ul>
</li>
<li>加载策略<ul>
<li>script元素的位置</li>
<li>HTTP分块</li>
<li>动态script元素实现非阻塞下载</li>
<li>延迟加载</li>
<li>按需加载</li>
<li>预加载JavaScript</li>
</ul>
</li>
<li>小结</li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  

            </div>

            

            
        </div>

        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/avatar/avatar.jpg" alt="flycloud" itemprop="image"/>
          <p class="site-author-name" itemprop="name">flycloud</p>
        </div>
        <p class="site-description motion-element" itemprop="description">Stay Hungry,Stay Foolish</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">9</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">1</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
        <div class="footer-inner">
            <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">flycloud</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



        </div>
    </footer>

    <div class="back-to-top"></div>
</div>

<script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>


  
  
  
  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"flycloud"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     
  	<script src="/js/ua-parser.min.js"></script>
  	<script src="/js/hook-duoshuo.js"></script>
  

  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.4"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.4"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.4" id="motion.global"></script>



  <script type="text/javascript" src="/js/search-toggle.js"></script>
  

<a id="hamburger" class="mm-slideout" href="#mmenu"><span></span></a>

<nav id="mmenu">
     <ul>

     </ul>
 </nav>
<link type="text/css" rel="stylesheet" href="/vendors/mmenu/core/css/jquery.mmenu.all.css" />
<link type="text/css" rel="stylesheet" href="http://mmenu.frebsite.nl/mmenu/extensions/css/jquery.mmenu.widescreen.css?v=" media="all and (min-width: 1430px)" />
<link type="text/css" rel="stylesheet" href="/vendors/mmenu/css/flycloudMenu.css" />
<script type="text/javascript" src="/vendors/mmenu/core/js/jquery.mmenu.min.all.js"></script>

<script type="text/javascript">
  $(document).ready(function () {
          $.getJSON("/json/menu.json",function(data){
            $.each( data, function() {
            var html="<li id='" + this.id + "'>" +"<span>"+this.text + "</span></li>"
            var chirldHtml="<ul><li id='"+this.id+"'>"+"<span>"+this.text+"</span></li></ul>"
            if(this.pid==''){
                $('#mmenu>ul:first').append(html);
              }else{
              if($('li#'+this.pid+">ul").length==0){
                 $('#'+this.pid).append(chirldHtml);
              }else{
                $('li#'+this.pid+">ul").append(html);
              }
             }
            });

            
              var html="<li>" +"<a href='/2015/12/06/javascript/javascript-patterns/chapter1/'>"+ " 第一章 绪言</a></li>";
              var chirldHtml="<ul><li>"+"<a href='/2015/12/06/javascript/javascript-patterns/chapter1/'>"+" 第一章 绪言</a></li></ul>"
              
                   if($('li#'+"2>ul").length==0){
                    $('li#'+"2").append(chirldHtml);
                   }else{
                    $('li#'+"2>ul:first").append(html);
                   }

              
            
              var html="<li>" +"<a href='/2015/12/06/javascript/javascript-patterns/chapter2/'>"+ " 第二章 概要</a></li>";
              var chirldHtml="<ul><li>"+"<a href='/2015/12/06/javascript/javascript-patterns/chapter2/'>"+" 第二章 概要</a></li></ul>"
              
                   if($('li#'+"2>ul").length==0){
                    $('li#'+"2").append(chirldHtml);
                   }else{
                    $('li#'+"2>ul:first").append(html);
                   }

              
            
              var html="<li>" +"<a href='/2015/12/06/javascript/javascript-patterns/chapter3/'>"+ " 第三章 字面量和构造函数</a></li>";
              var chirldHtml="<ul><li>"+"<a href='/2015/12/06/javascript/javascript-patterns/chapter3/'>"+" 第三章 字面量和构造函数</a></li></ul>"
              
                   if($('li#'+"2>ul").length==0){
                    $('li#'+"2").append(chirldHtml);
                   }else{
                    $('li#'+"2>ul:first").append(html);
                   }

              
            
              var html="<li>" +"<a href='/2015/12/06/javascript/javascript-patterns/chapter4/'>"+ " 第四章 函数</a></li>";
              var chirldHtml="<ul><li>"+"<a href='/2015/12/06/javascript/javascript-patterns/chapter4/'>"+" 第四章 函数</a></li></ul>"
              
                   if($('li#'+"2>ul").length==0){
                    $('li#'+"2").append(chirldHtml);
                   }else{
                    $('li#'+"2>ul:first").append(html);
                   }

              
            
              var html="<li>" +"<a href='/2015/12/06/javascript/javascript-patterns/chapter5/'>"+ " 第五章 对象创建模式</a></li>";
              var chirldHtml="<ul><li>"+"<a href='/2015/12/06/javascript/javascript-patterns/chapter5/'>"+" 第五章 对象创建模式</a></li></ul>"
              
                   if($('li#'+"2>ul").length==0){
                    $('li#'+"2").append(chirldHtml);
                   }else{
                    $('li#'+"2>ul:first").append(html);
                   }

              
            
              var html="<li>" +"<a href='/2015/12/06/javascript/javascript-patterns/chapter6/'>"+ " 第六章 代码复用模式</a></li>";
              var chirldHtml="<ul><li>"+"<a href='/2015/12/06/javascript/javascript-patterns/chapter6/'>"+" 第六章 代码复用模式</a></li></ul>"
              
                   if($('li#'+"2>ul").length==0){
                    $('li#'+"2").append(chirldHtml);
                   }else{
                    $('li#'+"2>ul:first").append(html);
                   }

              
            
              var html="<li>" +"<a href='/2015/12/06/javascript/javascript-patterns/chapter7/'>"+ " 第七章 设计模式</a></li>";
              var chirldHtml="<ul><li>"+"<a href='/2015/12/06/javascript/javascript-patterns/chapter7/'>"+" 第七章 设计模式</a></li></ul>"
              
                   if($('li#'+"2>ul").length==0){
                    $('li#'+"2").append(chirldHtml);
                   }else{
                    $('li#'+"2>ul:first").append(html);
                   }

              
            
              var html="<li>" +"<a href='/2015/12/06/javascript/javascript-patterns/chapter8/'>"+ " 第八章 DOM和浏览器中的模式</a></li>";
              var chirldHtml="<ul><li>"+"<a href='/2015/12/06/javascript/javascript-patterns/chapter8/'>"+" 第八章 DOM和浏览器中的模式</a></li></ul>"
              
                   if($('li#'+"2>ul").length==0){
                    $('li#'+"2").append(chirldHtml);
                   }else{
                    $('li#'+"2>ul:first").append(html);
                   }

              
            
              var html="<li>" +"<a href='/2015/12/06/javascript/javascript-patterns/README/'>"+ " JavaScript Patterns Catalog</a></li>";
              var chirldHtml="<ul><li>"+"<a href='/2015/12/06/javascript/javascript-patterns/README/'>"+" JavaScript Patterns Catalog</a></li></ul>"
              
                   if($('li#'+"2>ul").length==0){
                    $('li#'+"2").append(chirldHtml);
                   }else{
                    $('li#'+"2>ul:first").append(html);
                   }

              
            

            $('#mmenu').mmenu({
             extensions		: [ 'widescreen', 'theme-white', 'effect-menu-slide', 'pagedim-black','pageshadow'],
             			counters		: true,
             			dividers		: {
             				fixed 	: true
             			},
             			navbar 			: {
             				title	: 'mmenu'
             			},
             			navbars			: [{
             				position: 'top',
             				content : ['searchfield']
             			}, {
             				position: 'top'
             			}, {
             				position: 'bottom',
             				content : ['<div>Hosted by <a href="http://damonflycloud.info" target="_blank">FlyCloud</a></div>']
             			}]
            });
          })


      });
</script>






<script type="text/javascript">
    $(document).ready(function () {
        if (CONFIG.sidebar === 'always') {
            displaySidebar();
        }
    });
</script>




  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"flycloud"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     
  	<script src="/js/ua-parser.min.js"></script>
  	<script src="/js/hook-duoshuo.js"></script>
  

  





<!-- lazyload -->
<script type="text/javascript" src="/js/lazyload.js"></script>
<script type="text/javascript">
    jQuery(function () {
        jQuery("#posts img").lazyload({
            placeholder: "/images/loading.gif",
            effect: "fadeIn"
        });
    });
</script>
</body>
</html>
